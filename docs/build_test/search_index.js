var documenterSearchIndex = {"docs":
[{"location":"meshes/unstructured_quad_mesh.html#Unstructured-quadrilateral-mesh","page":"Unstructured mesh","title":"Unstructured quadrilateral mesh","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"The UnstructuredMesh2D is an unstructured, curvilinear, conforming mesh type in two space dimensions.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the normal::AbstractVector. Rotationally invariant equations such as the compressible Euler equations can use FluxRotated to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the TreeMesh but is usually less efficient, cf. PR #550.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Next, we describe the conventions taken in the implementation for two-dimensional unstructured quadrilateral meshes. Principally, this relates to how a file with the extension .mesh encodes information about the numbering and orientation of elements in an unstructured quadrilateral mesh with possibly curved boundaries.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"We use the following unstructured mesh with three elements for this discussion:","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"(Image: example-mesh)","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Further, a simulation using Trixi on this example unstructured mesh is provided in examples/unstructured_2d_dgsem/elixir_euler_basic.jl.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html#Mesh-file-header","page":"Unstructured mesh","title":"Mesh file header","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"The first two lines of the mesh file lists the mesh file type as well as the total number of corners, surfaces, elements, and the polynomial degree that the mesh will use to represent any curved sides. For the example mesh these quantities are","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"ISM-V2\r\n    7    9    3    8","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"corresponding to seven corners, nine surfaces, and three elements. The mesh polynomial degree of eight is taken only for illustrative purposes. In practice, this mesh polynomial degree depends on the particular application for which the curved, unstructured mesh is required.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html#List-of-corner-nodes","page":"Unstructured mesh","title":"List of corner nodes","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"After these global counts that prescribe information about the mesh skeleton, the mesh file give a list of the physical (x,y) coordinates of all the corners. The corner nodes are listed in the order prescribed by mesh generator. Thus, for the example mesh this node list would be","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":" 1.0    -1.0\r\n 3.0    0.0\r\n 1.0    1.0\r\n 2.0    0.0\r\n 0.0    0.0\r\n 3.0    1.0\r\n 3.0    -1.0","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"The corner nodes are internally referenced by their position in the list above. For example, here the node at (1.0, -1.0) would have node id 1, node id 2 would be at (3.0, 0.0) etc.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html#List-of-neighbor-connectivity","page":"Unstructured mesh","title":"List of neighbor connectivity","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"After the corner list comes the neighbor connectivity along each surface in the mesh. This includes local indexing and orientation information necessary to compute the coupling between elements in the mesh. In 2D each surface is defined by connecting two nodes indexed as with the numbering above. We adopt the convention that node id 1 < node id 2.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Each surface will have two neighbors where the element on the left locally as one \"walks\" from node id 1 to node id 2 is taken to be the primary element and the element locally on the right is taken to be the secondary element. If, however, there is no secondary element index, then the surface lies along a physical boundary. In this case the only available element index is considered to be primary and the secondary index is set to zero.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"The final two index numbers within the neighbor information list are used to identify the local surface within each element. The first local surface index (on the primary element) will always be positive whereas the second local surface index (on the primary element) can be positive or negative. If the second local surface index is positive, then the local coordinate systems in the primary element and secondary element match, i.e., the indexing on either side runs from 1:polydeg+1. However, if the local surface index of the secondary element is negative in the mesh file, then the coordinate system in the secondary element is flipped with respect to the primary element. Therefore, care must be taken in the implementation to ensure that the primary element indexing runs from 1:polydeg+1 whereas the secondary element indexing must run in reverse from polydeg+1:-1:1. Finally, if the secondary element index is zero, then so will be the local surface index because the surface is on a physical boundary. Also, there is no flipping of coordinate indexing required at the physical boundary because only the primary element's coordinate system exists.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html#Three-examples:-One-along-a-physical-boundary-and-two-along-interior-surfaces.","page":"Unstructured mesh","title":"Three examples: One along a physical boundary and two along interior surfaces.","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Along edge {8} we connect node (2) to node (7) and are along a physical boundary in element 3 with the local surface index 1 and the neighbor information:","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    2    7    3    0    1    0","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Along edge {1} we connect node (2) to node (4) such that the primary element is 3 with local surface index 2 and the secondary element is 2 with local surface index 1. Furthermore, we see that coordinate system in the secondary element 2 is flipped with respect to the primary element's coordinate system such that the sign of the local surface index in the secondary element flips. This gives the following neighbor information:","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    2    4    3    2    2    -1","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Along edge {4} we connect node (1) to node (4) such that the primary element is 1 with local surface index 2 and the secondary element is 3 with local surface index 3. The coordinate systems in both elements match and no sign change is required on the local surface index in the secondary element:","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    1    4    1    3    2    3","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"We collect the complete neighbor information for the example mesh above:","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    2    4    3    2    2    -1\r\n    3    5    1    0    4    0\r\n    1    5    1    0    1    0\r\n    1    4    1    3    2    3\r\n    2    6    2    0    2    0\r\n    1    7    3    0    4    0\r\n    3    6    2    0    3    0\r\n    2    7    3    0    1    0\r\n    3    4    2    1    4    -3","category":"page"},{"location":"meshes/unstructured_quad_mesh.html#List-of-elements","page":"Unstructured mesh","title":"List of elements","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Each quadrilateral element in the unstructured mesh is dictated by four corner points with indexing taken from the numbering given by the corner list above. We connect a set of four corner points (starting from the bottom left) in an anti-clockwise fashion thus making the element right-handed indicated using the circular arrow in the figure above. In turn, this right-handedness defines the local surface indexing (i.e. the four local sides) and the local (xi eta) coordinate system. For example, the four corners for element 1 would be listed as","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    5    1    4    3","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"The mesh file also encodes information for curved surfaces either interior to the domain (as surface {9} above) or along the physical boundaries. A set of check digits are included directly below the four corner indexes to indicate whether the local surface index (1, 2, 3, or 4) within the element is straight sided, 0, or is curved, 1. If the local surface is straight sided no additional information is necessary during the mesh file read in. But for any curved surfaces the mesh file provides (x,y) coordinate values in order to construct an interpolant of this surface with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes. This list of (x,y) data will be given in the direction of the local coordinate system.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"The last piece of information provided by the mesh file are labels for the different surfaces of an element. These labels are useful to set boundary conditions along physical surfaces. The labels can be short descriptive words. The label --- indicates an internal surface where no boundary condition is required.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"As an example, the complete information for element 1 in the example mesh would be","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    5    1    4    3\r\n    0    0    1    1\r\n 1.000000000000000   1.000000000000000\r\n 1.024948365654583   0.934461926834452\r\n 1.116583018200151   0.777350964621867\r\n 1.295753434047077   0.606254343587194\r\n 1.537500000000000   0.462500000000000\r\n 1.768263070247418   0.329729152118310\r\n 1.920916981799849   0.185149035378133\r\n 1.986035130050921   0.054554577460044\r\n 2.000000000000000                 0.0\r\n               0.0                 0.0\r\n 0.035513826946206   0.105291711848750\r\n 0.148591270347399   0.317731556850611\r\n 0.340010713990041   0.452219430075470\r\n 0.575000000000000   0.462500000000000\r\n 0.788022294598950   0.483764065630034\r\n 0.926408729652601   0.644768443149389\r\n 0.986453164464803   0.883724792445746\r\n 1.000000000000000   1.000000000000000\r\n Slant --- --- Bezier","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"where the curved boundary information is encoded \"back to back\". That is, the first nine (x,y) nodes in the list above correspond to the interior boundary curve along local side 3 in element 1 and the next nine (x,y) nodes denote the curved physical boundary named Bezier along local side 4.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"We collect the complete set of element information for the example mesh","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"    5    1    4    3\r\n    0    0    1    1\r\n 1.000000000000000   1.000000000000000\r\n 1.024948365654583   0.934461926834452\r\n 1.116583018200151   0.777350964621867\r\n 1.295753434047077   0.606254343587194\r\n 1.537500000000000   0.462500000000000\r\n 1.768263070247418   0.329729152118310\r\n 1.920916981799849   0.185149035378133\r\n 1.986035130050921   0.054554577460044\r\n 2.000000000000000                 0.0\r\n               0.0                 0.0\r\n 0.035513826946206   0.105291711848750\r\n 0.148591270347399   0.317731556850611\r\n 0.340010713990041   0.452219430075470\r\n 0.575000000000000   0.462500000000000\r\n 0.788022294598950   0.483764065630034\r\n 0.926408729652601   0.644768443149389\r\n 0.986453164464803   0.883724792445746\r\n 1.000000000000000   1.000000000000000\r\n Slant --- --- Bezier\r\n    4    2    6    3\r\n    0    0    0    1\r\n 2.000000000000000                 0.0\r\n 1.986035130050921   0.054554577460044\r\n 1.920916981799849   0.185149035378133\r\n 1.768263070247418   0.329729152118310\r\n 1.537500000000000   0.462500000000000\r\n 1.295753434047077   0.606254343587194\r\n 1.116583018200151   0.777350964621867\r\n 1.024948365654583   0.934461926834452\r\n 1.000000000000000   1.000000000000000\r\n --- Right Top ---\r\n    7    2    4    1\r\n    0    0    0    0\r\n Right --- --- Bottom","category":"page"},{"location":"meshes/unstructured_quad_mesh.html#Trixi.jl-on-an-unstructured-quadrilateral-mesh","page":"Unstructured mesh","title":"Trixi.jl on an unstructured quadrilateral mesh","text":"","category":"section"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"We provide an example simulation on an unstructured quadrilateral mesh by executing","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"julia> trixi_include(default_example_unstructured())","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"Note this may download a copy of the mesh file described above for the three element unstructured mesh. This elixir provides the solution for the compressible Euler equations in two spatial dimensions for a smooth propagating wave solution. Below we provide the time evolution of the pressure wave for this example created with the Trixi2Vtk tool and visualized using ParaView.","category":"page"},{"location":"meshes/unstructured_quad_mesh.html","page":"Unstructured mesh","title":"Unstructured mesh","text":"  <!--\r\n  Video creation details\r\n  * Set up terminal size and position appropriately\r\n  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)\r\n  * Upload to YouTube\r\n  * Obtain responsive code by inserting link on https://embedresponsively.com\r\n  -->\r\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/lS8GjuctXAY' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"EditURL = \"<unknown>/docs/literate/src/files/structured_mesh_mapping.jl\"","category":"page"},{"location":"tutorials/structured_mesh_mapping.html#structured_mesh_mapping","page":"14 Structured mesh with curvilinear mapping","title":"14: Structured mesh with curvilinear mapping","text":"","category":"section"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Here, we want to introduce another mesh type of Trixi. More precisely, this tutorial is about the curved mesh type StructuredMesh supporting curved meshes.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html#Creating-a-curved-mesh","page":"14 Structured mesh with curvilinear mapping","title":"Creating a curved mesh","text":"","category":"section"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"There are two basic options to define a curved StructuredMesh in Trixi. You can implement curves for the domain boundaries, or alternatively, set up directly the complete transformation mapping. We now present one short example each.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html#Mesh-defined-by-domain-boundary-curves","page":"14 Structured mesh with curvilinear mapping","title":"Mesh defined by domain boundary curves","text":"","category":"section"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Both examples are based on a semdiscretization of the 2D compressible Euler equations.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"using OrdinaryDiffEq\nusing Trixi\n\nequations = CompressibleEulerEquations2D(1.4)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"We start with a pressure perturbation at (xs, 0.0) as initial condtition.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"function initial_condition_pressure_perturbation(x, t, equations::CompressibleEulerEquations2D)\n  xs = 1.5 # location of the initial disturbance on the x axis\n  w = 1/8 # half width\n  p = exp(-log(2) * ((x[1]-xs)^2 + x[2]^2)/w^2) + 1.0\n  v1 = 0.0\n  v2 = 0.0\n  rho = 1.0\n\n  return prim2cons(SVector(rho, v1, v2, p), equations)\nend\ninitial_condition = initial_condition_pressure_perturbation","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Initialize every boundary as a boundary_condition_slip_wall.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"boundary_conditions = boundary_condition_slip_wall","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"The approximation setup is an entropy-stable split-form DG method with polydeg=4. We are using the two fluxes flux_ranocha and flux_lax_friedrichs.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"solver = DGSEM(polydeg=4, surface_flux=flux_lax_friedrichs,\n               volume_integral=VolumeIntegralFluxDifferencing(flux_ranocha))","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"We want to define a circular cylinder as physical domain. It contains an inner semicircle with radius r0 and an outer semicircle of radius r1.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"(Image: )","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"The domain boundary curves with curve parameter in -11 are sorted as shown in the sketch. They always are orientated from negative to positive coordinate, such that the corners have to fit like this f_1(+1) = f_4(-1), f_3(+1) = f_2(-1), etc.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"In our case we can define the domain boundary curves as follows:","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"r0 = 0.5 # inner radius\nr1 = 5.0 # outer radius\nf1(xi)  = SVector( r0 + 0.5 * (r1 - r0) * (xi + 1), 0.0) # right line\nf2(xi)  = SVector(-r0 - 0.5 * (r1 - r0) * (xi + 1), 0.0) # left line\nf3(eta) = SVector(r0 * cos(0.5 * pi * (eta + 1)), r0 * sin(0.5 * pi * (eta + 1))) # inner circle\nf4(eta) = SVector(r1 * cos(0.5 * pi * (eta + 1)), r1 * sin(0.5 * pi * (eta + 1))) # outer circle","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"We create a curved mesh with 16 x 16 elements. The defined domain boundary curves are passed as a tuple.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"cells_per_dimension = (16, 16)\nmesh = StructuredMesh(cells_per_dimension, (f1, f2, f3, f4), periodicity=false)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Then, we define the simulation with endtime T=3 with semi, ode and callbacks.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    boundary_conditions=boundary_conditions)\n\ntspan = (0.0, 3.0)\node = semidiscretize(semi, tspan)\n\nanalysis_interval = 100\nanalysis_callback = AnalysisCallback(semi, interval=analysis_interval)\n\nalive_callback = AliveCallback(analysis_interval=analysis_interval)\n\nstepsize_callback = StepsizeCallback(cfl=0.9)\n\ncallbacks = CallbackSet(analysis_callback,\n                        alive_callback,\n                        stepsize_callback);\nnothing #hide","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Running the simulation","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"sol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1.0, # solve needs some value here but it will be overwritten by the stepsize_callback\n            save_everystep=false, callback=callbacks);\n\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"pd = PlotData2D(sol)\nplot(pd[\"p\"])\nplot!(getmesh(pd))","category":"page"},{"location":"tutorials/structured_mesh_mapping.html#Mesh-directly-defined-by-the-transformation-mapping","page":"14 Structured mesh with curvilinear mapping","title":"Mesh directly defined by the transformation mapping","text":"","category":"section"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"As mentioned before, you can also define the domain for a StructuredMesh by directly setting up a transformation mapping. Here, we want to present a nice mapping, which is often used to test free-stream preservation. Exact free-stream preservation is a crucial property of any numerical method on curvilinear grids. The mapping is a reduced 2D version of the mapping described in Rueda-Ramírez et al. (2021), p.18.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"using OrdinaryDiffEq\nusing Trixi\n\nequations = CompressibleEulerEquations2D(1.4)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"As mentioned, this mapping is used for testing free-stream preservation. So, we use a constant initial condition.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"initial_condition = initial_condition_constant\n\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"We define the transformation mapping with variables in -1 1 as described in Rueda-Ramírez et al. (2021), p.18 (reduced to 2D):","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"function mapping(xi_, eta_)\n  # Transform input variables between -1 and 1 onto [0,3]\n  xi = 1.5 * xi_ + 1.5\n  eta = 1.5 * eta_ + 1.5\n\n  y = eta + 3/8 * (cos(1.5 * pi * (2 * xi - 3)/3) *\n                   cos(0.5 * pi * (2 * eta - 3)/3))\n\n  x = xi + 3/8 * (cos(0.5 * pi * (2 * xi - 3)/3) *\n                  cos(2 * pi * (2 * y - 3)/3))\n\n  return SVector(x, y)\nend","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Instead of a tuple of boundary functions, the mesh now has the mapping as its parameter.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"cells_per_dimension = (16, 16)\nmesh = StructuredMesh(cells_per_dimension, mapping)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)\n\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan)\n\nanalysis_callback = AnalysisCallback(semi, interval=250)\n\nstepsize_callback = StepsizeCallback(cfl=0.8)\n\ncallbacks = CallbackSet(analysis_callback,\n                        stepsize_callback)\n\nsol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1.0, # solve needs some value here but it will be overwritten by the stepsize_callback\n            save_everystep=false, callback=callbacks);\nnothing #hide","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Now, we want to verify the free-stream preservation property and plot the mesh. For the verification, we calculate the absolute difference of the first conservation variable density u[1] and 1.0. To plot this error and the mesh, we are using the visualization feature ScalarPlotData2D, explained in visualization.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"error_density = let u = Trixi.wrap_array(sol.u[end], semi)\n  abs.(u[1, :, :, :] .- 1.0) # density, x, y, elements\nend\npd = ScalarPlotData2D(error_density, semi)\n\nusing Plots\nplot(pd, title=\"Error in density\")\nplot!(getmesh(pd))","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"We observe that the errors in the variable density are at the level of machine accuracy. Moreover, the plot shows the mesh structure resulting from our transformation mapping.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"Of course, you can also use other mappings as for instance shifts by (x y)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"mapping(xi, eta) = SVector(xi + x, eta + y)","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"or rotations with a rotation matrix T","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"mapping(xi, eta) = T * SVector(xi, eta).","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"For more curved mesh mappings, please have a look at some elixirs for StructuredMesh. For another curved mesh type, there is a tutorial about Trixi's unstructured mesh type [UnstructuredMesh2D] and its use of the High-Order Hex-Quad Mesh (HOHQMesh) generator, created and developed by David Kopriva.","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"","category":"page"},{"location":"tutorials/structured_mesh_mapping.html","page":"14 Structured mesh with curvilinear mapping","title":"14 Structured mesh with curvilinear mapping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"EditURL = \"<unknown>/docs/literate/src/files/upwind_fdsbp.jl\"","category":"page"},{"location":"tutorials/upwind_fdsbp.html#upwind_fdsbp","page":"8 Upwind FD SBP schemes","title":"8: Upwind FD SBP schemes","text":"","category":"section"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"General tensor product SBP methods are supported via the DGMulti solver in a reasonably complete way, see the previous tutorial. Nevertheless, there is also experimental support for SBP methods with other solver and mesh types.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"The first step is to set up an SBP operator. A classical (central) SBP operator can be created as follows.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"using Trixi\nD_SBP = derivative_operator(SummationByPartsOperators.MattssonNordström2004(),\n                            derivative_order=1, accuracy_order=2,\n                            xmin=0.0, xmax=1.0, N=11)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Instead of prefixing the source of coefficients MattssonNordström2004(), you can also load the package SummationByPartsOperators.jl. Either way, this yields an object representing the operator efficiently. If you want to compare it to coefficients presented in the literature, you can convert it to a matrix.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Matrix(D_SBP)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Upwind SBP operators are a concept introduced in 2017 by Ken Mattsson. You can create them as follows.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"D_upw = upwind_operators(SummationByPartsOperators.Mattsson2017,\n                         derivative_order=1, accuracy_order=2,\n                         xmin=0.0, xmax=1.0, N=11)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Upwind operators are derivative operators biased towards one direction. The \"minus\" variants has a bias towards the left side, i.e., it uses values from more nodes to the left than from the right to compute the discrete derivative approximation at a given node (in the interior of the domain). In matrix form, this means more non-zero entries are left from the diagonal.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Matrix(D_upw.minus)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Analogously, the \"plus\" variant has a bias towards the right side.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Matrix(D_upw.plus)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"For more information on upwind SBP operators, please refer to the documentation of SummationByPartsOperators.jl and references cited there.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"The basic idea of upwind SBP schemes is to apply a flux vector splitting and use appropriate upwind operators for both parts of the flux. In 1D, this means to split the flux","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"f(u) = f^-(u) + f^+(u)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"such that f^-(u) is associated with left-going waves and f^+(u) with right-going waves. Then, we apply upwind SBP operators D^- D^+ with an appropriate upwind bias, resulting in","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"partial_x f(u) approx D^+ f^-(u) + D^- f^+(u)","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Note that the established notations of upwind operators D^pm and flux splittings f^pm clash. The right-going waves from f^+ need an operator biased towards their upwind side, i.e., the left side. This upwind bias is provided by the operator D^-.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Many classical flux vector splittings have been developed for finite volume methods and are described in the book \"Riemann Solvers and Numerical Methods for Fluid Dynamics: A Practical Introduction\" of Eleuterio F. Toro (2009), DOI: 10.1007/b79761. One such a well-known splitting provided by Trixi.jl is splitting_steger_warming.","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"Trixi.jl comes with several example setups using upwind SBP methods with flux vector splitting, e.g.,","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"elixir_euler_vortex.jl\nelixir_euler_taylor_green_vortex.jl","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"","category":"page"},{"location":"tutorials/upwind_fdsbp.html","page":"8 Upwind FD SBP schemes","title":"8 Upwind FD SBP schemes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"EditURL = \"<unknown>/docs/literate/src/files/adding_nonconservative_equation.jl\"","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html#adding_nonconservative_equation","page":"10 Adding a non-conservative equation","title":"10: Adding a non-conservative equation","text":"","category":"section"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"If you want to use Trixi for your own research, you might be interested in a new physics model that is not present in Trixi.jl. In this tutorial, we will implement the nonconservative linear advection equation in a periodic domain","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"left\nbeginalignedpartial_t u(tx) + a(x) partial_x u(tx) = 0 \nu(0x)=sin(x) \nu(t-pi)=u(tpi)\nendaligned\nright","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"where a(x) = 2 + cos(x). The analytic solution is","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"u(tx)=-sin left(2 tan ^-1left(sqrt3 tan left(fracsqrt3 t2-tan ^-1left(frac1sqrt3tan left(fracx2right)right)right)right)right)","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"In Trixi.jl, such a mathematical model is encoded as a subtype of Trixi.AbstractEquations.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html#Basic-setup","page":"10 Adding a non-conservative equation","title":"Basic setup","text":"","category":"section"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"Since there is no native support for variable coefficients, we need to transform the PDE to the following system:","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"left\nbeginalignedpartial_t beginpmatrixu(tx)a(tx) endpmatrix +beginpmatrix a(tx) partial_x u(tx)  0 endpmatrix = 0 \nu(0x)=sin(x) \na(0x)=2+cos(x) \nu(t-pi)=u(tpi)\nendaligned\nright","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"# Define new physics\nusing Trixi\nusing Trixi: AbstractEquations, get_node_vars\nimport Trixi: varnames, default_analysis_integrals, flux, max_abs_speed_naive,\n              have_nonconservative_terms\n\n# Since there is no native support for variable coefficients, we use two\n# variables: one for the basic unknown `u` and another one for the coefficient `a`\nstruct NonconservativeLinearAdvectionEquation <: AbstractEquations{1 #= spatial dimension =#,\n                                                                   2 #= two variables (u,a) =#}\nend\n\nvarnames(::typeof(cons2cons), ::NonconservativeLinearAdvectionEquation) = (\"scalar\", \"advection_velocity\")\n\ndefault_analysis_integrals(::NonconservativeLinearAdvectionEquation) = ()\n\n\n# The conservative part of the flux is zero\nflux(u, orientation, equation::NonconservativeLinearAdvectionEquation) = zero(u)\n\n# Calculate maximum wave speed for local Lax-Friedrichs-type dissipation\nfunction max_abs_speed_naive(u_ll, u_rr, orientation::Integer, ::NonconservativeLinearAdvectionEquation)\n    _, advection_velocity_ll = u_ll\n    _, advection_velocity_rr = u_rr\n\n    return max(abs(advection_velocity_ll), abs(advection_velocity_rr))\nend\n\n\n# We use nonconservative terms\nhave_nonconservative_terms(::NonconservativeLinearAdvectionEquation) = Trixi.True()\n\n# This \"nonconservative numerical flux\" implements the nonconservative terms.\n# In general, nonconservative terms can be written in the form\n#   g(u) ∂ₓ h(u)\n# Thus, a discrete difference approximation of this nonconservative term needs\n# - `u mine`:  the value of `u` at the current position (for g(u))\n# - `u_other`: the values of `u` in a neighborhood of the current position (for ∂ₓ h(u))\nfunction flux_nonconservative(u_mine, u_other, orientation,\n                              equations::NonconservativeLinearAdvectionEquation)\n    _, advection_velocity = u_mine\n    scalar, _             = u_other\n\n    return SVector(advection_velocity * scalar, zero(scalar))\nend","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"The implementation of nonconservative terms uses a single \"nonconservative flux\" function flux_nonconservative. It will basically be applied in a loop of the form","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"du_m(D, u) = sum(D[m, l] * flux_nonconservative(u[m], u[l], 1, equations)) # orientation 1: x","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"where D is the derivative matrix and u contains the nodal solution values.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"Now, we can run a simple simulation using a DGSEM discretization.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"# Create a simulation setup\nusing Trixi\nusing OrdinaryDiffEq\n\nequation = NonconservativeLinearAdvectionEquation()\n\n# You can derive the exact solution for this setup using the method of\n# characteristics\nfunction initial_condition_sine(x, t, equation::NonconservativeLinearAdvectionEquation)\n    x0 = -2 * atan(sqrt(3) * tan(sqrt(3) / 2 * t - atan(tan(x[1] / 2) / sqrt(3))))\n    scalar = sin(x0)\n    advection_velocity = 2 + cos(x[1])\n    SVector(scalar, advection_velocity)\nend\n\n# Create a uniform mesh in 1D in the interval [-π, π] with periodic boundaries\nmesh = TreeMesh(-Float64(π), Float64(π), # min/max coordinates\n                initial_refinement_level=4, n_cells_max=10^4)\n\n# Create a DGSEM solver with polynomials of degree `polydeg`\n# Remember to pass a tuple of the form `(conservative_flux, nonconservative_flux)`\n# as `surface_flux` and `volume_flux` when working with nonconservative terms\nvolume_flux  = (flux_central, flux_nonconservative)\nsurface_flux = (flux_lax_friedrichs, flux_nonconservative)\nsolver = DGSEM(polydeg=3, surface_flux=surface_flux,\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))\n\n# Setup the spatial semidiscretization containing all ingredients\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create an ODE problem with given time span\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan)\n\n# Set up some standard callbacks summarizing the simulation setup and computing\n# errors of the numerical solution\nsummary_callback = SummaryCallback()\nanalysis_callback = AnalysisCallback(semi, interval=50)\ncallbacks = CallbackSet(summary_callback, analysis_callback)\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes\n# the passed callbacks\nsol = solve(ode, Tsit5(), abstol=1.0e-6, reltol=1.0e-6,\n            save_everystep=false, callback=callbacks)\n\n# Print the timer summary\nsummary_callback()\n\n# Plot the numerical solution at the final time\nusing Plots: plot\nplot(sol)","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"You see a plot of the final solution.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"We can check whether everything fits together by refining the grid and comparing the numerical errors. First, we look at the error using the grid resolution above.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"error_1 = analysis_callback(sol).l2 |> first","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"Next, we increase the grid resolution by one refinement level and run the simulation again.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"mesh = TreeMesh(-Float64(π), Float64(π), # min/max coordinates\n                initial_refinement_level=5, n_cells_max=10^4)\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan);\n\nsummary_callback = SummaryCallback()\nanalysis_callback = AnalysisCallback(semi, interval=50)\ncallbacks = CallbackSet(summary_callback, analysis_callback);\n\nsol = solve(ode, Tsit5(), abstol=1.0e-6, reltol=1.0e-6,\n            save_everystep=false, callback=callbacks);\nsummary_callback()\n\nerror_2 = analysis_callback(sol).l2 |> first","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"error_1 / error_2","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"As expected, the new error is roughly reduced by a factor of 16, corresponding to an experimental order of convergence of 4 (for polynomials of degree 3).","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html#Summary-of-the-code","page":"10 Adding a non-conservative equation","title":"Summary of the code","text":"","category":"section"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"Here is the complete code that we used (without the callbacks since these create a lot of unnecessary output in the doctests of this tutorial). In addition, we create the struct inside the new module NonconservativeLinearAdvection. That ensures that we can re-create structs defined therein without having to restart Julia.","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"Define new physics","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"module NonconservativeLinearAdvection\n\nusing Trixi\nusing Trixi: AbstractEquations, get_node_vars\nimport Trixi: varnames, default_analysis_integrals, flux, max_abs_speed_naive,\n              have_nonconservative_terms\n\n# Since there is not yet native support for variable coefficients, we use two\n# variables: one for the basic unknown `u` and another one for the coefficient `a`\nstruct NonconservativeLinearAdvectionEquation <: AbstractEquations{1 #= spatial dimension =#,\n                                                                   2 #= two variables (u,a) =#}\nend\n\nvarnames(::typeof(cons2cons), ::NonconservativeLinearAdvectionEquation) = (\"scalar\", \"advection_velocity\")\n\ndefault_analysis_integrals(::NonconservativeLinearAdvectionEquation) = ()\n\n\n# The conservative part of the flux is zero\nflux(u, orientation, equation::NonconservativeLinearAdvectionEquation) = zero(u)\n\n# Calculate maximum wave speed for local Lax-Friedrichs-type dissipation\nfunction max_abs_speed_naive(u_ll, u_rr, orientation::Integer, ::NonconservativeLinearAdvectionEquation)\n    _, advection_velocity_ll = u_ll\n    _, advection_velocity_rr = u_rr\n\n    return max(abs(advection_velocity_ll), abs(advection_velocity_rr))\nend\n\n\n# We use nonconservative terms\nhave_nonconservative_terms(::NonconservativeLinearAdvectionEquation) = Trixi.True()\n\n# This \"nonconservative numerical flux\" implements the nonconservative terms.\n# In general, nonconservative terms can be written in the form\n#   g(u) ∂ₓ h(u)\n# Thus, a discrete difference approximation of this nonconservative term needs\n# - `u mine`:  the value of `u` at the current position (for g(u))\n# - `u_other`: the values of `u` in a neighborhood of the current position (for ∂ₓ h(u))\nfunction flux_nonconservative(u_mine, u_other, orientation,\n                              equations::NonconservativeLinearAdvectionEquation)\n    _, advection_velocity = u_mine\n    scalar, _            = u_other\n\n    return SVector(advection_velocity * scalar, zero(scalar))\nend\n\nend # module\n\n\n\n# Create a simulation setup\nimport .NonconservativeLinearAdvection\nusing Trixi\nusing OrdinaryDiffEq\n\nequation = NonconservativeLinearAdvection.NonconservativeLinearAdvectionEquation()\n\n# You can derive the exact solution for this setup using the method of\n# characteristics\nfunction initial_condition_sine(x, t, equation::NonconservativeLinearAdvection.NonconservativeLinearAdvectionEquation)\n    x0 = -2 * atan(sqrt(3) * tan(sqrt(3) / 2 * t - atan(tan(x[1] / 2) / sqrt(3))))\n    scalar = sin(x0)\n    advection_velocity = 2 + cos(x[1])\n    SVector(scalar, advection_velocity)\nend\n\n# Create a uniform mesh in 1D in the interval [-π, π] with periodic boundaries\nmesh = TreeMesh(-Float64(π), Float64(π), # min/max coordinates\n                initial_refinement_level=4, n_cells_max=10^4)\n\n# Create a DGSEM solver with polynomials of degree `polydeg`\n# Remember to pass a tuple of the form `(conservative_flux, nonconservative_flux)`\n# as `surface_flux` and `volume_flux` when working with nonconservative terms\nvolume_flux  = (flux_central, NonconservativeLinearAdvection.flux_nonconservative)\nsurface_flux = (flux_lax_friedrichs, NonconservativeLinearAdvection.flux_nonconservative)\nsolver = DGSEM(polydeg=3, surface_flux=surface_flux,\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))\n\n# Setup the spatial semidiscretization containing all ingredients\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create an ODE problem with given time span\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan);\n\n# Set up some standard callbacks summarizing the simulation setup and computing\n# errors of the numerical solution\nsummary_callback = SummaryCallback()\nanalysis_callback = AnalysisCallback(semi, interval=50)\ncallbacks = CallbackSet(summary_callback, analysis_callback);\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes\n# the passed callbacks\nsol = solve(ode, Tsit5(), abstol=1.0e-6, reltol=1.0e-6,\n            save_everystep=false);\n\n# Plot the numerical solution at the final time\nusing Plots: plot\nplot(sol);\nnothing #hide","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"","category":"page"},{"location":"tutorials/adding_nonconservative_equation.html","page":"10 Adding a non-conservative equation","title":"10 Adding a non-conservative equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"meshes/dgmulti_mesh.html#DGMulti","page":"DGMulti mesh","title":"Unstructured meshes and the DGMulti solver","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Trixi includes support for simplicial and tensor product meshes via the DGMulti solver type, which is based on the StartUpDG.jl package. DGMulti solvers also provide support for quadrilateral and hexahedral meshes, though this feature is currently restricted to Cartesian grids. On these line/quad/hex meshes, the DGMulti solver also allows to use all (finite domain) SBP derivative operators provided by SummationByPartsOperators.jl, including several finite difference SBP methods.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"We make a few simplifying assumptions about supported meshes:","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"meshes consist of a single type of element\nmeshes are conforming (e.g., each face of an element is shared with at most one other element).\nthe geometric mapping from reference to physical elements is polynomial (currently, only affine mappings are supported).","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"StartUpDG.jl includes both simple uniform meshes via uniform_mesh, as well as support for triangular meshes constructed using Triangulate.jl, a wrapper around Jonathan Shewchuk's Triangle package.","category":"page"},{"location":"meshes/dgmulti_mesh.html#The-DGMulti-solver-type","page":"DGMulti mesh","title":"The DGMulti solver type","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Trixi solvers on simplicial meshes use the [DGMulti](@ref) solver type, which allows users to specify element_type and approximation_type in addition to polydeg, surface_flux, surface_integral, and volume_integral.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"DGMulti(; polydeg::Integer,\r\n          element_type::AbstractElemShape,\r\n          approximation_type=Polynomial(),\r\n          surface_flux=flux_central,\r\n          surface_integral=SurfaceIntegralWeakForm(surface_flux),\r\n          volume_integral=VolumeIntegralWeakForm(),\r\n          RefElemData_kwargs...)","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Here, element_type can be Tri(), Quad(), Tet(), or Hex(), and approximation_type can be","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Polynomial(), which specifies a DG discretization using a polynomial basis using quadrature rules which are exact for degree 2 * polydeg integrands, or\nSBP(), which specifies a DG discretization using multi-dimensional SBP operators. Types of SBP discretizations available include: SBP{Kubatko{LobattoFaceNodes}}() (the default choice), SBP{Kubatko{LegendreFaceNodes}}(), and SBP{Hicken}(). For polydeg = 1, ..., 4, the SBP{Kubatko{LegendreFaceNodes}}() SBP nodes are identical to the SBP nodes of Chen and Shu. More detailed descriptions of each SBP node set can be found in the StartUpDG.jl docs. Trixi will also specialize certain parts of the solver based on the SBP approximation type.\na (periodic or non-periodic) derivative operator from SummationByPartsOperators.jl, usually constructed as D = derivative_operator(...). In this case, you do not need to pass a polydeg. Periodic derivative operators will only work with single-element meshes constructed using DGMultiMesh.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Additional options can also be specified through RefElemData_kwargs:","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"quad_rule_vol = quad_nodes(Tri(), Nq) will substitute in a volume quadrature rule of degree Nq instead of the default (which is a quadrature rule of degree polydeg). Here, a degree Nq rule will be exact for at least degree 2*Nq integrands (such that the mass matrix is integrated exactly). Quadrature rules of which exactly integrate degree Nq integrands may also be specified (for example, quad_rule_vol = StartUpDG.quad_nodes_tri(Nq) on triangles).\nquad_rule_face = quad_nodes(Line(), Nq)) will use a face quadrature rule of degree Nq rather than the default. This rule is also exact for at least degree 2*Nq integrands.","category":"page"},{"location":"meshes/dgmulti_mesh.html#The-GaussSBP()-approximation-type-on-Quad()-and-Hex()-meshes","page":"DGMulti mesh","title":"The GaussSBP() approximation type on Quad() and Hex() meshes","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"When using VolumeIntegralFluxDifferencing on Quad() and Hex() meshes, one can also specify approximation_type = GaussSBP() to use an entropy stable Gauss collocation scheme. Here, GaussSBP() refers to \"generalized\" summation-by-parts operators (see for example Ranocha 2018 or Fernandez and Zingg 2015).","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Unlike traditional SBP operators, generalized SBP operators are constructed from nodes which do not include boundary nodes (i.e., Gauss quadrature nodes as opposed to Gauss-Lobatto quadrature nodes). This makes the computation of interface fluxes slightly more expensive, but also usually results in a more accurate solution. Roughly speaking, an entropy stable Gauss collocation scheme will yield results similar to a modal entropy stable scheme using a Polynomial() approximation type, but will be more efficient at high orders of approximation.","category":"page"},{"location":"meshes/dgmulti_mesh.html#Trixi-elixirs-on-simplicial-and-tensor-product-element-meshes","page":"DGMulti mesh","title":"Trixi elixirs on simplicial and tensor product element meshes","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Example elixirs with triangular, quadrilateral, and tetrahedral meshes can be found in the examples/dgmulti_2d and examples/dgmulti_3d folders. Some key elixirs to look at:","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"examples/dgmulti_2d/elixir_euler_weakform.jl: basic weak form DG discretization on a uniform triangular mesh. Changing element_type = Quad() or approximation_type = SBP() will switch to a quadrilateral mesh or an SBP-type discretization. Changing surface_integral = SurfaceIntegralWeakForm(flux_ec) and volume_integral = VolumeIntegralFluxDifferencing(flux_ec) for some entropy conservative flux (e.g., flux_chandrashekar or flux_ranocha) will switch to an entropy conservative formulation.\nexamples/dgmulti_2d/elixir_euler_triangulate_pkg_mesh.jl: uses an unstructured mesh generated by Triangulate.jl.\nexamples/dgmulti_3d/elixir_euler_weakform.jl: basic weak form DG discretization on a uniform tetrahedral mesh. Changing element_type = Hex() will switch to a hexahedral mesh. Changing surface_integral = SurfaceIntegralWeakForm(flux_ec) and volume_integral = VolumeIntegralFluxDifferencing(flux_ec) for some entropy conservative flux (e.g., flux_chandrashekar or flux_ranocha) will switch to an entropy conservative formulation.","category":"page"},{"location":"meshes/dgmulti_mesh.html#For-developers","page":"DGMulti mesh","title":"For developers","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html#DGMultiMesh-wrapper-type","page":"DGMulti mesh","title":"DGMultiMesh wrapper type","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"DGMulti meshes in Trixi are represented using a DGMultiMesh{NDIMS, ...} type. This mesh type is assumed to have fields md::MeshData, which contains geometric terms derived from the mapping between the reference and physical elements, and boundary_faces, which contains a Dict of boundary segment names (symbols) and list of faces which lie on that boundary segment.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"A DGMultiMesh can be constructed in several ways. For example, DGMultiMesh(dg::DGMulti) will return a Cartesian mesh on -1 1^d with element types specified by dg. DGMulti meshes can also be constructed by specifying a list of vertex coordinates vertex_coordinates_x, vertex_coordinates_y, vertex_coordinates_z and a connectivity matrix EToV where EToV[e,:] gives the vertices which correspond to element e. These quantities are available from most unstructured mesh generators.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Initial support for curved DGMultiMeshes is available for flux differencing solvers using SBP and GaussSBP approximation types on quadrilateral and hexahedral meshes. These can be called by specifying mesh = DGMultiMesh(dg, cells_per_dimension, mapping), where mapping is a function which specifies the warping of the mesh (e.g., mapping(xi, eta) = SVector{2}(xi, eta) is the identity mapping) similar to the mapping argument used by StructuredMesh.","category":"page"},{"location":"meshes/dgmulti_mesh.html#Variable-naming-conventions","page":"DGMulti mesh","title":"Variable naming conventions","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"We use the convention that coordinates on the reference element are r in 1D, r s in 2D, or r s t in 3D. Physical coordinates use the standard conventions x (1D), x y (2D), and x y z (3D).","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"(Image: \"Ref-to-physical mapping\")","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Derivatives of reference coordinates with respect to physical coordinates are abbreviated, e.g., fracpartial rpartial x = r_x. Additionally, J is used to denote the determinant of the Jacobian of the reference-to-physical mapping.","category":"page"},{"location":"meshes/dgmulti_mesh.html#Variable-meanings-and-conventions-in-StartUpDG.jl","page":"DGMulti mesh","title":"Variable meanings and conventions in StartUpDG.jl","text":"","category":"section"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"StartUpDG.jl exports structs RefElemData{NDIMS, ElemShape, ...} (which contains data associated with the reference element, such as interpolation points, quadrature rules, face nodes, normals, and differentiation/interpolation/projection matrices) and MeshData{NDIMS} (which contains geometric data associated with a mesh). These are currently used for evaluating DG formulations in a matrix-free fashion. These structs contain fields similar (but not identical) to those in Globals1D, Globals2D, Globals3D in the Matlab codes from \"Nodal Discontinuous Galerkin Methods\" by Hesthaven and Warburton (2007).","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"In general, we use the following code conventions:","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"variables such as r, s,... and x, y,... correspond to values at nodal interpolation points.\nvariables ending in q (e.g., rq, sq,... and xq, yq,...) correspond to values at volume quadrature points.\nvariables ending in f (e.g., rf, sf,... and xf, yf,...) correspond to values at face quadrature points.\nvariables ending in p (e.g., rp, sp,...) correspond to \"plotting\" points, which are usually a fine grid of equispaced points.\nV matrices correspond to interpolation matrices from nodal interpolation points, e.g., Vq interpolates to volume quadrature points, Vf interpolates to face quadrature points.\ngeometric quantities in MeshData are stored as matrices of dimension textnumber of points per element times textnumber of elements.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Quantities in rd::RefElemData:","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"rd.Np, rd.Nq, rd.Nf: the number of nodal interpolation points, volume quadrature points, and face quadrature points on the reference element, respectively.\nrd.Vq: interpolation matrices from values at nodal interpolation points to volume quadrature points\nrd.wq: volume quadrature weights on the reference element\nrd.Vf: interpolation matrices from values at nodal interpolation points to face quadrature points\nrd.wf: a vector containing face quadrature weights on the reference element\nrd.M: the quadrature-based mass matrix, computed via rd.Vq' * diagm(rd.wq) * rd.Vq.\nrd.Pq: a quadrature-based L^2 projection matrix rd.Pq = rd.M \\ rd.Vq' * diagm(rd.wq) which maps between values at quadrature points and values at nodal points.\nDr, Ds, Dt matrices are nodal differentiation matrices with respect to the rst coordinates, e.g., Dr*f.(r,s) approximates the derivative of f(rs) at nodal points.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"Quantities in md::MeshData:","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"md.xyz is a tuple of matrices md.x, md.y, md.z, where column e contains coordinates of physical interpolation points.\nmd.xyzq is a tuple of matrices md.xq, md.yq, md.zq, where column e contains coordinates of physical quadrature points.\nmd.rxJ, md.sxJ, ... are matrices where column e contains values of Jfracpartial rpartial x, Jfracpartial spartial x, etc. at nodal interpolation points on the element e.\nmd.J is a matrix where column e contains values of the Jacobian J at nodal interpolation points.\nmd.Jf is a matrix where column e contains values of the face Jacobian (e.g., determinant of the geometric mapping between a physical face and a reference face) at face quadrature points.\nmd.nxJ, md.nyJ, ... are matrices where column e contains values of components of the unit normal scaled by the face Jacobian md.Jf at face quadrature points.","category":"page"},{"location":"meshes/dgmulti_mesh.html","page":"DGMulti mesh","title":"DGMulti mesh","text":"For more details, please see the StartUpDG.jl docs.","category":"page"},{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Trixi is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as merge requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Trixi and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing.html#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\r\nVersion 1.1\r\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\r\n1 Letterman Drive\r\nSuite D4700\r\nSan Francisco, CA, 94129\r\n\nEveryone is permitted to copy and distribute verbatim copies of this\r\nlicense document, but changing it is not allowed.\r\n\n\nDeveloper's Certificate of Origin 1.1\r\n\nBy making a contribution to this project, I certify that:\r\n\n(a) The contribution was created in whole or in part by me and I\r\n    have the right to submit it under the open source license\r\n    indicated in the file; or\r\n\n(b) The contribution is based upon previous work that, to the best\r\n    of my knowledge, is covered under an appropriate open source\r\n    license and I have the right under that license to submit that\r\n    work with modifications, whether created in whole or in part\r\n    by me, under the same open source license (unless I am\r\n    permitted to submit under a different license), as indicated\r\n    in the file; or\r\n\n(c) The contribution was provided directly to me by some other\r\n    person who certified (a), (b) or (c) and I have not modified\r\n    it.\r\n\n(d) I understand and agree that this project and the contribution\r\n    are public and that a record of the contribution (including all\r\n    personal information I submit with it, including my sign-off) is\r\n    maintained indefinitely and may be redistributed consistent with\r\n    this project or the open source license(s) involved.","category":"page"},{"location":"development.html#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development.html#interactive-use-of-julia","page":"Development","title":"Interactive use of Julia","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"When a Julia program is executed, Julia first loads and parses all code. Then, the just-in-time compiler has to compile all functions at their first use, which incurs an overhead each time a program is run. For proper packages and commands executed in the REPL (= \"return-eval-print loop\", which is what the Julia community calls the interactive command-line prompt that opens when executing julia without any files as arguments), however, the previously compiled functions are cached. Therefore, Trixi should generally always be used interactively from the REPL without closing Julia during development, as it allows much faster turnaround times.","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"If you naively run Trixi from the REPL, you will not be able to change your Trixi source files and then run the changed code without restarting the REPL, which destroys any potential benefits from caching. However, restarting Julia can be avoided by using the Revise.jl package, which tracks changed files and re-loads them automatically. Therefore, it is highly recommended to first install Revise with the following command in Julia: To enter the package REPL mode, press ] in the standard Julia REPL mode. Then, execute","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"(@v1.8) pkg> add Revise","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"Now you are able to run Trixi from the REPL, change Trixi code between runs, and enjoy the advantages of the compilation cache! Before you start using Revise regularly, please be aware of some of the Pitfalls when using Revise.","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"Another recommended package for working from the REPL is OhMyREPL.jl. It can be installed by running","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"(@v1.8) pkg> add OhMyREPL","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"and adds syntax highlighting, bracket highlighting, and other helpful improvements for using Julia interactively. To automatically use OhMyREPL when starting the REPL, follow the instructions given in the official documentation.","category":"page"},{"location":"development.html#Running-Trixi-interactively-in-the-global-environment","page":"Development","title":"Running Trixi interactively in the global environment","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"If you've installed Trixi and Revise in your default environment, begin by executing:","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"This will start the Julia REPL. Then, run","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia> using Revise; using Trixi","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"You can run a simulation by executing","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia> trixi_include(default_example())","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"Together, all of these commands can take some time, roughly half a minute on a modern workstation. Most of the time is spent on compilation of Julia code etc. If you execute the last command again in the same REPL, it will finish within a few milliseconds (maybe ~45 on a modern workstation).  This demonstrates the second reason for using the REPL: the compilation cache.  That is, those parts of the code that do not change between two Trixi runs do not need to be recompiled and thus execute much faster after the first run.","category":"page"},{"location":"development.html#Manually-starting-Trixi-in-the-local-environment","page":"Development","title":"Manually starting Trixi in the local environment","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"If you followed the installation instructions for developers, execute Julia with the project directory set to the run directory of the program/tool you want to use. For example, to run Trixi this way, you need to start the REPL with","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia --project=path/to/Trixi.jl/run","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"and execute","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia> using Revise; using Trixi","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"to load Revise and Trixi. You can then proceed with the usual commands and run Trixi as in the example above. The --project flag is required such that Julia can properly load Trixi and all dependencies if Trixi is not installed in the global environment. The same procedure also applies should you opt to install the postprocessing tool Trixi2Vtk manually such that you can modify their implementations.","category":"page"},{"location":"development.html#Pitfalls-when-using-Revise","page":"Development","title":"Pitfalls when using Revise","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"While Revise is a great help for developing Julia code, there are a few situations to watch out for when using Revise. The following list of potential issues is based on personal experiences of the Trixi developers and probably incomplete.  Further information on limitations and possible issues with Revise can be found in the official documentation.","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"tip: If in doubt, restart the REPL\nOftentimes, it is possible to recover from issues with Revise by fixing the offending code. Sometimes, however, this is not possible or you might have troubles finding out what exactly caused the problems. Therefore, in these cases, or if in doubt, restart the REPL to get a fresh start.","category":"page"},{"location":"development.html#Syntax-errors-are-easy-to-miss","page":"Development","title":"Syntax errors are easy to miss","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"Revise does not stop on syntax errors, e.g., when you accidentally write a[i) instead of a[i].  In this case, Revise reports an error but continues to use the old version of your files! This is especially dangerous for syntax errors, as they are detected while Revise reloads changed code, which happens in the beginning of a new execution. Thus, the syntax error message quickly disappears from the terminal once Trixi starts writing output to the screen and you might not even have noticed that an error occurred at all.","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"Therefore, when you are deep in a coding/debugging session and wonder why your code modifications do not seem to have any effect, scroll up in your terminal to check if you missed earlier syntax errors, or - if in doubt - restart your REPL.","category":"page"},{"location":"development.html#Files-are-not-tracked-after-changing-branches","page":"Development","title":"Files are not tracked after changing branches","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"Sometimes, Revise stops tracking files when changing the Git branch. That is, modifications to Trixi's source files will not be reloaded by Revise and thus have no effect of a currently running REPL session. This issue is particularly annoying for a developer, since it does not come with any warning!  Therefore, it is good practice to always restart the REPL after changing branches.","category":"page"},{"location":"development.html#Changes-to-type-definitions-are-not-allowed","page":"Development","title":"Changes to type definitions are not allowed","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"Revise cannot handle changes to type definitions, e.g., when modifying the fields in a struct. In this case, Revise reports an error and refuses to run your code unless you undo the modifications. Once you undo the changes, Revise will usually continue to work as expected again. However, if you want to keep your type modifications, you need to restart the REPL.","category":"page"},{"location":"development.html#Using-the-Julia-REPL-effectively","page":"Development","title":"Using the Julia REPL effectively","text":"","category":"section"},{"location":"development.html","page":"Development","title":"Development","text":"The Julia manual is an excellent resource to learn Julia. Here, we list some helpful commands than can increase your productivity in the Julia REPL.","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"Use the REPL help mode entered by typing ?. ```julia-repl julia> using Trixi","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"help?> trixiinclude   search: trixiinclude","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"trixi_include([mod::Module=Main,] elixir::AbstractString; kwargs...)\r\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific\r\nassignments in elixir by supplying keyword arguments. It's basic purpose is to make it easier to modify some\r\nparameters while running Trixi from the REPL. Additionally, this is used in tests to reduce the computational\r\nburden for CI while still providing examples with sensible default values for users.\r\n\nExamples\r\n≡≡≡≡≡≡≡≡≡≡\r\n\njulia> trixi_include(@__MODULE__, default_example(), tspan=(0.0, 0.1))\r\n[...]\r\n\njulia> sol.t[end]\r\n0.1","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"- You can copy and paste REPL history including `julia>` prompts into the REPL.\r\n- Use tab completion in the REPL, both for names of functions/types/variables and\r\n  for function arguments.\r\n  ```julia-repl\r\n  julia> flux_ranocha( # and TAB\r\n  flux_ranocha(u_ll, u_rr, orientation::Integer, equations::CompressibleEulerEquations1D) in Trixi at ~/.julia/dev/Trixi/src/equations/compressible_euler_1d.jl:390\r\n  flux_ranocha(u_ll, u_rr, orientation::Integer, equations::CompressibleEulerEquations2D) in Trixi at ~/.julia/dev/Trixi/src/equations/compressible_euler_2d.jl:839\r\n  [...]\r\n  ```\r\n- Use `methodswith` to discover methods associated to a given type etc.\r\n  ```julia-repl\r\n  julia> methodswith(CompressibleEulerEquations2D)\r\n  [1] initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations2D) in Trixi at ~/.julia/dev/Trixi/src/equations/compressible_euler_2d.jl:51\r\n  [...]\r\n  ```\r\n- Use `@which` (or `@edit`) for method calls.\r\n  ```julia-repl\r\n  julia> @which trixi_include(default_example())\r\n  trixi_include(elixir::AbstractString; kwargs...) in Trixi at ~/.julia/dev/Trixi/src/auxiliary/special_elixirs.jl:36\r\n  ```\r\n- Use `apropos` to search through the documentation and docstrings.\r\n  ```julia-repl\r\n  julia> apropos(\"MHD\")\r\n  Trixi.IdealGlmMhdEquations3D\r\n  Trixi.IdealGlmMhdMulticomponentEquations2D\r\n  Trixi.calc_fast_wavespeed_roe\r\n  Trixi.IdealGlmMhdEquations1D\r\n  Trixi.initial_condition_constant\r\n  Trixi.flux_nonconservative_powell\r\n  Trixi.GlmSpeedCallback\r\n  Trixi.flux_derigs_etal\r\n  Trixi.flux_hindenlang_gassner\r\n  Trixi.initial_condition_convergence_test\r\n  Trixi.min_max_speed_naive\r\n  Trixi.IdealGlmMhdEquations2D\r\n  Trixi.IdealGlmMhdMulticomponentEquations1D\r\n  [...]\r\n  ```\r\n\r\n\r\n## Text editors\r\nWhen writing code, the choice of text editor can have a significant impact on\r\nproductivity and developer satisfaction. While using the default text editor\r\nof the operating system has its own benefits (specifically the lack of an explicit\r\ninstallation procure), usually it makes sense to switch to a more\r\nprogramming-friendly tool. In the following, a few of the many options are\r\nlisted and discussed:\r\n\r\n### VS Code\r\n[Visual Studio Code](https://code.visualstudio.com/) is a modern open source\r\neditor with [good support for Julia](https://github.com/julia-vscode/julia-vscode).\r\nWhile [Juno](#Juno) had some better support in the past, the developers of Juno\r\nand the Julia VS Code plugin are joining forces and concentrating on VS Code\r\nsince support of Atom has been suspended. Basically, all comments on [Juno](#Juno)\r\nbelow also apply to VS Code.\r\n\r\n### Juno\r\nIf you are new to programming or do not have a preference for a text editor\r\nyet, [Juno](https://junolab.org) is a good choice for developing Julia code.\r\nIt is based on *Atom*, a sophisticated and widely used editor for software\r\ndevelopers, and is enhanced with several Julia-specific features. Furthermore\r\nand especially helpful for novice programmers, it has a MATLAB-like\r\nappearance with easy and interactive access to the current variables, the\r\nhelp system, and a debugger.\r\n\r\n### Vim or Emacs\r\nVim and Emacs are both very popular editors that work great with Julia. One\r\nof their advantages is that they are text editors without a GUI and as such\r\nare available for almost any operating system. They also are preinstalled on\r\nvirtually all Unix-like systems.  However, Vim and Emacs come with their own,\r\nsteep learning curve if they have never been used before. Therefore, if in doubt, it\r\nis probably easier to get started with a classic GUI-based text editor (like\r\nJuno). If you decide to use Vim or Emacs, make sure that you install the\r\ncorresponding Vim plugin\r\n[julia-vim](https://github.com/JuliaEditorSupport/julia-vim) or Emacs major\r\nmode [julia-emacs](https://github.com/JuliaEditorSupport/julia-emacs).\r\n\r\n\r\n## Debugging\r\nJulia offers several options for debugging. A classical debugger is available with the\r\n[Debugger.jl](https://github.com/JuliaDebug/Debugger.jl) package or in the\r\n[Julia extension for VS Code](https://www.julia-vscode.org/docs/stable/userguide/debugging/).\r\nHowever, it can be quite slow and, at the time of writing (January 2023), currently does not work\r\nproperly with Trixi. The [Infiltrator.jl](https://github.com/JuliaDebug/Infiltrator.jl) package on\r\nthe other hand does not offer all features of a full debugger, but is a fast and simple tool that\r\nallows users to set breakpoints to open a local REPL session and access the call stack and variables.\r\n\r\n### Infiltrator\r\nThe Infiltrator package provides fast, interactive breakpoints using the ```@infiltrate``` command,\r\nwhich drops the user into a local REPL session. From there, it is possible to access local variables,\r\nsee the call stack, and execute statements.\r\n\r\nThe package can be installed in the Julia REPL by executing","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia-repl (@v1.8) pkg> add Infiltrator","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"\r\nTo load the package in the Julia REPL execute","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia-repl julia> using Infiltrator","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"\r\nBreakpoints can be set by adding a line with the ```@infiltrate``` macro at the respective position\r\nin the code. Use [Revise](@ref interactive-use-of-julia) if you want to set and delete breakpoints\r\nin your package without having to restart Julia.\r\n\r\n!!! note\r\n    When running Julia inside a package environment, the ```@infiltrate``` macro only works if `Infiltrator`\r\n    has been added to the dependencies. Another work around when using Revise is to first load the\r\n    package and then add breakpoints with `Main.@infiltrate` to the code. If this is not\r\n    desired, the functional form\r\n    ```julia\r\n    if isdefined(Main, :Infiltrator)\r\n      Main.Infiltrator.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\r\n    end\r\n    ```\r\n    can be used to set breakpoints when working with Trixi or other packages.\r\n\r\nTriggering the breakpoint starts a REPL session where it is possible to interact with the current\r\nlocal scope. Possible commands are:\r\n- ```@locals```: Print the local variables.\r\n- ```@exfiltrate```: Save the local variables to a global storage, which can be accessed with\r\n  the ```safehouse``` variable outside the Infiltrator session.\r\n- ```@trace```: Print the current stack trace.\r\n- Execute other arbitrary statements\r\n- ```?```: Print a help list with all options\r\n\r\nTo finish a debugging session, either use ```@continue``` to continue and eventually stop at the\r\nnext breakpoint or ```@exit``` to skip further breakpoints. After the code has finished, local\r\nvariables saved with ```@exfiltrate``` can be accessed in the REPL using the ```safehouse``` variable.\r\n\r\nLimitations of using Infiltrator.jl are that local variables cannot be changed, and that it is not\r\npossible to step into further calls or access other function scopes.\r\n\r\n\r\n## Releasing a new version of Trixi, Trixi2Vtk\r\n\r\n- Check whether everything is okay, tests pass etc.\r\n- Set the new version number in `Project.toml` according to the Julian version of semver.\r\n  Commit and push.\r\n- Comment `@JuliaRegistrator register` on the commit setting the version number.\r\n- `JuliaRegistrator` will create a PR with the new version in the General registry.\r\n  Wait for it to be merged.\r\n- Increment the version number in `Project.toml` again with suffix `-pre`. For example,\r\n  if you have released version `v0.2.0`, use `v0.2.1-pre` as new version number.\r\n- When a new version of Trixi was released, check whether the `[compat]` entries\r\n  in `test/Project.toml` in Trixi2Vtk should be updated.\r\n  When a new version of Trixi2Vtk was released, check whether the `[compat]`\r\n  entries in `docs/Project.toml` in Trixi should be updated.\r\n\r\n  These entries will also be checked regularly by CompatHelper (once a day). Hence,\r\n  if everything was released correctly, you should only need to do these checks manually\r\n  if new minor versions with changes in the docs of Trixi2Vtk were released\r\n  but no new version of Trixi was released afterwards.\r\n\r\n\r\n\r\n## Preview of the documentation\r\n\r\nYou can build the documentation of Trixi.jl locally by running","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"bash julia –project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()' julia –project=docs –color=yes docs/make.jl","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"from the Trixi.jl main directory. Then, you can look at the html files generated in\r\n`docs/build`.\r\nFor PRs triggered from branches inside the Trixi.jl main repository previews of\r\nthe new documentation are generated at `https://trixi-framework.github.io/Trixi.jl/previews/PRXXX`,\r\nwhere `XXX` is the number of the PR.\r\nThis does not work for PRs from forks for security reasons (since anyone could otherwise push\r\narbitrary stuff to the Trixi website, including malicious code).\r\n\r\n\r\n\r\n## [Developing Trixi2Vtk](@id trixi2vtk-dev)\r\n\r\nTrixi2Vtk has Trixi as dependency and uses Trixi's implementation to, e.g., load mesh files.\r\nWhen developing Trixi2Vtk, one may want to change functions in Trixi to allow them to be reused\r\nin Trixi2Vtk.\r\nTo use a locally modified Trixi clone instead of a Trixi release, one can tell Pkg\r\nto use the local source code of Trixi instead of a registered version by running","category":"page"},{"location":"development.html","page":"Development","title":"Development","text":"julia-repl (@v1.8) pkg> develop path/to/Trixi.jl ```","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"EditURL = \"<unknown>/docs/literate/src/files/getting_started_with_Trixi.jl\"","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#getting_started_with_Trixi","page":"1 Getting started with Trixi","title":"1: Getting started with Trixi","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"This tutorial is intended for beginners in Julia and Trixi.jl. After reading it, you will install Julia and Trixi on your PC and will be able to download files from Trixi github, execute and edit them. Trixi.jl is a numerical simulation framework for hyperbolic conservation laws written in Julia. This means that Julia have to be installed on a PC to work with Trixi.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Julia-installation","page":"1 Getting started with Trixi","title":"Julia installation","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Trixi works with the current stable Julia release. More information about Julia support can be found in README. The most fully explained installation process can be found in Julia installation instruction. But you can follow also our short installation instruction.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Windows","page":"1 Getting started with Trixi","title":"Windows","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Download Julia installer for Windows. Make sure that you choose the right version of installer (64-bit or 32-bit) according to your computer.\nOpen the downloaded installer.\nPaste an installation directory path or find it using a file manager (select Browse).\nSelect Next.\nCheck the Add Julia to PATH to add Julia to the Environment Variables. This makes possible to run Julia using Terminal from any directory only typing julia.\nSelect Next, then Julia will be insalled.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Now you can verify, that Julia is installed:","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Type Win+R on a keyboard.\nEnter cmd in opened window.\nEnter in a terminal julia.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Then Julia will be invoked. To close Julia enter exit().","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Linux","page":"1 Getting started with Trixi","title":"Linux","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Open a Terminal and navigate (using cd) to the directory, where you want to save Julia. Or you can open a file manager, find this directory, right-click inside and choose Open Terminal Here.\nTo install Julia execute the following commands in a Terminal:\nwget https://julialang-s3.julialang.org/bin/linux/x64/1.8/julia-1.8.5-linux-x86_64.tar.gz\ntar zxvf julia-1.8.5-linux-x86_64.tar.gz\nNow you can verify that Julia is installed entering julia command in a Terminal.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Then Julia will be invoked. To close Julia enter exit().","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Trixi-installation","page":"1 Getting started with Trixi","title":"Trixi installation","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Trixi and its related tools are registered Julia packages. So installation of them is running inside Julia. For appropriate work of Trixi you need to install Trixi, Trixi2Vtk, OrdinaryDiffEq and Plots.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Open a Terminal: type Win + R and enter cmd.\nInvoke Julia executing julia.\nExecute following commands:\nimport Pkg\nPkg.add([\"Trixi\", \"Trixi2Vtk\", \"OrdinaryDiffEq\", \"Plots\"])","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Now you have installed all these packages. Trixi2Vtk is a visualization tool, OrdinaryDiffEq provides time integration schemes used by Trixi and Plots can be used to directly visualize Trixi results from the Julia REPL.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Usage","page":"1 Getting started with Trixi","title":"Usage","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html#Files-execution","page":"1 Getting started with Trixi","title":"Files execution","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Trixi has a big set of examples, that can be taken as basis for your future investigations.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Now execute one of them using trixi_include(...) function. trixi_include(...) expects a single string argument with a path to a text file containing Julia code. joinpath(...) join a path components into a full path. examples_dir() returns a path to the examples folder.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Let's execute a short two-dimensional problem setup. Which approximates the solution of compressible Euler equations in 2D for an ideal gas with weak blast wave initial condition","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Invoke Julia in a Terminal. (Open a Terminal: Win+R and enter cmd, invoke Julia in terminal: julia). And execute following code. (Remark: you can ignore all arguments of trixi_include() except path to the file)","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"using Trixi, OrdinaryDiffEq\ntrixi_include(@__MODULE__,joinpath(examples_dir(), \"tree_2d_dgsem\", \"elixir_euler_ec.jl\"),\n callbacks=CallbackSet(StepsizeCallback(cfl=1.0)))","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"To observe the result of the computation, we need to use the Plots package and the function plot(), that builds a graphical representation of the solution. sol is a variable defined in executed example and it contains a solution at a final moment of time.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"To obtain list of all Trixi elixirs execute get_examples(). This will return pathes to all examples.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"get_examples()","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Editing Trixi examples is the best way to start your first own investigation using Trixi.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Files-downloading","page":"1 Getting started with Trixi","title":"Files downloading","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"To edit example files you have to download them. Let's have a look how to download elixir_euler_ec.jl used in the previous section from the Trixi github.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"All examples are located inside the examples folder.\nNavigate to the file elixir_euler_ec.jl.\nClick the Raw button on the right side of the webpage.\nRight-click on any place of the newly opened webpage and choose Save as.\nChoose a folder and erase .txt from the file name. Save the file.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Files-editing","page":"1 Getting started with Trixi","title":"Files editing","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"For example, we will change the initial condition for calculations that occur in elixir_euler_ec.jl. In this example we consider the compressible Euler equations:","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"fracpartialpartial t\nbeginpmatrix\nrho  rho v_1  rho v_2  rho e\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\nrho v_1  rho v_1^2 + p  rho v_1 v_2  (rho e +p) v_1\nendpmatrix\n+\nfracpartialpartial y\nbeginpmatrix\nrho v_2  rho v_1 v_2  rho v_2^2 + p  (rho e +p) v_2\nendpmatrix\n=\nbeginpmatrix\n0  0  0  0\nendpmatrix","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"for an ideal gas with ratio of specific heats gamma in two space dimensions. Here, rho is the density, v_1, v_2 the velocities, e the specific total energy, and","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"p = (gamma - 1) left( rho e - frac12 rho (v_1^2+v_2^2) right)","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"the pressure. So this means that an initial condition consists of initial values for rho, rho v_1, rho v_2 and rho e. One of the common initial condition for compressible Euler equations is density wave. Let's implement it.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Open the downloaded file with notepad or any other text editor.\nAnd go to the 9th line with following code:\ninitial_condition = initial_condition_weak_blast_wave\nHere initial_condition_weak_blast_wave is used.\nComment out this line using # symbol:\n# initial_condition = initial_condition_weak_blast_wave\nNow you can create your own initial conditions. Write following code into a file after the commented line:","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"    function initial_condition_density_waves(x,t,equations::CompressibleEulerEquations2D)\n      v1 = 0.1 # velocity along x-axis\n      v2 = 0.2 # velocity along y-axis\n      rho = 1.0 + 0.98 * sin(pi * (sum(x) - t * (v1 + v2))) # density wave profile\n      p = 20 # pressure\n      rho_e = p / (equations.gamma - 1) + 1/2 * rho * (v1^2 + v2^2)\n      return SVector(rho, rho*v1, rho*v2, rho_e)\n    end\n    initial_condition=initial_condition_density_waves","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Execute following code one more time, but instead of path_to_file paste the path to the elixir_euler_ec.jl file from the current folder.\nusing Trixi\ntrixi_include(path_to_file)\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Then you will obtain new solution.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"trixi_include(@__MODULE__,joinpath(examples_dir(), \"tree_2d_dgsem\", \"elixir_euler_ec.jl\"), #hide\n  callbacks=CallbackSet(StepsizeCallback(cfl=1.0)), initial_condition=initial_condition) #hide\nplot(sol) #hide","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Feel free to add changes into initial_condition to observe different solutions.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Now you are able to download, edit and execute Trixi code.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Next-steps","page":"1 Getting started with Trixi","title":"Next steps","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"If you plan on editing Trixi itself, you can download Trixi locally and run it from the cloned directory:","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Cloning-Trixi","page":"1 Getting started with Trixi","title":"Cloning Trixi","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html#Windows-2","page":"1 Getting started with Trixi","title":"Windows","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"If you are using Windows OS, you can clone Trixi directory using a Github Desktop.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"If you haven't any github account yet, you have to create it on the Github website.\nDownload and install Github Desktop and then login into your account.\nOpen an installed Github Desktop, type Ctrl+Shift+O.\nIn opened window paste trixi-framework/Trixi.jl and choose path to the folder, where you want to save Trixi. Then click Clone and Trixi will be cloned to PC.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Now you cloned Trixi and only need to add Trixi packages to Julia.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Open a Terminal using Win+R and cmd. Navigate to the folder with cloned Trixi using cd.\nCreate new directory and start Julia with the --project flag set to your local Trixi clone.\nmkdir run\ncd run\njulia --project=.\nRun following commands in Julia REPL:\nusing Pkg; Pkg.develop(PackageSpec(path=\"..\")) # Install local Trixi clone\nPkg.add([\"OrdinaryDiffEq\", \"Trixi2Vtk\", \"Plots\"])  # Install additional packages","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Now you already installed Trixi from your local clone. Note that if you installed Trixi this way, you always have to start Julia with the --project flag set to your run directory, e.g.,","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"julia --project=.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"if already inside the run directory.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#Linux-2","page":"1 Getting started with Trixi","title":"Linux","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"You can clone Trixi to PC executing following commands:","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"git clone git@github.com:trixi-framework/Trixi.jl.git\n# In case of an error, use following: git clone https://github.com/trixi-framework/Trixi.jl\ncd Trixi.jl\nmkdir run\ncd run\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))' # Install local Trixi clone\njulia -e 'using Pkg; Pkg.add([\"OrdinaryDiffEq\", \"Trixi2Vtk\", \"Plots\"])' # Install additional packages'","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Note that if you installed Trixi this way, you always have to start Julia with the --project flag set to your run directory, e.g.,","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"julia --project=.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"if already inside the run directory.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html#For-further-reading","page":"1 Getting started with Trixi","title":"For further reading","text":"","category":"section"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"To get deeper into Trixi, you may have a look at following tutorials.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"Introduction to DG methods is about how to set up a simple way to approximate the solution of a hyperbolic partial differential equation. It will be esspecialy useful to learn about the Discontinuous Galerkin method and way of implementation in Trixi. Detailed explanation of code provides a quick start with Trixi.\nAdding a new scalar conservation law and Adding a non-conservative equation describe how to add a new physics model that's not included in Trixi.jl yet.\nCallbacks gives an overview of an algorithmic entity called callback that gets passed to the ODE solver and is called at specific points during execution to perform certain tasks. It extends Trixi without modifying the internal source code.","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"","category":"page"},{"location":"tutorials/getting_started_with_Trixi.html","page":"1 Getting started with Trixi","title":"1 Getting started with Trixi","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"EditURL = \"<unknown>/docs/literate/src/files/shock_capturing.jl\"","category":"page"},{"location":"tutorials/shock_capturing.html#shock_capturing","page":"4 Shock capturing with flux differencing and stage limiter","title":"4: Shock capturing with flux differencing and stage limiter","text":"","category":"section"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"This tutorial contains a short summary of the idea of shock capturing for DGSEM with flux differencing and its implementation in Trixi.jl. In the second part, an implementation of a positivity preserving limiter is added to the simulation.","category":"page"},{"location":"tutorials/shock_capturing.html#Shock-capturing-with-flux-differencing","page":"4 Shock capturing with flux differencing and stage limiter","title":"Shock capturing with flux differencing","text":"","category":"section"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"The following rough explanation is on a very basic level. More information about an entropy stable shock-capturing strategy for DGSEM discretizations of advection dominated problems, such as the compressible Euler equations or the compressible Navier-Stokes equations, can be found in Hennemann et al. (2021). In Rueda-Ramírez et al. (2021) you find the extension to the systems with non-conservative terms, such as the compressible magnetohydrodynamics (MHD) equations.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"The strategy for a shock-capturing method presented by Hennemann et al. is based on a hybrid blending of a high-order DG method with a low-order variant. The low-order subcell finite volume (FV) method is created directly with the Legendre-Gauss-Lobatto (LGL) nodes already used for the high-order DGSEM. Then, the final method is a convex combination with regulating indicator alpha of these two methods.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Since the surface integral is equal for both the DG and the subcell FV method, only the volume integral divides between the two methods.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"This strategy for the volume integral is implemented in Trixi under the name of VolumeIntegralShockCapturingHG with the three parameters of the indicator and the volume fluxes for the DG and the subcell FV method.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Note, that the DG method is based on the flux differencing formulation. Hence, you have to use a two-point flux, such as flux_ranocha, flux_shima_etal, flux_chandrashekar or flux_kennedy_gruber, for the DG volume flux. We would recommend to use the entropy conserving flux flux_ranocha by Ranocha (2018) for the compressible Euler equations.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;\n                                                 volume_flux_dg=volume_flux_dg,\n                                                 volume_flux_fv=volume_flux_fv)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We now focus on a choice of the shock capturing indicator indicator_sc. A possible indicator is alpha_HG presented by Hennemann et al. (p.10), which depends on the current approximation with modal coefficients m_j_j=0^N of a given variable.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"The indicator is calculated for every DG element by itself. First, we calculate a smooth alpha by","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"alpha = frac11+exp(-frac-smathbbT(mathbbE-mathbbT))","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"with the total energy mathbbE=maxbig(fracm_N^2sum_j=0^N m_j^2 fracm_N-1^2sum_j=0^N-1 m_j^2big), threshold mathbbT= 05 * 10^-18*(N+1)^14 and parameter s=lnbig(frac1-0000100001big)approx 921024.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"For computational efficiency, alpha_min is introduced und used for","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"tildealpha = begincases\n0  textif  alphaalpha_min\nalpha  textif  alpha_minleq alpha leq 1- alpha_min\n1  textif  1-alpha_minalpha\nendcases","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Moreover, the parameter alpha_max sets a maximal value for alpha by","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"alpha = mintildealpha alpha_max","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"This allows to control the maximal dissipation.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"To remove numerical artifact the final indicator is smoothed with all the neighboring elements' indicators. This is activated with alpha_smooth=true.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"alpha_HG = max_E  alpha 05 * alpha_E","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"where E are all elements sharing a face with the current element.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Furthermore, you can specify the variable used for the calculation. For instance you can choose density, pressure or both with density_pressure for the compressible Euler equations. For every equation there is also the option to use the first conservation variable with first.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"This indicator is implemented in Trixi and called IndicatorHennemannGassner with the parameters equations, basis, alpha_max, alpha_min, alpha_smooth and variable.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"indicator_sc = IndicatorHennemannGassner(equations, basis,\n                                         alpha_max=0.5,\n                                         alpha_min=0.001,\n                                         alpha_smooth=true,\n                                         variable=variable)","category":"page"},{"location":"tutorials/shock_capturing.html#Positivity-preserving-limiter","page":"4 Shock capturing with flux differencing and stage limiter","title":"Positivity preserving limiter","text":"","category":"section"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Some numerical solutions are physically meaningless, for instance negative values of pressure or density for the compressible Euler equations. This often results in crashed simulations since the calculation of numerical fluxes or stable time steps uses mathematical operations like roots or logarithms. One option to avoid these cases are a-posteriori positivity preserving limiters. Trixi provides the fully-discrete positivity-preserving limiter of Zhang, Shu (2011).","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"It works the following way. For every passed (scalar) variable and for every DG element we calculate the minimal value value_min. If this value falls below the given threshold varepsilon, the approximation is slightly adapted such that the minimal value of the relevant variable lies now above the threshold.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"underlineu^new = theta * underlineu + (1-theta) * u_mean","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"where underlineu are the collected pointwise evaluation coefficients in element e and u_mean the integral mean of the quantity in e. The new coefficients are a convex combination of these two values with factor","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"theta = fracvalue_mean - varepsilonvalue_mean - value_min","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"where value_mean is the relevant variable evaluated for the mean value u_mean.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"The adapted approximation keeps the exact same mean value, but the relevant variable is now greater or equal the threshold varepsilon at every node in every element.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We specify the variables the way we did before for the shock capturing variables. For the compressible Euler equations density, pressure or the combined variable density_pressure are a reasonable choice.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"You can implement the limiter in Trixi using PositivityPreservingLimiterZhangShu with parameters threshold and variables.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"stage_limiter! = PositivityPreservingLimiterZhangShu(thresholds=thresholds,\n                                                     variables=variables)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Then, the limiter is added to the time integration method in the solve function. For instance, like","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"CarpenterKennedy2N54(stage_limiter!, williamson_condition=false)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"or","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"SSPRK43(stage_limiter!).","category":"page"},{"location":"tutorials/shock_capturing.html#Simulation-with-shock-capturing-and-positivity-preserving","page":"4 Shock capturing with flux differencing and stage limiter","title":"Simulation with shock capturing and positivity preserving","text":"","category":"section"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Now, we can run a simulation using the described methods of shock capturing and positivity preserving limiters. We want to give an example for the 2D compressible Euler equations.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"using OrdinaryDiffEq, Trixi\n\nequations = CompressibleEulerEquations2D(1.4)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"As our initial condition we use the Sedov blast wave setup.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"function initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)\n  # Set up polar coordinates\n  inicenter = SVector(0.0, 0.0)\n  x_norm = x[1] - inicenter[1]\n  y_norm = x[2] - inicenter[2]\n  r = sqrt(x_norm^2 + y_norm^2)\n\n  r0 = 0.21875 # = 3.5 * smallest dx (for domain length=4 and max-ref=6)\n  # r0 = 0.5 # = more reasonable setup\n  E = 1.0\n  p0_inner = 3 * (equations.gamma - 1) * E / (3 * pi * r0^2)\n  p0_outer = 1.0e-5 # = true Sedov setup\n  # p0_outer = 1.0e-3 # = more reasonable setup\n\n  # Calculate primitive variables\n  rho = 1.0\n  v1  = 0.0\n  v2  = 0.0\n  p   = r > r0 ? p0_outer : p0_inner\n\n  return prim2cons(SVector(rho, v1, v2, p), equations)\nend\ninitial_condition = initial_condition_sedov_blast_wave","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"basis = LobattoLegendreBasis(3)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We set the numerical fluxes and divide between the surface flux and the two volume fluxes for the DG and FV method. Here, we are using flux_lax_friedrichs and flux_ranocha.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"surface_flux = flux_lax_friedrichs\nvolume_flux  = flux_ranocha","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Now, we specify the shock capturing indicator alpha.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We implement the described indicator of Hennemann, Gassner as explained above with parameters equations, basis, alpha_max, alpha_min, alpha_smooth and variable. Since density and pressure are the critical variables in this example, we use density_pressure = density * pressure = rho * p as indicator variable.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"indicator_sc = IndicatorHennemannGassner(equations, basis,\n                                         alpha_max=0.5,\n                                         alpha_min=0.001,\n                                         alpha_smooth=true,\n                                         variable=density_pressure)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"Now, we can use the defined fluxes and the indicator to implement the volume integral using shock capturing.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;\n                                                 volume_flux_dg=volume_flux,\n                                                 volume_flux_fv=surface_flux)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We finalize the discretization by implementing Trixi's solver, mesh, semi and ode, while solver now has the extra parameter volume_integral.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"solver = DGSEM(basis, surface_flux, volume_integral)\n\ncoordinates_min = (-2.0, -2.0)\ncoordinates_max = ( 2.0,  2.0)\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=6,\n                n_cells_max=10_000)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)\n\ntspan = (0.0, 1.0)\node = semidiscretize(semi, tspan);\nnothing #hide","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We add some callbacks to get an solution analysis and use a CFL-based time step size calculation.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"analysis_callback = AnalysisCallback(semi, interval=100)\n\nstepsize_callback = StepsizeCallback(cfl=0.8)\n\ncallbacks = CallbackSet(analysis_callback, stepsize_callback);\nnothing #hide","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"We now run the simulation using the positivity preserving limiter of Zhang and Shu for the variables density and pressure.","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"stage_limiter! = PositivityPreservingLimiterZhangShu(thresholds=(5.0e-6, 5.0e-6),\n                                                     variables=(Trixi.density, pressure))\n\nsol = solve(ode, CarpenterKennedy2N54(stage_limiter!, williamson_condition=false),\n            dt=1.0, # solve needs some value here but it will be overwritten by the stepsize_callback\n            save_everystep=false, callback=callbacks);\n\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"","category":"page"},{"location":"tutorials/shock_capturing.html","page":"4 Shock capturing with flux differencing and stage limiter","title":"4 Shock capturing with flux differencing and stage limiter","text":"This page was generated using Literate.jl.","category":"page"},{"location":"visualization.html#visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"There are two possible approaches to visualize results from Trixi: either directly from the REPL using Plots.jl or with ParaView/VisIt by postprocessing Trixi's output files with Trixi2Vtk.","category":"page"},{"location":"visualization.html#Plots.jl","page":"Visualization","title":"Plots.jl [experimental]","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"By far the easiest and most convenient plotting approach is to use the powerful Plots.jl package to directly visualize Trixi's results from the REPL. In the following, you will find more information on a number of topics for how to use Plots.jl together with Trixi:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Getting started\nCustomizing plot results via a PlotData2D object\nPlotting a 3D solution as a 2D plot\nCreating a 1D plot\nPlotting a 2D or 3D solutions as a 1D plot\nVisualizing results during a simulation","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"note: Note\nPlotting via Plots.jl is still considered an experimental feature and might change in any future releases.","category":"page"},{"location":"visualization.html#getting-started-plots-jl","page":"Visualization","title":"Getting started","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"After running a simulation with Trixi in the REPL, load the Plots package with","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> using Plots","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"To visualize the solution, execute","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(sol)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Here we assume that sol holds the return value of the solve(...) method (with type SciMLBase.ODESolution), which is the default variable name when you use one of the example elixirs. This will generate a grid layout with one subplot for each solution variable, convenient for getting an overview of the current solution:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: plot-sol)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"You can save the resulting file as a PNG image file by calling savefig(...) with an output file name that ends in .png, e.g.,","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> savefig(\"solution-overview.png\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"In Trixi, two plot types are available: 2D heatmap plots and 1D line plots. If you use plot(sol), Trixi will automatically choose the plot type that fits the dimensions of the sol input: 2D/3D data will be visualized as a heatmap, 1D data as a line plot. For more fine-grained control over what to plot, you can create such an object yourself, which can either be a PlotData2D or a PlotData1D object. For further details on both of these see below:","category":"page"},{"location":"visualization.html#Customizing-plot-results-via-a-PlotData2D-object","page":"Visualization","title":"Customizing plot results via a PlotData2D object","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"For more fine-grained control over what to plot, first create a PlotData2D object by executing","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(sol)\r\njulia> pd = PlotData2D(u, semi)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"where u is an array containing the solution and semi is the semidiscretization. For example, if PlotData2D(sol.u[2], semi) is specified, this will create a PlotData2D instance from the 2nd saved time-step. If PlotData2D(sol(0.5), semi) is specified, it will construct a PlotData2D instance using OrdinaryDiffEq.jl's interpolation to evaluate the solution at time t=0.5.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This takes the results generated by Trixi and stores them in a data format that can be understood by the Plots package, and pd holds all data relevant for plotting sol. You can pass variable names as strings to pd using a dictionary-like syntax, e.g.,","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(pd[\"rho\"])","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This will create a single 2D heatmap plot of the variable rho:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: plot-rho)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"The default plot type and style can be overridden by passing any additional arguments that are understood by the Plots package. For example, to change the color scheme and add names to the axes, modify the previous command to","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(pd[\"rho\"], seriescolor = :heat, xguide=\"x\", yguide=\"y\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"to yield","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: plot-rho-modified)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"For more details on the various format options for plot, please consult the Plots documentation.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"In addition, you can plot the mesh lines on top of the solution variables by calling the getmesh(...) function on the PlotData2D object","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot!(getmesh(pd)) # here we use `plot!` with an `!` to add to the previous plot","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"which modifies the previous plot to","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: plot-rho-modified-mesh)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"By default, PlotData2D will convert the conserved variables to primitive variables, but this can be changed by passing an appropriate conversion function in the solution_variables keyword argument, similar to the behavior of the SaveSolutionCallback:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(sol; solution_variables=cons2cons) # Plot conservative variables","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"There are several other keyword arguments that influence how the solution data is processed for visualization with the Plots package. A detailed explanation can be found in the docstring of the PlotData2D constructor.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Another way to change the appearance of a plot is to convert the solution to a uniformly refined mesh before plotting. This can be helpful, e.g., when trying different settings for a simulation with adaptive mesh refinement, where one would like to ignore the mesh changes when comparing solutions. This is achieved with adapt_to_mesh_level, which uses the mesh adaptation routines to adapt the solution to a uniform grid. For example, the AMR solution from above could be preprocessed with","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(adapt_to_mesh_level(sol, 4)...)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"When plotted together with the mesh, this will yield the following visualization:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: plot-rho-uniform-mesh)","category":"page"},{"location":"visualization.html#Plotting-a-user-defined-scalar-field","page":"Visualization","title":"Plotting a user-defined scalar field","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"To plot a scalar quantity, one can call plot(ScalarPlotData2D(u, semi)), where u is an array of nodal values of the scalar field to plot. The layout of u should match the layout of the x and y nodal coordinates of the respective solver. For example, after running trixi_include(joinpath(\"examples\", \"unstructured_2d_dgsem\", \"elixir_euler_wall_bc.jl\")), the following can be used to plot the function f(x, y) = x * y:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"x = view(semi.cache.elements.node_coordinates, 1, :, :, :)\r\ny = view(semi.cache.elements.node_coordinates, 2, :, :, :)\r\nplot(ScalarPlotData2D(x .* y, semi))","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This produces the following plot:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: scalar-plotting-example)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This routine can be used to visualize scalar quantities which depend on the solution, such as the norm of a velocity vector or two-dimensional vorticity. For example, we can visualize vorticity for a compressible version of the Brown-Minion vortex problem:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> using Trixi, Plots\r\n\r\njulia> redirect_stdout(devnull) do\r\n         # runs the elixir without any output from callbacks etc.\r\n         trixi_include(@__MODULE__,\r\n           joinpath(examples_dir(), \"dgmulti_2d\", \"elixir_euler_brown_minion_vortex.jl\"))\r\n       end\r\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\r\n\r\njulia> function compute_vorticity(velocity, mesh, equations::CompressibleEulerEquations2D,\r\n                                  dg::DGMulti, cache)\r\n         rd = dg.basis\r\n         md = mesh.md\r\n         @unpack Dr, Ds = rd\r\n         @unpack rxJ, sxJ, ryJ, syJ, J = md\r\n         v1, v2 = velocity\r\n         dv1dy = ryJ .* (Dr * v1) + syJ .* (Ds * v1)\r\n         dv2dx = rxJ .* (Dr * v2) + sxJ .* (Ds * v2)\r\n         return dv2dx - dv1dy\r\n       end;\r\n\r\njulia> compute_vorticity(velocity, semi) =\r\n         compute_vorticity(velocity, Trixi.mesh_equations_solver_cache(semi)...);\r\n\r\njulia> function get_velocity(sol)\r\n         rho, rhou, rhov, E = StructArrays.components(sol.u[end])\r\n         v1 = rhou ./ rho\r\n         v2 = rhov ./ rho\r\n         return v1, v2\r\n       end;\r\n\r\njulia> vorticity = compute_vorticity(get_velocity(sol), semi);\r\n\r\njulia> plot(ScalarPlotData2D(vorticity, semi;\r\n            variable_name = \"Vorticity at t = $(sol.prob.tspan[end])\"))\r\nPlot{Plots.GRBackend() n=1}","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This produces the following plot of vorticity.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: vorticity-example)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Since the mesh is fairly coarse, we observe numerical artifacts due to the low resolution. These errors vanish under mesh refinement; for example, doubling the mesh resolution by running","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi_include(joinpath(examples_dir(), \"dgmulti_2d\", \"elixir_euler_BM_vortex.jl\"), cells_per_dimension = 32)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"yields the following plot of vorticity:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: vorticity-example-refined)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"note: Note\nWhen visualizing a scalar field, the plotted solution is reinterpolated using a high order polynomial approximation. Thus, small discrepancies may be observed when the underlying data is highly non-smooth or under-resolved.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"ScalarPlotData2D objects can also be used with Makie through iplot. For example, the following code plots two surfaces:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> using Trixi, CairoMakie\r\n\r\njulia> redirect_stdout(devnull) do\r\n         # runs the elixir without any output from callbacks etc.\r\n         trixi_include(@__MODULE__,\r\n           joinpath(examples_dir(), \"unstructured_2d_dgsem\", \"elixir_euler_wall_bc.jl\"))\r\n       end\r\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\r\n\r\njulia> x = view(semi.cache.elements.node_coordinates, 1, :, :, :); # extracts the node x coordinates\r\n\r\njulia> y = view(semi.cache.elements.node_coordinates, 2, :, :, :); # extracts the node y coordinates\r\n\r\njulia> fig_ax_plt = iplot(ScalarPlotData2D((@. 1 - .25*(x^2 + y^2)), semi), plot_mesh=true, colormap=:viridis);\r\n\r\njulia> fig_ax_plt2 = iplot!(fig_ax_plt, ScalarPlotData2D((@. .125*(x+y)), semi), plot_mesh=true, colormap=:blues)\r\nFigureAxisPlot()","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This creates the following plot:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: ScalarPlotData2D_example)","category":"page"},{"location":"visualization.html#Plotting-a-3D-solution-as-a-2D-plot","page":"Visualization","title":"Plotting a 3D solution as a 2D plot","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"It is possible to plot 2D slices from 3D simulation data using the TreeMesh with the same commands as above:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(sol) # `sol` is from a 3D simulation","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"By default, plotting sol or creating a PlotData2D object from a 3D simulation will create a 2D slice of the solution in the xy-plane. You can customize this behavior by explicitly creating a PlotData2D object and passing appropriate keyword arguments:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"slice specifies the plane which is being sliced and can be :xy, :xz, or :yz (default: :xy)\npoint specifies a three-dimensional point. The sliced plane is then created such that it lies on the point (default: (0.0, 0.0, 0.0)).","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"All other attributes for PlotData2D objects apply here as well.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"For example, to plot the velocity field orthogonal to the yz-plane at different x-axis locations, you can execute","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi_include(joinpath(examples_dir(), \"tree_3d_dgsem\", \"elixir_euler_taylor_green_vortex.jl\"), tspan=(0.0, 1.0))\r\n[...]\r\n\r\njulia> plots = []\r\nAny[]\r\n\r\njulia> for x in range(0, stop=pi/2, length=6)\r\n         pd = PlotData2D(sol, slice=:yz, point=(x, 0.0, 0.0))\r\n         push!(plots, plot(pd[\"v1\"], clims=(-1,1), title=\"x = \"*string(round(x, digits=2))))\r\n       end\r\n\r\njulia> plot(plots..., layout=(2, 3), size=(750,350))","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"which results in a 2x3 grid of slices of the yz-plane:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: plot-v1-0.0-to-0.5pi)","category":"page"},{"location":"visualization.html#Creating-a-1D-plot","page":"Visualization","title":"Creating a 1D plot","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"When plotting a 1D solution with","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(sol) # `sol` is from a 1D simulation","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Trixi automatically creates a PlotData1D object and visualizes it as a line plot: (Image: 1d-plot)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"To customize your 1D plot, you can create a PlotData1D object manually as follows:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData1D(sol)\r\njulia> pd = PlotData1D(u, semi)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"The behavior is analogous to the PlotData2D behavior.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"In a very similar fashion to PlotData2D, you can customize your plot:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"plot(pd) creates the same plot as in plot(sol).\nplot(pd[\"rho\", \"p\"]) only plots specific variables. In this case rho and p.\nplot!(getmesh(pd)) adds mesh lines after creating a plot.\nAny attributes from Plots can be used, e.g., plot(pd, yguide=:temperature).\npd = PlotData1D(adapt_to_mesh_level(sol, 4)...) adapts the mesh before plotting (in this example to a mesh with refinement level 4).","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"You can also customize the PlotData1D object itself by passing attributes to the PlotData1D constructor:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"solution_variables specifies the variables to be plotted.\nnvisnodes sets the amount of nodes per element which the solution then is interpolated on.","category":"page"},{"location":"visualization.html#Plotting-a-2D-or-3D-solutions-as-a-1D-plot","page":"Visualization","title":"Plotting a 2D or 3D solutions as a 1D plot","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"It is possible to extract a straight, axis-parallel line from a 2D or 3D solution and visualize it as a 1D plot. This is done by creating a PlotData1D object with a 2D/3D solution sol as input:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData1D(sol)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"The plot is then created with:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(pd)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"By default the x-axis is extracted, which can be changed with following attributes:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"slice specifies the axis which is being extracted and can be :x, :y or :z (:z is only for 3D input and default is :x)\npoint specifies a two or three dimensional point. The sliced axis is then created in such a way, that it lies on the point. (default: (0.0, 0.0) or (0.0, 0.0, 0.0))","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"All other attributes for PlotData1D objects apply here as well.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"In the following, is an example for a 2D simulation of the linear scalar advection equation. First, we have the regular 2D heatmap plot:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: 2d-plot-for-slice)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"From this, we can extract a line plot parallel to the y-axis going through the point (1.0, 0.0) with the following commands:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData1D(sol, slice=:y, point=(1.0, 0.0))\r\njulia> plot(pd)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: 1d-plot-for-slice)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This convenient method of slicing is limited to axis-parallel slices, but for 2D/3D solutions it is also possible to create a plot along any curve you want. To do so, you first need to create a list of 2D/3D points that define your curve. Then you can create a PlotData1D with the keyword argument curve set to your list.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Let's give an example of this with the basic advection equation from above by creating a plot along the circle marked in green:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: 2d-plot-along-cirlce)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"We can write a function like this, that outputs a list of points on a circle:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"function circle(radius, center, n_points)\r\n    coordinates = zeros(2, n_points)\r\n    for i in 1:n_points\r\n        coordinates[:,i] = radius*[cospi(2*i/n_points), sinpi(2*i/n_points)] .+ center\r\n    end\r\n    return coordinates\r\nend","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Then create and plot a PlotData1D object along a circle with radius one, center at (1,1), and 100 points:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"pd = PlotData1D(sol, curve=circle(1.0, (1.0, 1.0), 100))\r\nplot(pd)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This gives you the following plot: (Image: 1d-plot-along-circle)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Creating a plot like this has its downsides. For one, it is unclear what to put on the abscissa of the plot. By default, the arc length of the given curve is used. Also, with this way of plotting you lose the ability to use a mesh plot from getmesh.","category":"page"},{"location":"visualization.html#Visualizing-results-during-a-simulation","page":"Visualization","title":"Visualizing results during a simulation","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"To visualize solutions while a simulation is still running (also known as in-situ visualization), you can use the VisualizationCallback. It is created as a regular callback and accepts upon creation a number of keyword arguments that allow, e.g., to control the visualization interval, to specify the variables to plot, or to customize the plotting style.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"During the simulation, the visualization callback creates and displays visualizations of the current solution in regular intervals. This can be useful to, e.g., monitor the validity of a long-running simulation or for illustrative purposes. An example for how to create a VisualizationCallback can be found in examples/tree2ddgsem/elixir_advection_amr_visualization.jl:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"[...]\r\n\r\n# Enable in-situ visualization with a new plot generated every 20 time steps\r\n# and additional plotting options passed as keyword arguments\r\nvisualization = VisualizationCallback(interval=20; clims=(0,1))\r\n\r\n[...]","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"The resulting output of the referenced elixir can be seen in the embedded video below:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"  <!--\r\n  Video creation details\r\n  * Set up terminal size and position appropriately\r\n  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)\r\n  * Upload to YouTube\r\n  * Obtain responsive code by inserting link on https://embedresponsively.com\r\n  -->\r\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/UZtrqeDY1Fs' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"visualization.html#Trixi2Vtk","page":"Visualization","title":"Trixi2Vtk","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Trixi2Vtk converts Trixi's .h5 output files to VTK files, which can be read by ParaView, VisIt, and other visualization tools. It automatically interpolates solution data from the original quadrature node locations to equidistant visualization nodes at a higher resolution, to make up for the loss of accuracy from going from a high-order polynomial representation to a piecewise constant representation in VTK.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"In the Julia REPL, first load the package Trixi2Vtk","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> using Trixi2Vtk","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"To process an HDF5 file generated by Trixi.jl, execute","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(joinpath(\"out\", \"solution_000000.h5\"), output_directory=\"out\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This will create two unstructured VTK files in the out subdirectory that can be opened with ParaView or VisIt: solution_000000.vtu contains the discontinuous Galerkin solution data while solution_000000_celldata.vtu holds any cell-based values such as the current AMR indicator or the cell refinement level.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: \"solution_000000_scalar_mesh\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This allows you to generate VTK files for solution, restart and mesh files. By default, Trixi2Vtk generates .vtu (unstructured VTK) files for both cell/element data (e.g., cell ids, element ids) and node data (e.g., solution variables). This format visualizes each cell with the same number of nodes, independent of its size.  Alternatively, you can provide format=:vti as a keyword argument to trixi2vtk, which causes Trixi2Vtk to generate .vti (image data VTK) files for the solution files, while still using .vtu files for cell-/element-based data. In .vti files, a uniform resolution is used throughout the entire domain, resulting in different number of visualization nodes for each element.  This can be advantageous to create publication-quality images, but increases the file size.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"If you want to convert multiple solution/restart files at once, you can just supply multiple input files as the positional arguments to trixi2vtk, e.g.,","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(\"out/solution_000000.h5\", \"out/solution_000040.h5\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"You may also use file globbing to select a range of files based on filename patterns, e.g.,","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(\"out/solution_*.h5\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"to convert all solution files in the out/ directory or","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi2vtk(\"out/restart_00[0-9]000.h5\")","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"to convert every one-thousandth restart file (out/restart_000000.h5, out/restart_001000.h5 etc.).","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"When multiple solution/restart files are provided, Trixi2Vtk will also generate a .pvd file, which allows ParaView to read all .vtu/.vti files at once and which uses the time attribute in solution/restart files to inform ParaView about the solution time. A comprehensive list of all possible arguments for trixi2vtk can be found in the Trixi2Vtk.jl API.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Further information regarding the development of Trixi2Vtk can be found in the","category":"page"},{"location":"visualization.html#Makie.jl","page":"Visualization","title":"Makie.jl [experimental]","text":"","category":"section"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"In addition to Plots.jl support, Trixi includes visualization utilities through Makie.jl. Trixi provides Makie-based visualization options both for heatmap-type plots (similar to the Plots.jl recipes) as well as for interactive surface plots. Support is currently limited to the UnstructuredMesh2D type.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"note: Note\nPlotting via Makie.jl is still considered an experimental feature and might change in any future releases.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"A Makie plot can be created as follows: after running a simulation with Trixi in the REPL, load a Makie backend (for example, GLMakie or CairoMakie).","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> using GLMakie","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"To visualize the solution and mesh with a heatmap-type plot, simply run","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(sol)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"note: Note\nBoth Makie.jl and Plots.jl export plot, so if you load both libraries, you will have to specify which plot function to call via Plots.plot or Makie.plot.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"As with Plots.jl recipes, one can view individual solution components by creating a PlotData2D object and indexing into it with the desired variable name","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> pd = PlotData2D(sol)\r\njulia> plot(pd[\"rho\"])","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Unlike the Plots.jl recipe, mesh plotting is controlled using the keyword argument plot_mesh = false, e.g.,","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> plot(sol; plot_mesh=false)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"The plot command also returns figure and axis handles, which can be used to edit plot titles or labels:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> fig, axes = plot(sol)\r\njulia> axes[1,1].title = \"New title for subplot (1,1)\"","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Trixi also supports interactive surface plots using iplot. After executing","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> trixi_include(joinpath(\"examples\", \"unstructured_2d_dgsem\", \"elixir_euler_wall_bc.jl\"))","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"we can run","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"julia> iplot(sol)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"This will open up an interactive visualization window:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: makie-example)","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"The plot can be rotated (click and hold), zoomed in and out (scroll up and down), and panned (hold right click and drag). Two toggle buttons control whether mesh lines are visible on top of and below the solution.","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"Both plot and iplot use colormap = :inferno by default. A different colormap can be selected by providing an appropriate keyword argument. For example, plot(sol, colormap=:blues) and iplot(sol, colormap=:blues) produce the following figures:","category":"page"},{"location":"visualization.html","page":"Visualization","title":"Visualization","text":"(Image: makie-plot-example) (Image: makie-iplot-example)","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"EditURL = \"<unknown>/docs/literate/src/files/non_periodic_boundaries.jl\"","category":"page"},{"location":"tutorials/non_periodic_boundaries.html#non_periodic_boundaries","page":"5 Non-periodic boundaries","title":"5: Non-periodic boundaries","text":"","category":"section"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/non_periodic_boundaries.html#Dirichlet-boundary-condition","page":"5 Non-periodic boundaries","title":"Dirichlet boundary condition","text":"","category":"section"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"First, let's look at the Dirichlet boundary condition BoundaryConditionDirichlet.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"BoundaryConditionDirichlet(boundary_value_function)","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"In Trixi.jl, this creates a Dirichlet boundary condition where the function boundary_value_function is used to set the values at the boundary. It can be used to create a boundary condition that sets exact boundary values by passing the exact solution of the equation.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"It is important to note that standard Dirichlet boundary conditions for hyperbolic PDEs do not make sense in most cases. However, we are using a special weak form of the Dirichlet boundary condition, based on the application of the numerical surface flux. The numerical surface flux takes the solution value from inside the domain and the prescribed value of the outer boundary state as arguments, and solves an approximate Riemann problem to introduce dissipation (and hence stabilization) at the boundary. Hence, the performance of the Dirichlet BC depends on the fidelity of the numerical surface flux.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"The passed boundary value function is called with the same arguments as an initial condition function, i.e.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"boundary_value_function(x, t, equations)","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"where x specifies the spatial coordinates, t is the current time, and equations is the corresponding system of equations.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"We want to give a short example for a simulation with such a Dirichlet BC.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Consider the one-dimensional linear advection equation with domain Omega=0 2 and a constant zero initial condition.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"using OrdinaryDiffEq, Trixi\n\nadvection_velocity = 1.0\nequations = LinearScalarAdvectionEquation1D(advection_velocity)\n\ninitial_condition_zero(x, t, equation::LinearScalarAdvectionEquation1D) = SVector(0.0)\ninitial_condition = initial_condition_zero\n\nusing Plots\nplot(x -> sum(initial_condition(x, 0.0, equations)), label=\"initial condition\", ylim=(-1.5, 1.5))","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Using an advection velocity of 1.0 and the (local) Lax-Friedrichs/Rusanov flux FluxLaxFriedrichs as a numerical surface flux, we are able to create an inflow boundary on the left and an outflow boundary on the right, as the Lax-Friedrichs flux is in this case an exact characteristics Riemann solver. We note that for more complex PDEs different strategies for inflow/outflow boundaries are necessary. To define the inflow values, we initialize a boundary_value_function.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"function boundary_condition_sine_sector(x, t, equation::LinearScalarAdvectionEquation1D)\n    if 1 <= t <= 3\n        scalar = sin(2 * pi * sum(t - 1))\n    else\n        scalar = zero(t)\n    end\n    return SVector(scalar)\nend\nboundary_condition = boundary_condition_sine_sector","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"We set the BC in negative and positive x-direction.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"boundary_conditions = (x_neg=BoundaryConditionDirichlet(boundary_condition),\n                       x_pos=BoundaryConditionDirichlet(boundary_condition))","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"solver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)\n\ncoordinates_min = (0.0,)\ncoordinates_max = (2.0,)","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"For the mesh type TreeMesh the parameter periodicity must be set to false in the corresponding direction.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"mesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4,\n                n_cells_max=10_000,\n                periodicity=false)\n\n\nsemi = SemidiscretizationHyperbolic(mesh, equations,\n                                    initial_condition,\n                                    solver,\n                                    boundary_conditions=boundary_conditions)\n\ntspan = (0.0, 6.0)\node = semidiscretize(semi, tspan)\n\nanalysis_callback = AnalysisCallback(semi, interval=100,)\n\nstepsize_callback = StepsizeCallback(cfl=0.9)\n\ncallbacks = CallbackSet(analysis_callback,\n                        stepsize_callback);\nnothing #hide","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"We define some equidistant nodes for the visualization","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"visnodes = range(tspan[1], tspan[2], length=300)","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"and run the simulation.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"sol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1, # solve needs some value here but it will be overwritten by the stepsize_callback\n            save_everystep=false, saveat=visnodes, callback=callbacks);\n\nusing Plots\n@gif for step in 1:length(sol.u)\n    plot(sol.u[step], semi, ylim=(-1.5, 1.5), legend=true, label=\"approximation\", title=\"time t=$(round(sol.t[step], digits=5))\")\n    scatter!([0.0], [sum(boundary_condition(SVector(0.0), sol.t[step], equations))], label=\"boundary condition\")\nend","category":"page"},{"location":"tutorials/non_periodic_boundaries.html#Other-available-example-elixirs-with-non-trivial-BC","page":"5 Non-periodic boundaries","title":"Other available example elixirs with non-trivial BC","text":"","category":"section"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Moreover, there are other boundary conditions in Trixi. For instance, you can use the slip wall boundary condition boundary_condition_slip_wall.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Trixi.jl provides some interesting examples with different combinations of boundary conditions, e.g. using boundary_condition_slip_wall and other self-defined boundary conditions using BoundaryConditionDirichlet.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"For instance, there is a 2D compressible Euler setup for a Mach 3 wind tunnel flow with a forward facing step in the elixir elixir_euler_forward_step_amr.jl discretized with a P4estMesh using adaptive mesh refinement (AMR).","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"  <!--\n  Video details\n  * Source: https://www.youtube.com/watch?v=glAug1aIxio\n  * Author: Andrew R. Winters (https://liu.se/en/employee/andwi94)\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/glAug1aIxio' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Source: Video on Trixi's YouTube channel Trixi Framework","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"A double Mach reflection problem for the 2D compressible Euler equations elixir_euler_double_mach_amr.jl exercises a special boundary conditions along the bottom of the domain that is a mixture of Dirichlet and slip wall.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"  <!--\n  Video details\n  * Source: https://www.youtube.com/watch?v=WElqqdMhY4A\n  * Author: Andrew R. Winters (https://liu.se/en/employee/andwi94)\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/WElqqdMhY4A' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Source: Video on Trixi's YouTube channel Trixi Framework","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"A channel flow around a cylinder at Mach 3 elixir_euler_supersonic_cylinder.jl contains supersonic Mach 3 inflow at the left portion of the domain and supersonic outflow at the right portion of the domain. The top and bottom of the channel as well as the cylinder are treated as Euler slip wall boundaries.","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"  <!--\n  Video details\n  * Source: https://www.youtube.com/watch?v=w0A9X38cSe4\n  * Author: Andrew R. Winters (https://liu.se/en/employee/andwi94)\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/w0A9X38cSe4' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"Source: Video on Trixi's YouTube channel Trixi Framework","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"","category":"page"},{"location":"tutorials/non_periodic_boundaries.html","page":"5 Non-periodic boundaries","title":"5 Non-periodic boundaries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"meshes/structured_mesh.html#Structured-mesh","page":"Structured mesh","title":"Structured mesh","text":"","category":"section"},{"location":"meshes/structured_mesh.html","page":"Structured mesh","title":"Structured mesh","text":"The StructuredMesh is a structured, curvilinear, conforming mesh type available for one-, two-, and three-dimensional simulations.","category":"page"},{"location":"meshes/structured_mesh.html","page":"Structured mesh","title":"Structured mesh","text":"Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the normal::AbstractVector. Rotationally invariant equations such as the compressible Euler equations can use FluxRotated to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the TreeMesh but is usually less efficient, cf. PR #550.","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"EditURL = \"<unknown>/docs/literate/src/files/DGMulti_2.jl\"","category":"page"},{"location":"tutorials/DGMulti_2.html#DGMulti_2","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7: Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"","category":"section"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"For a tutorial about DG schemes via the DGMulti solver please visit the previous tutorial. The DGMulti solver also supports other methods than DG. The important property a method has to fulfill is the summation-by-parts (SBP) property. The package SummationByPartsOperators.jl provides such methods, like a finite difference SBP (FD SBP) scheme. To do this, you need to create an SBP derivative operator and pass that as approximation_type to the DGMulti constructor. For example, the classical second-order FD SBP operator can be created as","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"using Trixi.SummationByPartsOperators # or add SummationByPartsOperators to your project and use it directly\nD = derivative_operator(MattssonNordström2004(), derivative_order=1, accuracy_order=2,\n                        xmin=0.0, xmax=1.0, N=11)","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"Here, the arguments xmin and xmax do not matter beyond setting the real type used for the operator - they just set a reference element and are rescaled on the physical elements. The parameter N determines the number of finite difference nodes. Then, D can be used as approximation_type like SBP() in a multi-block fashion. In multiple dimensions, such a 1D SBP operator will be used in a tensor product fashion, i.e., in each coordinate direction. In particular, you can use them only on 1D, 2D Quad(), and 3D Hex() elements.","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"You can also use fully periodic single-block FD methods by creating a periodic SBP operator. For example, a fully periodic FD operator can be constructed as","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"D = periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                 xmin=0.0, xmax=1.0, N=11)","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"An example using such an FD method is implemented in elixir_euler_fdsbp_periodic.jl. For all parameters and other calling options, please have a look in the documentation of SummationByPartsOperators.jl.","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"Another possible method is for instance a continuous Galerkin (CGSEM) method. You can use such a method with polynomial degree of 3 (N=4 Legendre Lobatto nodes on [0, 1]) coupled continuously on a uniform mesh with Nx=10 elements by setting approximation_type to","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"using Trixi.SummationByPartsOperators # or add SummationByPartsOperators to your project and use it directly\nD = couple_continuously(legendre_derivative_operator(xmin=0.0, xmax=1.0, N=4),\n                        UniformPeriodicMesh1D(xmin=-1.0, xmax=1.0, Nx=10))","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"To choose a discontinuous coupling (DGSEM), use couple_discontinuously() instead of couple_continuously().","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"For more information and other SBP operators, see the documentations of StartUpDG.jl and SummationByPartsOperators.jl.","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"","category":"page"},{"location":"tutorials/DGMulti_2.html","page":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","title":"7 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performance.html#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance.html","page":"Performance","title":"Performance","text":"Trixi.jl is designed to balance performance and readability. Since Julia provides a lot of zero-cost abstractions, it is often possible to optimize both goals simultaneously.","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"The usual development workflow in Julia is","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"Make it work.\nMake it nice.\nMake it fast.","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"To achieve the third step, you should be familiar with (at least) the section on performance tips in the Julia manual. Here, we just list some important aspects you should consider when developing Trixi.","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"Consider using @views/view(...) when using array slices, except on the left-side of an assignment (further details).\nFunctions are essentially for free, since they are usually automatically inlined where it makes sense (using @inline can be used as an additional hint to the compiler) (further details).\nFunction barriers can improve performance due to type stability (further details).\nLook for type instabilities using @code_warntype. Consider using @descend from Cthulhu.jl to investigate deeper call chains.","category":"page"},{"location":"performance.html#Manual-benchmarking","page":"Performance","title":"Manual benchmarking","text":"","category":"section"},{"location":"performance.html","page":"Performance","title":"Performance","text":"If you modify some internal parts of Trixi, you should check the impact on performance. Hence, you should at least investigate the performance roughly by comparing the reported timings of several elixirs. Deeper investigations and micro-benchmarks should usually use BenchmarkTools.jl. For example, the following steps were used to benchmark the changes introduced in https://github.com/trixi-framework/Trixi.jl/pull/256.","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"git checkout e7ebf3846b3fd62ee1d0042e130afb50d7fe8e48 (new version)\nStart julia --threads=1 --check-bounds=no.\nExecute the following code in the REPL to benchmark the rhs! call at the final state. ```julia julia> using BenchmarkTools, Revise; using Trixi","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> trixiinclude(\"examples/2d/elixireulersedovblast_wave.jl\")","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> dutest = copy(sol.u[end]); utest = copy(sol.u[end]);","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> @benchmark Trixi.rhs!(              du_test,              u_test,              semi,              sol.t[end])    BenchmarkTools.Trial:     memory estimate:  10.48 KiB     allocs estimate:  67     –––––––     minimum time:     4.510 ms (0.00% GC)     median time:      4.646 ms (0.00% GC)     mean time:        4.699 ms (0.00% GC)     maximum time:     7.183 ms (0.00% GC)     –––––––     samples:          1065     evals/sample:     1","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"shell> git checkout 222241ff54f8a4ca9876cc1fc25ae262416a4ea0","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> trixiinclude(\"examples/2d/elixireulersedovblast_wave.jl\")","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> @benchmark Trixi.rhs!(              du_test,              u_test,              semi,              sol.t[end])    BenchmarkTools.Trial:     memory estimate:  10.36 KiB     allocs estimate:  67     –––––––     minimum time:     4.500 ms (0.00% GC)     median time:      4.635 ms (0.00% GC)     mean time:        4.676 ms (0.00% GC)     maximum time:     5.880 ms (0.00% GC)     –––––––     samples:          1070     evals/sample:     1","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"   Run the `@benchmark ...` commands multiple times to see whether there are any significant fluctuations.\r\n\r\nFollow these steps for both commits you want to compare. The relevant benchmark results you should typically be looking at\r\nare the median and mean values of the runtime and the memory/allocs estimate. In this example, the differences\r\nof the runtimes are of the order of the fluctuations one gets when running the benchmarks multiple times. Since\r\nthe memory/allocs are (roughly) the same, there doesn't seem to be a significant performance regression here.\r\n\r\nYou can also make it more detailed by benchmarking only, e.g., the calculation of the volume terms, but whether that's necessary depends on the modifications you made and their (potential) impact.\r\n\r\nSome more detailed description of manual profiling and benchmarking as well as\r\nresulting performance improvements of Trixi are given in the following blog posts.\r\n- [Improving performance of AMR with p4est](https://ranocha.de/blog/Optimizing_p4est_AMR/),\r\n  cf. [#638](https://github.com/trixi-framework/Trixi.jl/pull/638)\r\n- [Improving performance of EC methods](https://ranocha.de/blog/Optimizing_EC_Trixi/),\r\n  cf. [#643](https://github.com/trixi-framework/Trixi.jl/pull/643)\r\n\r\n\r\n## Automated benchmarking\r\n\r\nWe use [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) to provide a standard set of\r\nbenchmarks for Trixi. The relevant benchmark script is\r\n[benchmark/benchmarks.jl](https://github.com/trixi-framework/Trixi.jl/blob/main/benchmark/benchmarks.jl).\r\nYou can run a standard set of benchmarks via","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia julia> using PkgBenchmark, Trixi","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> results = benchmarkpkg(Trixi, BenchmarkConfig(juliacmd=$(Base.julia_cmd()) --check-bounds=no --threads=1))","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> exportmarkdown(joinpath(pathof(Trixi) |> dirname |> dirname, \"benchmark\", \"singlebenchmark.md\"), results)","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"This will save a markdown file with a summary of the benchmark results similar to\r\n[this example](https://gist.github.com/ranocha/494fa2529e1e6703c17b08434c090980).\r\nNote that this will take quite some time. Additional options are described in the\r\n[docs of PkgBenchmark.jl](https://juliaci.github.io/PkgBenchmark.jl/stable).\r\nA particularly useful option is to specify a `BenchmarkConfig` including Julia\r\ncommand line options affecting the performance such as disabling bounds-checking\r\nand setting the number of threads.\r\n\r\nA useful feature when developing Trixi is to compare the performance of Trixi's\r\ncurrent state vs. the `main` branch. This can be achieved by executing","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia julia> using PkgBenchmark, Trixi","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> results = judge(Trixi,              BenchmarkConfig(juliacmd=$(Base.julia_cmd()) --check-bounds=no --threads=1), # target              BenchmarkConfig(juliacmd=$(Base.julia_cmd()) --check-bounds=no --threads=1, id=\"main\") # baseline        )","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia> export_markdown(joinpath(pathof(Trixi) |> dirname |> dirname, \"benchmark\", \"results.md\"), results)","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"By default, the `target` is the current state of the repository. Remember that you\r\nneed to be in a clean state (commit or stash your changes) to run this successfully.\r\nYou can also run this comparison and an additional one using two threads via","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"julia julia> include(\"benchmark/run_benchmarks.jl\")","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"Then, markdown files including the results are saved in `benchmark/`.\r\n[This example result](https://gist.github.com/ranocha/bf98d19e288e759d3a36ca0643448efb)\r\nwas obtained using a GitHub action for the\r\n[PR #535](https://github.com/trixi-framework/Trixi.jl/pull/535).\r\nNote that GitHub actions run on in the cloud in a virtual machine. Hence, we do not really\r\nhave control over it and performance results must be taken with a grain of salt.\r\nNevertheless, significant runtime differences and differences of memory allocations\r\nshould be robust indicators of performance changes.\r\n\r\n\r\n## Runtime performance vs. latency aka using `@nospecialize` selectively\r\n\r\nUsually, Julia will compile specialized versions of each method, using as much information from the\r\ntypes of function arguments as possible (based on some\r\n[heuristics](https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing)).\r\nThe compiler will generate code that is as efficient as comparable code written in a low-level\r\nlanguage such as C or Fortran. However, there are cases where the runtime performance does not\r\nreally matter but the time needed to compile specializations becomes significant. This is related to\r\nlatency or the time-to-first-plot problem, well-known in the Julia community. In such a case, it can\r\nbe useful to remove some burden from the compiler by avoiding specialization on every possible argument\r\ntypes using [the macro `@nospecialize`](https://docs.julialang.org/en/v1/base/base/#Base.@nospecialize).\r\nA prime example of such a case is pretty printing of `struct`s in the Julia REPL, see the\r\n[associated PR](https://github.com/trixi-framework/Trixi.jl/pull/447) for further discussions.\r\n\r\nAs a rule of thumb:\r\n- Do not use `@nospecialize` in performance-critical parts, in particular not for methods involved\r\n  in computing `Trixi.rhs!`.\r\n- Consider using `@nospecialize` for methods like custom implementations of `Base.show`.\r\n\r\n\r\n## Performance metrics of the `AnalysisCallback`\r\nThe [`AnalysisCallback`](@ref) computes two performance indicators that you can use to\r\nevaluate the serial and parallel performance of Trixi. They represent\r\nmeasured run times that are normalized by the number of `rhs!` evaluations and\r\nthe number of degrees of freedom of the problem setup. The normalization ensures that we can\r\ncompare different measurements for each type of indicator independent of the number of\r\ntime steps or mesh size. All indicators have in common that they are still in units of\r\ntime, thus *lower is better* for each of them.\r\n\r\nHere, the term \"degrees of freedom\" (DOFs) refers to the number of *independent*\r\nstate vectors that are used to represent the numerical solution. For example, if\r\nyou use a DGSEM-type scheme in 2D on a mesh with 8 elements and with\r\n5-by-5 Gauss-Lobatto nodes in each element (i.e., a polynomial degree of 4), the\r\ntotal number of DOFs would be","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"math n_\\text{DOFs,DGSEM} = {\\text{number of elements}} \\cdot {\\text{number of nodes per element}} = 8 \\cdot (5 \\cdot 5) = 200.","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"In contrast, for a finite volume-type scheme on a mesh with 8 elements, the total number of\r\nDOFs would be (independent of the number of spatial dimensions)","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"math n_\\text{DOFs,FV} = {\\text{number of elements}} = 8,","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"since for standard finite volume methods you store a single state vector in each\r\nelement. Note that we specifically count the number of state *vectors* and not\r\nthe number of state *variables* for the DOFs. That is, in the previous example\r\n``n_\\text{DOFs,FV}`` is equal to 8 independent of whether this is a compressible Euler\r\nsetup with 5 state variables or a linear scalar advection setup with one state\r\nvariable.\r\n\r\nFor each indicator, the measurements are always since the last invocation of the\r\n`AnalysisCallback`. That is, if the analysis callback is called multiple times,\r\nthe indicators are repeatedly computed and can thus also be used to track the\r\nperformance over the course of a longer simulation, e.g., to analyze setups with varying performance\r\ncharacteristics. Note that the time spent in the `AnalysisCallback` itself is always\r\n*excluded*, i.e., the performance measurements are not distorted by potentially\r\nexpensive solution analysis computations. All other parts of a Trixi simulation\r\nare included, however, thus make sure that you disable everything you do *not*\r\nwant to be measured (such as I/O callbacks, visualization etc.).\r\n\r\n!!! note \"Performance indicators and adaptive mesh refinement\"\r\n    Currently it is not possible to compute meaningful performance indicators for a simulation\r\n    with arbitrary adaptive mesh refinement, since this would require to\r\n    explicitly keep track of the number of DOF updates due to the mesh size\r\n    changing repeatedly. The only way to do this at the moment is by setting the\r\n    analysis interval to the same value as the AMR interval.\r\n\r\n### Local, `rhs!`-only indicator\r\nThe *local, `rhs!`-only indicator* is computed as","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"math \\text{time/DOF/rhs!} = \\frac{t\\text{\\texttt{rhs!}}}{n\\text{DOFs,local} \\cdot n_\\text{calls,\\texttt{rhs!}}},","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"where ``t_\\text{\\texttt{rhs!}}`` is the accumulated time spent in `rhs!`,\r\n``n_\\text{DOFs,local}`` is the *local* number of DOFs (i.e., on the\r\ncurrent MPI rank; if doing a serial run, you can just think of this as *the*\r\nnumber of DOFs), and ``n_\\text{calls,\\texttt{rhs!}}`` is the number of times the\r\n`rhs!` function has been evaluated. Note that for this indicator, we measure *only*\r\nthe time spent in `rhs!`, i.e., by definition all computations outside of `rhs!` - specifically\r\nall other callbacks and the time integration method - are not taken into account.\r\n\r\nThe local, `rhs!`-only indicator is usually most useful if you do serial\r\nmeasurements and are interested in the performance of the implementation of your\r\ncore numerical methods (e.g., when doing performance tuning).\r\n\r\n### Performance index (PID)\r\nThe *performance index* (PID) is computed as","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"math \\text{PID} = \\frac{t\\text{wall} \\cdot n\\text{ranks,MPI}}{n\\text{DOFs,global} \\cdot n\\text{calls,\\texttt{rhs!}}}, `wheret\\text{wall}is the walltime since the last call to the AnalysisCallbackn\\text{ranks,MPI}is the number of MPI ranks usedn\\text{DOFs,global}is the *global* number of DOFs (ie the sum of DOFs over all MPI ranks if doing a serial run you can just think of this as *the* number of DOFs) andn\\text{calls,\\texttt{rhs!}}`is the number of times therhs!function has been evaluated since the last call to theAnalysisCallback. The PID measures everything except the time spent in theAnalysisCallback` itself - specifically, all other callbacks and the time integration method itself are included.","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"The PID is usually most useful if you would like to compare the parallel performance of your code to its serial performance. Specifically, it allows you to evaluate the parallelization overhead of your code by giving you a measure of the resources that are necessary to solve a given simulation setup. In a sense, it mimics the \"core hours\" metric that is often used by supercomputer centers to measure how many resources a particular compute job requires. It can thus be seen as a proxy for \"energy used\" and, as an extension, \"monetary cost\".","category":"page"},{"location":"performance.html","page":"Performance","title":"Performance","text":"note: Initialization overhead in measurements\nWhen using one of the integration schemes from OrdinaryDiffEq.jl, their implementation will initialize some OrdinaryDiffEq.jl-specific information during the first time step. Among other things, one additional call to rhs! is performed. Therefore, make sure that for performance measurements using the PID either the number of timesteps or the workload per rhs! call is large enough to make the initialization overhead negligible. Note that the extra call to rhs! is properly accounted for in both the number of calls and the measured time, so you do not need to worry about it being expensive. If you want a perfect timing result, you need to set the analysis interval such that the AnalysisCallback is invoked at least once during the course of the simulation and discard the first PID value.","category":"page"},{"location":"meshes/tree_mesh.html#Tree-mesh","page":"Tree mesh","title":"Tree mesh","text":"","category":"section"},{"location":"meshes/tree_mesh.html","page":"Tree mesh","title":"Tree mesh","text":"The TreeMesh is a Cartesian, h-non-conforming mesh type used in many parts of Trixi. Often, the support for this mesh type is developed best since it was the first mesh type in Trixi, and it is available in one, two, and three space dimensions.","category":"page"},{"location":"meshes/tree_mesh.html","page":"Tree mesh","title":"Tree mesh","text":"It is limited to hypercube domains but supports AMR via the AMRCallback. Due to its Cartesian nature, (numerical) fluxes need to implement methods dispatching on the orientation::Integer as described in the conventions.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"EditURL = \"<unknown>/docs/literate/src/files/parabolic_terms.jl\"","category":"page"},{"location":"tutorials/parabolic_terms.html#parabolic_terms","page":"11 Parabolic terms","title":"11: Parabolic terms","text":"","category":"section"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"Experimental support for parabolic diffusion terms is available in Trixi.jl. This demo illustrates parabolic terms for the advection-diffusion equation.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"using OrdinaryDiffEq\nusing Trixi","category":"page"},{"location":"tutorials/parabolic_terms.html#Splitting-a-system-into-hyperbolic-and-parabolic-parts.","page":"11 Parabolic terms","title":"Splitting a system into hyperbolic and parabolic parts.","text":"","category":"section"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"For a mixed hyperbolic-parabolic system, we represent the hyperbolic and parabolic parts of the system  separately. We first define the hyperbolic (advection) part of the advection-diffusion equation.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"advection_velocity = (1.5, 1.0)\nequations_hyperbolic = LinearScalarAdvectionEquation2D(advection_velocity);\nnothing #hide","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"Next, we define the parabolic diffusion term. The constructor requires knowledge of equations_hyperbolic to be passed in because the LaplaceDiffusion2D applies diffusion to every variable of the hyperbolic system.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"diffusivity = 5.0e-2\nequations_parabolic = LaplaceDiffusion2D(diffusivity, equations_hyperbolic);\nnothing #hide","category":"page"},{"location":"tutorials/parabolic_terms.html#Boundary-conditions","page":"11 Parabolic terms","title":"Boundary conditions","text":"","category":"section"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"As with the equations, we define boundary conditions separately for the hyperbolic and parabolic part of the system. For this example, we impose inflow BCs for the hyperbolic system (no condition is imposed on the outflow), and we impose Dirichlet boundary conditions for the parabolic equations. Both BoundaryConditionDirichlet and BoundaryConditionNeumann are defined for LaplaceDiffusion2D.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"The hyperbolic and parabolic boundary conditions are assumed to be consistent with each other.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"boundary_condition_zero_dirichlet = BoundaryConditionDirichlet((x, t, equations) -> SVector(0.0))\n\nboundary_conditions_hyperbolic = (; x_neg = BoundaryConditionDirichlet((x, t, equations) -> SVector(1 + 0.5 * x[2])),\n                                    y_neg = boundary_condition_zero_dirichlet,\n                                    y_pos = boundary_condition_do_nothing,\n                                    x_pos = boundary_condition_do_nothing)\n\nboundary_conditions_parabolic = (; x_neg = BoundaryConditionDirichlet((x, t, equations) -> SVector(1 + 0.5 * x[2])),\n                                   y_neg = boundary_condition_zero_dirichlet,\n                                   y_pos = boundary_condition_zero_dirichlet,\n                                   x_pos = boundary_condition_zero_dirichlet);\nnothing #hide","category":"page"},{"location":"tutorials/parabolic_terms.html#Defining-the-solver-and-mesh","page":"11 Parabolic terms","title":"Defining the solver and mesh","text":"","category":"section"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"The process of creating the DG solver and mesh is the same as for a purely hyperbolic system of equations.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"solver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)\ncoordinates_min = (-1.0, -1.0) # minimum coordinates (min(x), min(y))\ncoordinates_max = ( 1.0,  1.0) # maximum coordinates (max(x), max(y))\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4,\n                periodicity=false, n_cells_max=30_000) # set maximum capacity of tree data structure\n\ninitial_condition = (x, t, equations) -> SVector(0.0);\nnothing #hide","category":"page"},{"location":"tutorials/parabolic_terms.html#Semidiscretizing-and-solving","page":"11 Parabolic terms","title":"Semidiscretizing and solving","text":"","category":"section"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"To semidiscretize a hyperbolic-parabolic system, we create a SemidiscretizationHyperbolicParabolic. This differs from a SemidiscretizationHyperbolic in that we pass in a Tuple containing both the hyperbolic and parabolic equation, as well as a Tuple containing the hyperbolic and parabolic boundary conditions.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"semi = SemidiscretizationHyperbolicParabolic(mesh,\n                                             (equations_hyperbolic, equations_parabolic),\n                                             initial_condition, solver;\n                                             boundary_conditions=(boundary_conditions_hyperbolic,\n                                                                  boundary_conditions_parabolic))","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"The rest of the code is identical to the hyperbolic case. We create a system of ODEs through semidiscretize, defining callbacks, and then passing the system to OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"tspan = (0.0, 1.5)\node = semidiscretize(semi, tspan)\ncallbacks = CallbackSet(SummaryCallback())\ntime_int_tol = 1.0e-6\nsol = solve(ode, RDPK3SpFSAL49(), abstol=time_int_tol, reltol=time_int_tol,\n            save_everystep=false, callback=callbacks);\nnothing #hide","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"We can now visualize the solution, which develops a boundary layer at the outflow boundaries.","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"","category":"page"},{"location":"tutorials/parabolic_terms.html","page":"11 Parabolic terms","title":"11 Parabolic terms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"EditURL = \"<unknown>/docs/literate/src/files/DGMulti_1.jl\"","category":"page"},{"location":"tutorials/DGMulti_1.html#DGMulti_1","page":"6 DG schemes via DGMulti solver","title":"6: DG schemes via DGMulti solver","text":"","category":"section"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"DGMulti is a DG solver that allows meshes with simplex elements. The basic idea and implementation of this solver is explained in section \"Meshes\". Here, we want to give some examples and a quick overview about the options with DGMulti.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"We start with a simple example we already used in the tutorial about flux differencing. There, we implemented a simulation with initial_condition_weak_blast_wave for the 2D compressible Euler equations CompressibleEulerEquations2D and used the DG formulation with flux differencing using volume flux flux_ranocha and surface flux flux_lax_friedrichs.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"Here, we want to implement the equivalent example, only now using the DGMulti solver instead of DGSEM.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Trixi, OrdinaryDiffEq\n\nequations = CompressibleEulerEquations2D(1.4)\n\ninitial_condition = initial_condition_weak_blast_wave","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"To use the Gauss-Lobatto nodes again, we choose approximation_type=SBP() in the solver. Since we want to start with a Cartesian domain discretized with squares, we use the element type Quad().","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"dg = DGMulti(polydeg = 3,\n             element_type = Quad(),\n             approximation_type = SBP(),\n             surface_flux = flux_lax_friedrichs,\n             volume_integral = VolumeIntegralFluxDifferencing(flux_ranocha))\n\nmesh = DGMultiMesh(dg,\n                   cells_per_dimension=(32, 32), # initial_refinement_level = 5\n                   coordinates_min=(-2.0, -2.0),\n                   coordinates_max=( 2.0,  2.0),\n                   periodicity=true)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, dg,\n                                    boundary_conditions=boundary_condition_periodic)\ntspan = (0.0, 0.4)\node = semidiscretize(semi, tspan)\n\nalive_callback = AliveCallback(alive_interval=10)\nanalysis_callback = AnalysisCallback(semi, interval=100, uEltype=real(dg))\ncallbacks = CallbackSet(analysis_callback, alive_callback);\nnothing #hide","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"Run the simulation with the same time integration algorithm as before.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"sol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6,\n            callback=callbacks, save_everystep=false);\nnothing #hide","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Plots\npd = PlotData2D(sol)\nplot(pd)","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"plot(pd[\"rho\"])\nplot!(getmesh(pd))","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"This simulation is not as fast as the equivalent with TreeMesh since no special optimizations for quads (for instance tensor product structure) have been implemented. Figure 4 in \"Efficient implementation of modern entropy stable and kinetic energy preserving discontinuous Galerkin methods for conservation laws\" (2021) provides a nice runtime comparison between the different mesh types. On the other hand, the functions are more general and thus we have more option we can choose from.","category":"page"},{"location":"tutorials/DGMulti_1.html#Simulation-with-Gauss-nodes","page":"6 DG schemes via DGMulti solver","title":"Simulation with Gauss nodes","text":"","category":"section"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"For instance, we can change the approximation type of our simulation.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Trixi, OrdinaryDiffEq\nequations = CompressibleEulerEquations2D(1.4)\ninitial_condition = initial_condition_weak_blast_wave","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"We now use Gauss nodes instead of Gauss-Lobatto nodes which can be done for the element types Quad() and Hex(). Therefore, we set approximation_type=GaussSBP(). Alternatively, we can use a modal approach using the approximation type Polynomial().","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"dg = DGMulti(polydeg = 3,\n             element_type = Quad(),\n             approximation_type = GaussSBP(),\n             surface_flux = flux_lax_friedrichs,\n             volume_integral = VolumeIntegralFluxDifferencing(flux_ranocha))\n\nmesh = DGMultiMesh(dg,\n             cells_per_dimension=(32, 32), # initial_refinement_level = 5\n             coordinates_min=(-2.0, -2.0),\n             coordinates_max=( 2.0,  2.0),\n             periodicity=true)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, dg,\n                              boundary_conditions=boundary_condition_periodic)\ntspan = (0.0, 0.4)\node = semidiscretize(semi, tspan)\n\nalive_callback = AliveCallback(alive_interval=10)\nanalysis_callback = AnalysisCallback(semi, interval=100, uEltype=real(dg))\ncallbacks = CallbackSet(analysis_callback, alive_callback);\n\nsol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6,\n            callback=callbacks, save_everystep=false);\nnothing #hide","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Plots\npd = PlotData2D(sol)\nplot(pd)","category":"page"},{"location":"tutorials/DGMulti_1.html#Simulation-with-triangular-elements","page":"6 DG schemes via DGMulti solver","title":"Simulation with triangular elements","text":"","category":"section"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"Also, we can set another element type. We want to use triangles now.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Trixi, OrdinaryDiffEq\nequations = CompressibleEulerEquations2D(1.4)\ninitial_condition = initial_condition_weak_blast_wave","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"Since there is no direct equivalent to Gauss-Lobatto nodes on triangles, the approximation type SBP() now uses Gauss-Lobatto nodes on faces and special nodes in the interior of the triangular. More details can be found in the documentation of StartUpDG.jl.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"dg = DGMulti(polydeg = 3,\n             element_type = Tri(),\n             approximation_type = SBP(),\n             surface_flux = flux_lax_friedrichs,\n             volume_integral = VolumeIntegralFluxDifferencing(flux_ranocha))\n\nmesh = DGMultiMesh(dg,\n                   cells_per_dimension=(32, 32), # initial_refinement_level = 5\n                   coordinates_min=(-2.0, -2.0),\n                   coordinates_max=( 2.0,  2.0),\n                   periodicity=true)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, dg,\n                                    boundary_conditions=boundary_condition_periodic)\ntspan = (0.0, 0.4)\node = semidiscretize(semi, tspan)\n\nalive_callback = AliveCallback(alive_interval=10)\nanalysis_callback = AnalysisCallback(semi, interval=100, uEltype=real(dg))\ncallbacks = CallbackSet(analysis_callback, alive_callback);\n\nsol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6,\n            callback=callbacks, save_everystep=false);\nnothing #hide","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Plots\npd = PlotData2D(sol)\nplot(pd)","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"plot(pd[\"rho\"])\nplot!(getmesh(pd))","category":"page"},{"location":"tutorials/DGMulti_1.html#Triangular-meshes-on-non-Cartesian-domains","page":"6 DG schemes via DGMulti solver","title":"Triangular meshes on non-Cartesian domains","text":"","category":"section"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"To use triangular meshes on a non-Cartesian domain, Trixi uses the package StartUpDG.jl. The following example is based on elixir_euler_triangulate_pkg_mesh.jl and uses a pre-defined mesh from StartUpDG.jl.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Trixi, OrdinaryDiffEq","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"We want to simulate the smooth initial condition initial_condition_convergence_test with source terms source_terms_convergence_test for the 2D compressible Euler equations.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"equations = CompressibleEulerEquations2D(1.4)\ninitial_condition = initial_condition_convergence_test\nsource_terms = source_terms_convergence_test","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"We create the solver DGMulti with triangular elements (Tri()) as before.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"dg = DGMulti(polydeg = 3, element_type = Tri(),\n             approximation_type=Polynomial(),\n             surface_flux = flux_lax_friedrichs,\n             volume_integral = VolumeIntegralFluxDifferencing(flux_ranocha))","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"StartUpDG.jl provides for instance a pre-defined Triangulate geometry for a rectangular domain with hole RectangularDomainWithHole. Other pre-defined Triangulate geometries are e.g., SquareDomain, Scramjet, and CircularDomain.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"meshIO = StartUpDG.triangulate_domain(StartUpDG.RectangularDomainWithHole());\nnothing #hide","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"The pre-defined Triangulate geometry in StartUpDG has integer boundary tags. With DGMultiMesh we assign boundary faces based on these integer boundary tags and create a mesh compatible with Trixi.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"mesh = DGMultiMesh(meshIO, dg, Dict(:outer_boundary=>1, :inner_boundary=>2))","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"boundary_condition_convergence_test = BoundaryConditionDirichlet(initial_condition)\nboundary_conditions = (; :outer_boundary => boundary_condition_convergence_test,\n                         :inner_boundary => boundary_condition_convergence_test)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, dg,\n                                    source_terms = source_terms,\n                                    boundary_conditions = boundary_conditions)\n\ntspan = (0.0, 0.2)\node = semidiscretize(semi, tspan)\n\nalive_callback = AliveCallback(alive_interval=20)\nanalysis_callback = AnalysisCallback(semi, interval=200, uEltype=real(dg))\ncallbacks = CallbackSet(alive_callback, analysis_callback);\n\nsol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt = 0.5 * estimate_dt(mesh, dg), save_everystep=false, callback=callbacks);\nnothing #hide","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"using Plots\npd = PlotData2D(sol)\nplot(pd[\"rho\"])\nplot!(getmesh(pd))","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"For more information, please have a look in the StartUpDG.jl documentation.","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"","category":"page"},{"location":"tutorials/DGMulti_1.html","page":"6 DG schemes via DGMulti solver","title":"6 DG schemes via DGMulti solver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"github-git.html#GitHub-and-Git","page":"GitHub & Git","title":"GitHub & Git","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"This page contains information on how to use GitHub and Git when developing Trixi.","category":"page"},{"location":"github-git.html#Development-workflow","page":"GitHub & Git","title":"Development workflow","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"For adding modifications to Trixi, we generally follow these steps:","category":"page"},{"location":"github-git.html#Create-an-issue-(optional)","page":"GitHub & Git","title":"Create an issue (optional)","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"In many cases it makes sense to start by creating an issue on GitHub. For example, if the implementation approach for a new feature is not yet clear or if there should be a discussion about the desired outcome, it is good practice to first get a consensus on what is the expected result of this modification. A GitHub issue is the place to lead this discussion, as it preserves it in the project and - together with the actual code changes - allows in the future to revisit the reasons for a particular choice of implementation or feature.","category":"page"},{"location":"github-git.html#Create-a-branch-and-*immediately*-create-a-pull-request","page":"GitHub & Git","title":"Create a branch and immediately create a pull request","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"All feature development, bug fixes etc. should be developed in a branch and not directly on main. If you do not have write access to the main repository on GitHub, first create a fork of the Trixi.jl repository and clone the fork to your machine. Then, create a branch locally by executing git checkout -b yourbranch, push it to the repository, and create a pull request (PR).","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"If you have already cloned Trixi.jl from the main repo to your local machine, you can also work in that clone. You just need to add your fork as additional remote repository and push your new branch there.","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"git remote add myfork git@github.com:YOUR_NAME/Trixi.jl.git\r\n# get latest main from the main repo\r\ngit checkout main\r\ngit pull\r\n# create a new branch for a cool new feature, bug fix, ...\r\ngit checkout -b YOUR_BRANCH_NAME\r\n# do some work and push it to your fork\r\ngit push -u myfork\r\n# go to https://github.com/trixi-framework/Trixi.jl/pull\r\n# and create a PR from your new branch","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"info: Why using pull requests?\nImmediately creating a PR for your branch has the benefit that all code discussions can now be held directly next to the corresponding code. Also, the PR allows to easily compare your branch to the upstream branch (usually main) to see what you have changed. Moreover, tests will run automatically.","category":"page"},{"location":"github-git.html#Make-changes","page":"GitHub & Git","title":"Make changes","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"With a branch and PR in place, you can now write your code and commit it to your branch. If you request feedback from someone else, make sure to push your branch to the repository such that the others can easily review your changes or dive in and change something themselves.","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"warning: Avoid committing unwanted files\nWhen you use git add . or similar catch-all versions, make sure you do not accidentally commit unwanted files (e.g., Trixi output files, images or videos etc.). If it happens anyways, you can undo the last commit (also multiple times) by running git reset HEAD~ (see also Undo last commit). However, this strategy only works if you have not yet pushed your changes. If you did push your changes, please talk to one of the core developers on how to proceed.","category":"page"},{"location":"github-git.html#Keep-your-branch-in-sync-with-main","page":"GitHub & Git","title":"Keep your branch in sync with main","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"For larger features with longer-living branches, it may make sense to synchronize your branch with the current main, e.g., if there was a bug fix in main that is relevant for you. In this case, perform the following steps to merge the current main to your branch:","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Commit all your local changes to your branch and push it. This allows you to delete your clone in case you make a mistake and need to abort the merge.\nExecute git fetch to get the latest changes from the repository.\nMake sure you are in the correct branch by checking the output of git status or by running git checkout yourbranch.\nMerge main using git merge main. If there were no conflicts, hooray!, you are done. Otherwise you need to resolve your merge conflicts and commit the changes afterwards. A good guide for resolving merge conflicts can be found here.","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"In general, always use git merge and not git rebase to get the latest changes from main. It is less error-prone and does not create problems on branches that are worked on collaboratively.","category":"page"},{"location":"github-git.html#Prepare-for-review","page":"GitHub & Git","title":"Prepare for review","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"If you feel like your branch is ready to be merged to main, prepare it for review. That is, you should","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"merge the current main to your branch\nrun tests if available, but at least ensure that you did not accidentally change the results for one of the existing example elixirs\nproperly comment your code\ndelete old/unused code, especially commented lines (unless they contain helpful code, in which case you should add a comment on why you keep this around)\nremove debug statements\nadd a elixir_xxx.jl that uses your feature (only relevant for new features)\nmake sure your code formatting adheres to the Style guide\ndescribe changes in NEWS.md if appropriate","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"After you are confident that your branch is cleaned up properly, commit all changes and push them to the repository.","category":"page"},{"location":"github-git.html#Get-reviewed","page":"GitHub & Git","title":"Get reviewed","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Ask one of the core developers to review your code. Sometimes this will be done directly, either face-to-face or via a video call. Other times a review will be conducted asynchronously, with the reviewer leaving comments and annotations. In some cases it will be necessary to do multiple rounds of reviews, especially if there are larger changes to be added. Just commit and push your changes to your branch, and the corresponding pull request will be updated automatically.","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Please note that a review has nothing to do with the lack of experience of the person developing changes: We try to review all code before it gets added to main, even from the most experienced developers. This is good practice and helps to keep the error rate low while ensuring the the code is developed in a consistent fashion. Furthermore, do not take criticism of your code personally - we just try to keep Trixi as accessible and easy to use for everyone.","category":"page"},{"location":"github-git.html#Merge-branch","page":"GitHub & Git","title":"Merge branch","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Once your branch is reviewed and declared ready for merging by the reviewer, make sure that all the latest changes have been pushed. Then, one of the developers will merge your PR. If you are one of the developers, you can also go to the pull request page on GitHub and and click on Merge pull request. Voilá, you are done! Your branch will have been merged to main and the source branch will have been deleted in the GitHub repository (if you are not working in your own fork).","category":"page"},{"location":"github-git.html#Update-your-working-copy","page":"GitHub & Git","title":"Update your working copy","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Once you have merged your branch by accepting the PR on GitHub, you should clean up your local working copy of the repository by performing the following steps:","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Update your clone by running git fetch.\nCheck out main using git checkout main.\nDelete merged branch locally with git branch -d yourbranch.\nRemove local references to deleted remote branch by executing git remote prune origin.","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"You can now proceed with your next changes by starting again at the top.","category":"page"},{"location":"github-git.html#Using-Git","page":"GitHub & Git","title":"Using Git","text":"","category":"section"},{"location":"github-git.html#Resources-for-learning-Git","page":"GitHub & Git","title":"Resources for learning Git","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Here are a few resources for learning do use Git that at least one of us found helpful in the past (roughly ordered from novice to advanced to expert):","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Git Handbook by GitHub\nLearn Git Branching","category":"page"},{"location":"github-git.html#Tips-and-tricks","page":"GitHub & Git","title":"Tips and tricks","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"This is an unordered collection of different tips and tricks that can be helpful while working with Git. As usual, your mileage might vary.","category":"page"},{"location":"github-git.html#Undo-last-commit","page":"GitHub & Git","title":"Undo last commit","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"If you made a mistake in your last commit, e.g., by committing an unwanted file, you can undo the latest commit by running","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"git reset HEAD~","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"This only works if you have not yet pushed your branch to the GitHub repository. In this case, please talk to one of the core developers on how to proceed. Especially when you accidentally committed a large file (image, or video), please let us know as fast as possible, since the effort to fix the repository grows considerably over time.","category":"page"},{"location":"github-git.html#Remove-large-file-from-repository","page":"GitHub & Git","title":"Remove large file from repository","text":"","category":"section"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"If a large file was accidentally committed and pushed to the Trixi repository, please talk to one of the core developers as soon as possible so that they can fix it.","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"danger: Large files\nYou should never try to fix this yourself, as it potentially disrupts/destroys the work of others!","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Based on the instructions found here and here, the following steps need to be taken (as documented for GitLab in issue #33):","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Tell everyone to commit and push their changes to the repository.\nFix the branch in which the file was committed by removing it and committing the removal. This is especially important on main.\nPerform the following steps to clean up the Git repository: ```bash cd /tmp","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":" # Download bfg-1.13.0.jar from https://rtyley.github.io/bfg-repo-cleaner/\r\n\n # Get fresh clone of repo (so you can throw it away in case there is a problem)\r\n git clone --mirror git@github.com:trixi-framework/Trixi.jl.git\r\n\n # Clean up repo of all files larger than 10M\r\n java -jar bfg-1.13.0.jar --strip-blobs-bigger-than 10M Trixi.jl.git\r\n\n # Enter repo\r\n cd Trixi.jl.git\r\n\n # Clean up reflog and force aggressive garbage collection\r\n git reflog expire --expire=now --all && git gc --prune=now --aggressive\r\n\n # Push changes\r\n git push\r\n\n # Delete clone\r\n rm -rf Trixi.jl.git\r\n ```","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":"Tell everyone to clean up their local working copies by performing the following steps (also do this yourself): ```bash\nEnter repo\ncd Trixi.jl","category":"page"},{"location":"github-git.html","page":"GitHub & Git","title":"GitHub & Git","text":" # Get current changes\r\n git fetch\r\n\n # Check out the fixed branch\r\n git checkout branchname\r\n\n # IMPORTANT: Do a rebase instead of a pull!\r\n git rebase\r\n\n # Clean reflog and force garbage collection\r\n git reflog expire --expire=now --all && git gc --prune=now --aggressive\r\n ```\r\n **IMPORTANT**: You need to do a `git rebase` instead of a `git pull` when\r\n updating the fixed branch.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"EditURL = \"<unknown>/docs/literate/src/files/adding_new_scalar_equations.jl\"","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html#adding_new_scalar_equations","page":"9 Adding a new scalar conservation law","title":"9: Adding a new scalar conservation law","text":"","category":"section"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"If you want to use Trixi for your own research, you might be interested in a new physics model that's not already included in Trixi.jl. In this tutorial, we will implement the cubic conservation law","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"partial_t u(tx) + partial_x u(tx)^3 = 0","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"in a periodic domain in one space dimension. In Trixi.jl, such a mathematical model is encoded as a subtype of Trixi.AbstractEquations.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html#Basic-setup","page":"9 Adding a new scalar conservation law","title":"Basic setup","text":"","category":"section"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"using Trixi\n\nstruct CubicEquation <: Trixi.AbstractEquations{1 #= number of spatial dimensions =#,\n                                                1 #= number of primary variables, i.e. scalar =#};\nend","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"We create CubicEquation as an empty struct since we do not use any parameters for this equation. Other models could bundle arbitrary parameters, e.g., the ideal gas constant for the compressible Euler equations.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"Next, we define the physical flux f(u) = u^3 using the calling structure used in Trixi.jl.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"Trixi.flux(u, orientation, equation::CubicEquation) = u.^3\nTrixi.varnames(_, ::CubicEquation) = (\"scalar\",)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"In Trixi.jl, the conserved variables u are usually passed as SVectors of variables at a single physical location. Hence, we must use u.^3 instead of the scalar operation u^3.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"That's already enough to run a simple simulation with a standard DGSEM discretization using the non-dissipative central flux at interfaces.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"using OrdinaryDiffEq\n\n# Create a simulation setup\nequation = CubicEquation()\n\ninitial_condition_sine(x, t, equation::CubicEquation) = SVector(sinpi(x[1]))\n\nmesh = TreeMesh(-1.0, 1.0, # min/max coordinates\n                initial_refinement_level=4,\n                n_cells_max=10^4)\n\nsolver = DGSEM(3 #= polynomial degree =#, flux_central)\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"We wrap the return value of the initial_condition_sine inside an SVector since that's the approach used in Trixi.jl also for systems of equations. We need to index the spatial coordinate x[1], since it is an SVector with one component. In multiple space dimensions, all spatial coordinates are passed together.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"Next, we create an ODEProblem from the SciML/DifferentialEquations ecosystem. We can solve this ODE numerically using any time integration method, e.g., SSPRK43 from OrdinaryDiffEq.jl. Before, we set up a callback to summarize the simulation setup.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"# Create ODE problem with given time span\ntspan = (0.0, 0.09)\node = semidiscretize(semi, tspan)\n\nsummary_callback = SummaryCallback()\ncallbacks = CallbackSet(summary_callback)\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes the passed callbacks\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks);\nnothing #hide","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"That's it, you ran your first simulation using your new equation with Trixi! Now, we can plot the solution at the final time using Plots.jl.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"You can already see that discontinuities will develop and oscillations start to occur around steep parts of the wave. That's expected from our central discretization. To avoid these issues, we need to use dissipative numerical fluxes (approximate Riemann solvers) at interfaces.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html#Advanced-setup","page":"9 Adding a new scalar conservation law","title":"Advanced setup","text":"","category":"section"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"Thus, we add a Godunov's flux for our cubic equation. That is easy for this equation since the wave speed f'(u) = 3u^2 is always non-negative.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"@inline Trixi.flux_godunov(u_ll, u_rr, orientation, equation::CubicEquation) = flux(u_ll, orientation, equation)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"Let's run the example again but with a dissipative numerical flux at interfaces. remake will recreate the semidiscretization we used before and only change selected parameters, in this case the solver.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"# A new setup with dissipation\nsemi = remake(semi, solver=DGSEM(3, flux_godunov))\node = semidiscretize(semi, tspan)\nsol = solve(ode, SSPRK43(), save_everystep=false)\nplot!(sol)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"You can see that there are fewer oscillations, in particular around steep edges. Now let's increase the final time (and also the spatial resolution).","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"# A larger final time: Nonclassical shocks develop (you can even increase the refinement to 12)\nsemi = remake(semi, mesh=TreeMesh(-1.0, 1.0, initial_refinement_level=8, n_cells_max=10^5))\node = semidiscretize(semi, (0.0, 0.5) #= tspan =#)\nsol = solve(ode, SSPRK43(), save_everystep=false)\nplot(sol)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"You can observe that nonclassical shocks develop and are stable under grid refinement, e.g. for initial_refinement_level=12. In this case, these nonclassical shocks can be avoided by using an entropy-dissipative semidiscretization. Thus, we need to define an entropy-conservative numerical flux","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"@inline function Trixi.flux_ec(u_ll, u_rr, orientation, equation::CubicEquation)\n  return SVector(0.25 * (u_ll[1]^3 + u_ll[1]^2 * u_rr[1] + u_ll[1] * u_rr[1]^2 + u_rr[1]^3))\nend","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"and use a VolumeIntegralFluxDifferencing instead of the standard VolumeIntegralWeakForm in the DGSEM.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"# Let's use a provably entropy-dissipative semidiscretization\nsemi = remake(semi, solver=DGSEM(3, flux_godunov, VolumeIntegralFluxDifferencing(flux_ec)))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(), save_everystep=false);\nplot(sol)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"Possible next steps could be","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"to define Trixi.max_abs_speeds(u, equations::CubicEquation) = 3 * u[1]^2 to use CFL-based time step control via a StepsizeCallback\nto define quantities of interest like Trixi.entropy(u, equations::CubicEquation) = u[1]^2 and integrate them in a simulation using the AnalysisCallback\nto experiment with shock-capturing volume integrals VolumeIntegralShockCapturingHG and adaptive mesh refinement AMRCallback","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"For further reading, Trixi provides another example on adding a scalar equation. In the elixir about the KPP problem, the 2D scalar \"KPP equation\" from Kurganov, Petrova, Popov (2007) is implemented.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html#Summary-of-the-code","page":"9 Adding a new scalar conservation law","title":"Summary of the code","text":"","category":"section"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"To sum up, here is the complete code that we used (without the callbacks since these create a lot of unnecessary output in the doctests of this tutorial). In addition, we create the struct inside the new module CubicConservationLaw. That ensures that we can re-create structs defined therein without having to restart Julia.","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"# Define new physics\nmodule CubicConservationLaw\n\nusing Trixi\n\nstruct CubicEquation <: Trixi.AbstractEquations{1 #= number of spatial dimensions =#,\n                                                1 #= number of primary variables, i.e. scalar =#}\nend\n\n@inline Trixi.flux(u, orientation, equation::CubicEquation) = u.^3\nTrixi.varnames(_, ::CubicEquation) = (\"scalar\",)\n\n@inline Trixi.flux_godunov(u_ll, u_rr, orientation, equation::CubicEquation) = flux(u_ll, orientation, equation)\n@inline function Trixi.flux_ec(u_ll, u_rr, orientation, equation::CubicEquation)\n  return SVector(0.25 * (u_ll[1]^3 + u_ll[1]^2 * u_rr[1] + u_ll[1] * u_rr[1]^2 + u_rr[1]^3))\nend\n\nend # module\n\n\n# Create a simulation setup\nimport .CubicConservationLaw\nusing Trixi\nusing OrdinaryDiffEq\nusing Plots\n\nequation = CubicConservationLaw.CubicEquation()\n\ninitial_condition_sine(x, t, equation::CubicConservationLaw.CubicEquation) = SVector(sinpi(x[1]))\n\nmesh = TreeMesh(-1.0, 1.0, # min/max coordinates\n                initial_refinement_level=4,\n                n_cells_max=10^4)\n\nsolver = DGSEM(3 #= polynomial degree =#, flux_central)\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create ODE problem with given time span\ntspan = (0.0, 0.1)\node = semidiscretize(semi, tspan)\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes the passed callbacks\nsol = solve(ode, SSPRK43(), save_everystep=false)\nplot(sol)\n\n\n# A new setup with dissipation\nsemi = remake(semi, solver=DGSEM(3, flux_godunov))\node = semidiscretize(semi, tspan)\nsol = solve(ode, SSPRK43(), save_everystep=false)\nplot!(sol)\n\n\n# A larger final time: Nonclassical shocks develop (you can even increase the refinement to 12)\nsemi = remake(semi, mesh=TreeMesh(-1.0, 1.0, initial_refinement_level=8, n_cells_max=10^5))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(), save_everystep=false)\nplot(sol)\n\n\n# Let's use a provably entropy-dissipative semidiscretization\nsemi = remake(semi, solver=DGSEM(3, flux_godunov, VolumeIntegralFluxDifferencing(flux_ec)))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(), save_everystep=false)\nplot(sol)","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"","category":"page"},{"location":"tutorials/adding_new_scalar_equations.html","page":"9 Adding a new scalar conservation law","title":"9 Adding a new scalar conservation law","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"EditURL = \"<unknown>/docs/literate/src/files/index.jl\"","category":"page"},{"location":"tutorials/introduction.html#Tutorials-for-Trixi.jl","page":"Introduction","title":"Tutorials for Trixi.jl","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"The tutorial section for Trixi.jl also contains interactive step-by-step explanations via Binder.","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Right now, you are using the classic documentation. The corresponding interactive notebooks can be opened in Binder and viewed in nbviewer via the icons (Image: ) and (Image: ) in the respective tutorial. You can download the raw notebooks from GitHub via (Image: ).","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Note: To improve responsiveness via caching, the notebooks are updated only once a week. They are only available for the latest stable release of Trixi at the time of caching.","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"There are tutorials for the following topics:","category":"page"},{"location":"tutorials/introduction.html#[1-Introduction-to-DG-methods](@ref-scalar_linear_advection_1d)","page":"Introduction","title":"1 Introduction to DG methods","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"This tutorial gives an introduction to discontinuous Galerkin (DG) methods with the example of the scalar linear advection equation in 1D. Starting with some theoretical explanations, we first implement a raw version of a discontinuous Galerkin spectral element method (DGSEM). Then, we will show how to use features of Trixi.jl to achieve the same result.","category":"page"},{"location":"tutorials/introduction.html#[2-DGSEM-with-flux-differencing](@ref-DGSEM_FluxDiff)","page":"Introduction","title":"2 DGSEM with flux differencing","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"To improve stability often the flux differencing formulation of the DGSEM (split form) is used. We want to present the idea and formulation on a basic 1D level. Then, we show how this formulation can be implemented in Trixi and analyse entropy conservation for two different flux combinations.","category":"page"},{"location":"tutorials/introduction.html#[3-Shock-capturing-with-flux-differencing-and-stage-limiter](@ref-shock_capturing)","page":"Introduction","title":"3 Shock capturing with flux differencing and stage limiter","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Using the flux differencing formulation, a simple procedure to capture shocks is a hybrid blending of a high-order DG method and a low-order subcell finite volume (FV) method. We present the idea on a very basic level and show the implementation in Trixi. Then, a positivity preserving limiter is explained and added to an exemplary simulation of the Sedov blast wave with the 2D compressible Euler equations.","category":"page"},{"location":"tutorials/introduction.html#[4-Non-periodic-boundary-conditions](@ref-non_periodic_boundaries)","page":"Introduction","title":"4 Non-periodic boundary conditions","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Thus far, all examples used periodic boundaries. In Trixi, you can also set up a simulation with non-periodic boundaries. This tutorial presents the implementation of the classical Dirichlet boundary condition with a following example. Then, other non-periodic boundaries are mentioned.","category":"page"},{"location":"tutorials/introduction.html#[5-DG-schemes-via-DGMulti-solver](@ref-DGMulti_1)","page":"Introduction","title":"5 DG schemes via DGMulti solver","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"This tutorial is about the more general DG solver DGMulti, introduced here. We are showing some examples for this solver, for instance with discretization nodes by Gauss or triangular elements. Moreover, we present a simple way to include pre-defined triangulate meshes for non-Cartesian domains using the package StartUpDG.jl.","category":"page"},{"location":"tutorials/introduction.html#[6-Other-SBP-schemes-(FD,-CGSEM)-via-DGMulti-solver](@ref-DGMulti_2)","page":"Introduction","title":"6 Other SBP schemes (FD, CGSEM) via DGMulti solver","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Supplementary to the previous tutorial about DG schemes via the DGMulti solver we now present the possibility for DGMulti to use other SBP schemes via the package SummationByPartsOperators.jl. For instance, we show how to set up a finite differences (FD) scheme and a continuous Galerkin (CGSEM) method.","category":"page"},{"location":"tutorials/introduction.html#[7-Upwind-FD-SBP-schemes](@ref-upwind_fdsbp)","page":"Introduction","title":"7 Upwind FD SBP schemes","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"General SBP schemes can not only be used via the DGMulti solver but also with a general DG solver. In particular, upwind finite difference SBP methods can be used together with the TreeMesh. Similar to general SBP schemes in the DGMulti framework, the interface is based on the package SummationByPartsOperators.jl.","category":"page"},{"location":"tutorials/introduction.html#[8-Adding-a-new-scalar-conservation-law](@ref-adding_new_scalar_equations)","page":"Introduction","title":"8 Adding a new scalar conservation law","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"This tutorial explains how to add a new physics model using the example of the cubic conservation law. First, we define the equation using a struct CubicEquation and the physical flux. Then, the corresponding standard setup in Trixi.jl (mesh, solver, semi and ode) is implemented and the ODE problem is solved by OrdinaryDiffEq's solve method.","category":"page"},{"location":"tutorials/introduction.html#[9-Adding-a-non-conservative-equation](@ref-adding_nonconservative_equation)","page":"Introduction","title":"9 Adding a non-conservative equation","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"In this part, another physics model is implemented, the nonconservative linear advection equation. We run two different simulations with different levels of refinement and compare the resulting errors.","category":"page"},{"location":"tutorials/introduction.html#[10-Adaptive-mesh-refinement](@ref-adaptive_mesh_refinement)","page":"Introduction","title":"10 Adaptive mesh refinement","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Adaptive mesh refinement (AMR) helps to increase the accuracy in sensitive or turbolent regions while not wasting ressources for less interesting parts of the domain. This leads to much more efficient simulations. This tutorial presents the implementation strategy of AMR in Trixi, including the use of different indicators and controllers.","category":"page"},{"location":"tutorials/introduction.html#[11-Structured-mesh-with-curvilinear-mapping](@ref-structured_mesh_mapping)","page":"Introduction","title":"11 Structured mesh with curvilinear mapping","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"In this tutorial, the use of Trixi's structured curved mesh type StructuredMesh is explained. We present the two basic option to initialize such a mesh. First, the curved domain boundaries of a circular cylinder are set by explicit boundary functions. Then, a fully curved mesh is defined by passing the transformation mapping.","category":"page"},{"location":"tutorials/introduction.html#[12-Unstructured-meshes-with-HOHQMesh.jl](@ref-hohqmesh_tutorial)","page":"Introduction","title":"12 Unstructured meshes with HOHQMesh.jl","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"The purpose of this tutorial is to demonstrate how to use the UnstructuredMesh2D functionality of Trixi.jl. This begins by running and visualizing an available unstructured quadrilateral mesh example. Then, the tutorial will demonstrate how to conceptualize a problem with curved boundaries, generate a curvilinear mesh using the available HOHQMesh software in the Trixi.jl ecosystem, and then run a simulation using Trixi.jl on said mesh. In the end, the tutorial briefly explains how to simulate an example using AMR via P4estMesh.","category":"page"},{"location":"tutorials/introduction.html#[13-Explicit-time-stepping](@ref-time_stepping)","page":"Introduction","title":"13 Explicit time stepping","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"This tutorial is about time integration using OrdinaryDiffEq.jl. It explains how to use their algorithms and presents two types of time step choices - with error-based and CFL-based adaptive step size control.","category":"page"},{"location":"tutorials/introduction.html#[14-Differentiable-programming](@ref-differentiable_programming)","page":"Introduction","title":"14 Differentiable programming","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"This part deals with some basic differentiable programming topics. For example, a Jacobian, its eigenvalues and a curve of total energy (through the simulation) are calculated and plotted for a few semidiscretizations. Moreover, we calculate an example for propagating errors with Measurement.jl at the end.","category":"page"},{"location":"tutorials/introduction.html#Examples-in-Trixi","page":"Introduction","title":"Examples in Trixi","text":"","category":"section"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"Trixi already contains several more coding examples, the so-called elixirs. You can find them in the folder examples. They are structured by the underlying mesh type and the respective number of spatial dimensions. The name of an elixir is composed of the underlying system of conservation equations (for instance advection or euler) and other special characteristics like the initial condition (e.g. gauss, astro_jet, blast_wave) or the included simulation features (e.g. amr, shockcapturing).","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction.html","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"code_of_conduct.html","page":"Code of Conduct","title":"Code of Conduct","text":"EditURL = \"https://github.com/trixi-framework/Trixi.jl/blob/main/CODE_OF_CONDUCT.md\"","category":"page"},{"location":"code_of_conduct.html#code-of-conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct.html","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Michael Schlottke-Lakemper, Hendrik Ranocha, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"conventions.html#conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"conventions.html#Spatial-dimensions-and-directions","page":"Conventions","title":"Spatial dimensions and directions","text":"","category":"section"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"We use the following numbering schemes on Cartesian or curved structured meshes.","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"The orientations are numbered as 1 => x, 2 => y, 3 => z. For example, numerical fluxes such as flux_central(u_ll, u_rr, orientation, equations::AbstractEquations) use the orientation in this way.\nThe directions are numbered as 1 => -x, 2 => +x, 3 => -y, 4 => +y, 5 => -z, 6 => +z. For example, the boundary_conditions are ordered in this way when a Tuple of boundary conditions per direction is passed to the constructor of a SemidiscretizationHyperbolic.\nFor structured and unstructured curved meshes the concept of direction is generalized via the variable normal_direction. This variable points in the normal direction at a given, curved surface. For the computation of boundary fluxes the normal_direction is normalized to be a normal_vector used, for example, in FluxRotated.","category":"page"},{"location":"conventions.html#Cells-vs.-elements-vs.-nodes","page":"Conventions","title":"Cells vs. elements vs. nodes","text":"","category":"section"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"To uniquely distinguish between different components of the discretization, we use the following naming conventions:","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"The computational domain is discretized by a mesh, which is made up of individual cells. In general, neither the mesh nor the cells should be aware of any solver-specific knowledge, i.e., they should not store anything that goes beyond the geometrical information and the connectivity.\nThe numerical solvers do not directly store their information inside the mesh, but use own data structures. Specifically, for each cell on which a solver wants to operate, the solver creates an element to store solver-specific data.\nFor discretization schemes such as the discontinuous Galerkin or the finite element method, inside each element multiple nodes may be defined, which hold nodal information. The nodes are again a solver-specific component, just like the elements.\nWe often identify elements, nodes, etc. with their (local or global) integer index. Convenience iterators such as eachelement, eachnode use these indices.","category":"page"},{"location":"conventions.html#Keywords-in-elixirs","page":"Conventions","title":"Keywords in elixirs","text":"","category":"section"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"Trixi.jl is distributed with several examples in the form of elixirs, small Julia scripts containing everything to set up and run a simulation. Working interactively from the Julia REPL with these scripts can be quite convenient while for exploratory research and development of Trixi.jl. For example, you can use the convenience function trixi_include to include an elixir with some modified arguments. To enable this, it is helpful to use a consistent naming scheme in elixirs, since trixi_include can only perform simple replacements. Some standard variables names are","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"polydeg for the polynomial degree of a solver\nsurface_flux for the numerical flux at surfaces\nvolume_flux for the numerical flux used in flux differencing volume terms","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"Moreover, convergence_test requires that the spatial resolution is set via the keywords","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"initial_refinement_level (an integer, e.g. for the TreeMesh and the P4estMesh) or\ncells_per_dimension (a tuple of integers, one per spatial dimension, e.g. for the StructuredMesh and the DGMultiMesh).","category":"page"},{"location":"conventions.html#Variable-names","page":"Conventions","title":"Variable names","text":"","category":"section"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"Use descriptive names (using snake_case for variables/functions and CamelCase for types)\nUse a suffix _ as in name_ for local variables that would otherwise hide existing symbols.\nUse a prefix _ as in _name to indicate internal methods/data that are \"fragile\" in the sense that there's no guarantee that they might get changed without notice. These are also not documented with a docstring (but maybe with comments using #).","category":"page"},{"location":"conventions.html#Array-types-and-wrapping","page":"Conventions","title":"Array types and wrapping","text":"","category":"section"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"To allow adaptive mesh refinement efficiently when using time integrators from OrdinaryDiffEq, Trixi allows to represent numerical solutions in two different ways. Some discussion can be found online and in form of comments describing Trixi.wrap_array and Trixi.wrap_array_native in the source code of Trixi. The flexibility introduced by this possible wrapping enables additional performance optimizations. However, it comes at the cost of some additional abstractions (and needs to be used with caution, as described in the source code of Trixi). Thus, we use the following conventions to distinguish between arrays visible to the time integrator and wrapped arrays mainly used internally.","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"Arrays visible to the time integrator have a suffix _ode, e.g., du_ode, u_ode.\nWrapped arrays do not have a suffix, e.g., du, u.","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"Methods either accept arrays visible to the time integrator or wrapped arrays based on the following rules.","category":"page"},{"location":"conventions.html","page":"Conventions","title":"Conventions","text":"When some solution is passed together with a semidiscretization semi, the solution must be a u_ode that needs to be  wrapped via wrap_array(u_ode, semi) (or wrap_array_native(u_ode, semi)) for further processing.\nWhen some solution is passed together with the mesh, equations, solver, cache, ..., it is already wrapped via wrap_array (or wrap_array_native).\nExceptions of this rule are possible, e.g. for AMR, but must be documented in the code.\nwrap_array should be used as default option. wrap_array_native should only be used when necessary, e.g., to avoid additional overhead when interfacing with external C libraries such as HDF5, MPI, or visualization.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"EditURL = \"<unknown>/docs/literate/src/files/adding_new_parabolic_terms.jl\"","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html#adding_new_parabolic_terms","page":"12 Adding new parabolic terms","title":"12: Adding new parabolic terms","text":"","category":"section"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"This demo illustrates the steps involved in adding new parabolic terms for the scalar advection equation. In particular, we will add an anisotropic diffusion. We begin by defining the hyperbolic (advection) part of the advection-diffusion equation.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"using OrdinaryDiffEq\nusing Trixi\n\n\nadvection_velocity = (1.0, 1.0)\nequations_hyperbolic = LinearScalarAdvectionEquation2D(advection_velocity);\nnothing #hide","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html#Define-a-new-parabolic-equation-type","page":"12 Adding new parabolic terms","title":"Define a new parabolic equation type","text":"","category":"section"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Next, we define a 2D parabolic diffusion term type. This is similar to LaplaceDiffusion2D except that the diffusivity field refers to a spatially constant diffusivity matrix now. Note that ConstantAnisotropicDiffusion2D has a field for equations_hyperbolic. It is useful to have information about the hyperbolic system available to the parabolic part so that we can reuse functions defined for hyperbolic equations (such as varnames).","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"struct ConstantAnisotropicDiffusion2D{E, T} <: Trixi.AbstractEquationsParabolic{2, 1}\n  diffusivity::T\n  equations_hyperbolic::E\nend\n\nvarnames(variable_mapping, equations_parabolic::ConstantAnisotropicDiffusion2D) =\n  varnames(variable_mapping, equations_parabolic.equations_hyperbolic)","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Next, we define the viscous flux function. We assume that the mixed hyperbolic-parabolic system is of the form","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"partial_t u(tx) + partial_x (f_1(u) - g_1(u nabla u))\n                  + partial_y (f_2(u) - g_2(u nabla u)) = 0","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"where f_1(u), f_2(u) are the hyperbolic fluxes and g_1(u nabla u), g_2(u nabla u) denote the viscous fluxes. For anisotropic diffusion, the viscous fluxes are the first and second components of the matrix-vector product involving diffusivity and the gradient vector.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Here, we specialize the flux to our new parabolic equation type ConstantAnisotropicDiffusion2D.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"function Trixi.flux(u, gradients, orientation::Integer, equations_parabolic::ConstantAnisotropicDiffusion2D)\n  @unpack diffusivity = equations_parabolic\n  dudx, dudy = gradients\n  if orientation == 1\n    return SVector(diffusivity[1, 1] * dudx + diffusivity[1, 2] * dudy)\n  else # if orientation == 2\n    return SVector(diffusivity[2, 1] * dudx + diffusivity[2, 2] * dudy)\n  end\nend","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html#Defining-boundary-conditions","page":"12 Adding new parabolic terms","title":"Defining boundary conditions","text":"","category":"section"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Trixi.jl's implementation of parabolic terms discretizes both the gradient and divergence using weak formulation. In other words, we discretize the system","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"beginaligned\nbmq = nabla u \nbmsigma = beginpmatrix g_1(u bmq)  g_2(u bmq) endpmatrix \ntextviscous contribution  = nabla cdot bmsigma\nendaligned","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Boundary data must be specified for all spatial derivatives, e.g., for both the gradient equation bmq = nabla u and the divergence of the viscous flux nabla cdot bmsigma. We account for this by introducing internal Gradient and Divergence types which are used to dispatch on each type of boundary condition.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"As an example, let us introduce a Dirichlet boundary condition with constant boundary data.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"struct BoundaryConditionConstantDirichlet{T <: Real}\n  boundary_value::T\nend","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"This boundary condition contains only the field boundary_value, which we assume to be some real-valued constant which we will impose as the Dirichlet data on the boundary.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Boundary conditions have generally been defined as \"callable structs\" (also known as \"functors\"). For each boundary condition, we need to specify the appropriate boundary data to return for both the Gradient and Divergence. Since the gradient is operating on the solution u, the boundary data should be the value of u, and we can directly impose Dirichlet data.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"@inline function (boundary_condition::BoundaryConditionConstantDirichlet)(flux_inner, u_inner, normal::AbstractVector,\n                                                                          x, t, operator_type::Trixi.Gradient,\n                                                                          equations_parabolic::ConstantAnisotropicDiffusion2D)\n  return boundary_condition.boundary_value\nend","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"While the gradient acts on the solution u, the divergence acts on the viscous flux bmsigma. Thus, we have to supply boundary data for the Divergence operator that corresponds to bmsigma. However, we've already imposed boundary data on u for a Dirichlet boundary condition, and imposing boundary data for bmsigma might overconstrain our problem.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Thus, for the Divergence boundary data under a Dirichlet boundary condition, we simply return flux_inner, which is boundary data for bmsigma computed using the \"inner\" or interior solution. This way, we supply boundary data for the divergence operation without imposing any additional conditions.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"@inline function (boundary_condition::BoundaryConditionConstantDirichlet)(flux_inner, u_inner, normal::AbstractVector,\n                                                                          x, t, operator_type::Trixi.Divergence,\n                                                                          equations_parabolic::ConstantAnisotropicDiffusion2D)\n  return flux_inner\nend","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html#A-note-on-the-choice-of-gradient-variables","page":"12 Adding new parabolic terms","title":"A note on the choice of gradient variables","text":"","category":"section"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"It is often simpler to transform the solution variables (and solution gradients) to another set of variables prior to computing the viscous fluxes (see CompressibleNavierStokesDiffusion2D for an example of this). If this is done, then the boundary condition for the Gradient operator should be modified accordingly as well.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html#Putting-things-together","page":"12 Adding new parabolic terms","title":"Putting things together","text":"","category":"section"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"Finally, we can instantiate our new parabolic equation type, define boundary conditions, and run a simulation. The specific anisotropic diffusion matrix we use produces more dissipation in the direction (1 -1) as an isotropic diffusion.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"For boundary conditions, we impose that u=1 on the left wall, u=2 on the bottom wall, and u = 0 on the outflow walls. The initial condition is taken to be u = 0. Note that we use BoundaryConditionConstantDirichlet only for the parabolic boundary conditions, since we have not defined its behavior for the hyperbolic part.","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"using Trixi: SMatrix\ndiffusivity = 5.0e-2 * SMatrix{2, 2}([2 -1; -1 2])\nequations_parabolic = ConstantAnisotropicDiffusion2D(diffusivity, equations_hyperbolic);\n\nboundary_conditions_hyperbolic = (; x_neg = BoundaryConditionDirichlet((x, t, equations) -> SVector(1.0)),\n                                    y_neg = BoundaryConditionDirichlet((x, t, equations) -> SVector(2.0)),\n                                    y_pos = boundary_condition_do_nothing,\n                                    x_pos = boundary_condition_do_nothing)\n\nboundary_conditions_parabolic = (; x_neg = BoundaryConditionConstantDirichlet(1.0),\n                                   y_neg = BoundaryConditionConstantDirichlet(2.0),\n                                   y_pos = BoundaryConditionConstantDirichlet(0.0),\n                                   x_pos = BoundaryConditionConstantDirichlet(0.0));\n\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)\ncoordinates_min = (-1.0, -1.0) # minimum coordinates (min(x), min(y))\ncoordinates_max = ( 1.0,  1.0) # maximum coordinates (max(x), max(y))\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4,\n                periodicity=false, n_cells_max=30_000) # set maximum capacity of tree data structure\n\ninitial_condition = (x, t, equations) -> SVector(0.0)\n\nsemi = SemidiscretizationHyperbolicParabolic(mesh,\n                                             (equations_hyperbolic, equations_parabolic),\n                                             initial_condition, solver;\n                                             boundary_conditions=(boundary_conditions_hyperbolic,\n                                                                  boundary_conditions_parabolic))\n\ntspan = (0.0, 2.0)\node = semidiscretize(semi, tspan)\ncallbacks = CallbackSet(SummaryCallback())\ntime_int_tol = 1.0e-6\nsol = solve(ode, RDPK3SpFSAL49(), abstol=time_int_tol, reltol=time_int_tol,\n            save_everystep=false, callback=callbacks);\n\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"","category":"page"},{"location":"tutorials/adding_new_parabolic_terms.html","page":"12 Adding new parabolic terms","title":"12 Adding new parabolic terms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"EditURL = \"<unknown>/docs/literate/src/files/adaptive_mesh_refinement.jl\"","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#adaptive_mesh_refinement","page":"13 Adaptive mesh refinement","title":"13: Adaptive mesh refinement","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Adaptive mesh refinement (AMR) is a method of adapting the resolution of the numerical method to the solution features such as turbulent regions or shocks. In those critical regions of the domain, we want the simulation to use elements with smaller mesh sizes compared to other regions. This should be automatically and dynamically adapted during the run of the simulation.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#Implementation-in-Trixi","page":"13 Adaptive mesh refinement","title":"Implementation in Trixi","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"In Trixi.jl, AMR is possible for the mesh types TreeMesh and P4estMesh. Both meshes are organized in a tree structure and therefore, each element can be refined independently. In Trixi, AMR is restricted to a 2:1 refinement ratio between neighbor elements. This means that the maximum resolution difference of neighboring elements is a factor of two.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"The implementation of AMR is divided into different steps. The basic refinement setting contains an indicator and a controller. These are added to the simulation by using an AMR callback.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#Indicators","page":"13 Adaptive mesh refinement","title":"Indicators","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"An indicator estimates the current accuracy of the numerical approximation. It indicates which regions of the domain need finer or coarser resolutions. In Trixi, you can use for instance IndicatorLöhner and IndicatorHennemannGassner.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"IndicatorLöhner (also callable with IndicatorLoehner) is an interpretation and adaptation of a FEM indicator by Löhner (1987) and estimates a weighted second derivative of a specified variable locally.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_indicator = IndicatorLöhner(semi, variable=variable)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"All indicators have the parameter variable which is used to specify the variable for the indicator calculation. You can use for instance density, pressure or density_pressure for the compressible Euler equations. Moreover, you have the option to use simply the first conservation variable with first for any equations. This might be a good choice for a starting example.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"IndicatorHennemannGassner, also used as a shock-capturing indicator, was developed by Hennemann et al. (2021) and is explained in detail in the tutorial about shock-capturing. It can be constructed as follows.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_indicator = IndicatorHennemannGassner(semi,\n                                          alpha_max=0.5,\n                                          alpha_min=0.001,\n                                          alpha_smooth=true,\n                                          variable=variable)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Another indicator is the very basic IndicatorMax. It indicates the maximal value of a variable and is therefore mostly used for verification and testing. But it might be useful for the basic understanding of the implementation of indicators and AMR in Trixi.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_indicator = IndicatorMax(semi, variable=variable)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#Controllers","page":"13 Adaptive mesh refinement","title":"Controllers","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"The spatial discretization into elements is tree-based for both AMR supporting mesh types TreeMesh and P4estMesh. Thus, the higher the level in the tree the higher the level of refinement. For instance, a mesh element of level 3 has double resolution in each direction compared to another element with level 2.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"To map specific indicator values to a desired level of refinement, Trixi uses controllers. They are build in three levels: There is a base level of refinement base_level, which is the minimum allowed refinement level. Then, there is a medium level med_level, which corresponds to the initial level of refinement, for indicator values above the threshold med_threshold and equally, a maximal level max_level for values above max_threshold. This variant of controller is called ControllerThreeLevel in Trixi.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_controller = ControllerThreeLevel(semi, amr_indicator;\n                                      base_level=4,\n                                      med_level=5, med_threshold=0.1,\n                                      max_level=6, max_threshold=0.6)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"You can also set med_level=0 to use the current level as target, see the docstring of ControllerThreeLevel.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"An extension is ControllerThreeLevelCombined, which uses two different indicators. The primary indicator works the same as the single indicator for ControllerThreeLevel. The second indicator with its own maximum threshold adds the property, that the target level is set to max_level additionally if this indicator's value is greater than max_threshold_secondary. This is for instance used to assure that a shock has always the maximum refinement level.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_controller = ControllerThreeLevelCombined(semi, indicator_primary, indicator_secondary;\n                                              base_level=2,\n                                              med_level=6, med_threshold=0.0003,\n                                              max_level=8, max_threshold=0.003,\n                                              max_threshold_secondary=0.3)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"This controller is for instance used in elixir_euler_astro_jet_amr.jl.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#Callback","page":"13 Adaptive mesh refinement","title":"Callback","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"The AMR indicator and controller are added to the simulation through the callback AMRCallback. It contains a semidiscretization semi, the controller amr_controller and the parameters interval, adapt_initial_condition, and adapt_initial_condition_only_refine.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Adaptive mesh refinement will be performed every interval time steps. adapt_initial_condition indicates whether the initial condition already should be adapted before the first time step. And with adapt_initial_condition_only_refine=true the mesh is only refined at the beginning but not coarsened.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_callback = AMRCallback(semi, amr_controller,\n                           interval=5,\n                           adapt_initial_condition=true,\n                           adapt_initial_condition_only_refine=true)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#Exemplary-simulation","page":"13 Adaptive mesh refinement","title":"Exemplary simulation","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Here, we want to implement a simple AMR simulation of the 2D linear advection equation for a Gaussian pulse.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"using OrdinaryDiffEq\nusing Trixi\n\nadvection_velocity = (0.2, -0.7)\nequations = LinearScalarAdvectionEquation2D(advection_velocity)\n\ninitial_condition = initial_condition_gauss\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)\n\ncoordinates_min = (-5.0, -5.0)\ncoordinates_max = ( 5.0,  5.0)\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4,\n                n_cells_max=30_000)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)\n\n\ntspan = (0.0, 10.0)\node = semidiscretize(semi, tspan);\nnothing #hide","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"For the best understanding about indicators and controllers, we use the simple AMR indicator IndicatorMax. As described before, it returns the maximal value of the specified variable (here the only conserved variable). Therefore, regions with a high maximum are refined. This is not really useful numerical application, but a nice demonstration example.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_indicator = IndicatorMax(semi, variable=first)","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"These values are transferred to a refinement level with the ControllerThreeLevel, such that every element with maximal value greater than 0.1 is refined once and elements with maximum above 0.6 are refined twice.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"amr_controller = ControllerThreeLevel(semi, amr_indicator,\n                                      base_level=4,\n                                      med_level=5, med_threshold=0.1,\n                                      max_level=6, max_threshold=0.6)\n\namr_callback = AMRCallback(semi, amr_controller,\n                           interval=5,\n                           adapt_initial_condition=true,\n                           adapt_initial_condition_only_refine=true)\n\nstepsize_callback = StepsizeCallback(cfl=0.9)\n\ncallbacks = CallbackSet(amr_callback, stepsize_callback);\nnothing #hide","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Running the simulation.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"sol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1.0, # solve needs some value here but it will be overwritten by the stepsize_callback\n            save_everystep=false, callback=callbacks);\nnothing #hide","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"We plot the solution and add the refined mesh at the end of the simulation.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"using Plots\npd = PlotData2D(sol)\nplot(pd)\nplot!(getmesh(pd))","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html#More-examples","page":"13 Adaptive mesh refinement","title":"More examples","text":"","category":"section"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Trixi provides many elixirs using AMR. We want to give some examples for different mesh types:","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"elixir_euler_blast_wave_amr.jl for TreeMesh and P4estMesh\nelixir_euler_kelvin_helmholtz_instability_amr.jl for TreeMesh\nelixir_euler_double_mach_amr.jl for P4estMesh","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Animations of more interesting and complicated AMR simulations can be found below and on Trixi's youtube channel \"Trixi Framework\".","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"First, we give a purely hyperbolic simulation of a Sedov blast wave with self-gravity. This simulation uses the mesh type TreeMesh as we did and the AMR indicator IndicatorHennemannGassner.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"  <!--\n  Video details\n  * Source: https://www.youtube.com/watch?v=dxgzgteJdOA\n  * Authors: Michael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor Gassner\n  * Setup described in detail in: A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics,\n    Journal of Computational Physics (2021),(https://doi.org/10.1016/j.jcp.2021.110467).\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/dxgzgteJdOA' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Source: Trixi's YouTube channel Trixi Framework","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"The next example is a numerical simulation of an ideal MHD rotor on an unstructured AMR mesh. The used mesh type is a P4estMesh.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"  <!--\n  Video details\n  * Source: https://www.youtube.com/watch?v=Iei7e9oQ0hs\n  * Author: Andrew R. Winters (https://liu.se/en/employee/andwi94)\n  * Obtain responsive code by inserting link on https://embedresponsively.com\n  -->\n  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/Iei7e9oQ0hs' frameborder='0' allowfullscreen></iframe></div>","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"Source: Trixi's YouTube channel Trixi Framework","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"For more information, please have a look at the respective links.","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"","category":"page"},{"location":"tutorials/adaptive_mesh_refinement.html","page":"13 Adaptive mesh refinement","title":"13 Adaptive mesh refinement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"EditURL = \"<unknown>/docs/literate/src/files/scalar_linear_advection_1d.jl\"","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#scalar_linear_advection_1d","page":"2 Introduction to DG methods","title":"2: Introduction to DG methods","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"This tutorial is about how to set up a simple way to approximate the solution of a hyperbolic partial differential equation. First, we will implement a basic and naive algorithm. Then, we will use predefined features from Trixi.jl to show how you can use Trixi.jl on your own.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We will implement the scalar linear advection equation in 1D with the advection velocity 1.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u_t + u_x = 0 textfor tin mathbbR^+ xinOmega=-11","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We define the domain Omega by setting the boundaries.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"coordinates_min = -1.0 # minimum coordinate\ncoordinates_max = 1.0  # maximum coordinate","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We assume periodic boundaries and the following initial condition.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"initial_condition_sine_wave(x) = 1.0 + 0.5 * sin(pi * x)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#The-discontinuous-Galerkin-collocation-spectral-element-method-(DGSEM)","page":"2 Introduction to DG methods","title":"The discontinuous Galerkin collocation spectral element method (DGSEM)","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html#i.-Discretization-of-the-physical-domain","page":"2 Introduction to DG methods","title":"i. Discretization of the physical domain","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"To improve precision we want to approximate the solution on small parts of the physical domain. So, we split the domain Omega=-1 1 into elements Q_l of length dx.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"n_elements = 16 # number of elements\n\ndx = (coordinates_max - coordinates_min) / n_elements # length of one element","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"To make the calculation more efficient and storing less information, we transform each element Q_l with center point x_l to a reference element E=-1 1","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Q_l=Bigx_l-fracdx2 x_l+fracdx2Big undersetx(xi)oversetxi(x)rightleftarrows -1 1","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"So, for every element the transformation from the reference domain to the physical domain is defined by","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"x(xi) = x_l + fracdx2 xi xiin-1 1","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Therefore,","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"beginalign*\nu = u(x(xi) t) \nu_x = u_xi fracdxidx 3pt\nfracdxidx = (x_xi)^-1 = frac2dx = J^-1 \nendalign*","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Here, J is the Jacobian determinant of the transformation.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Using this transformation, we can transform our equation for all elements Q_l.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"fracdx2 u_t^Q_l + u_xi^Q_l = 0 text for tinmathbbR^+ xiin-1 1","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#ii.-Polynomial-approach","page":"2 Introduction to DG methods","title":"ii. Polynomial approach","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Now, we want to approximate the solution in each element Q_l by a polynomial of degree N. Since we transformed the equation, we can use the same polynomial approach for the reference coordinate xiin-1 1 in every physical element Q_l. This saves a lot of ressources by reducing the amount of calculations needed and storing less information.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"For DGSEM we choose Lagrange basis functions l_j_j=0^N as our polynomial basis of degree N in -1 1. The solution in element Q_l can be approximated by","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u(x(xi) t)big_Q_l approx u^Q_l(xi t) = sum_j=0^N u_j^Q_l(t) l_j(xi)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"with N+1 coefficients u_j^Q_l_j=0^N. By contruction the Lagrange basis has some useful advantages. This basis is defined by N+1 nodes, which fulfill a Kronecker property at the exact same nodes. Let xi_i_i=0^N be these nodes.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"l_j(xi_i) = delta_ij =\nbegincases\n1  textif  i=j \n0  textelse\nendcases","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Because of this property, the polynomial coefficients are exact the values of u^Q_l at the nodes","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u^Q_l(xi_i t) = sum_j=0^N u_j^Q_l(t) underbracel_j(xi_i)_=delta_ij = u_i^Q_l(t)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Next, we want to select the nodes xi_i_i=0^N, which we use for the construction of the Lagrange polynomials. We choose the N+1 Gauss-Lobatto nodes, which are used for the Gaussian-Lobatto quadrature. These always contain the boundary points at -1 and +1 and are well suited as interpolation nodes. The corresponding weights will be referred to as w_j_j=0^N. In Trixi.jl the basis with Lagrange polynomials on Gauss-Lobatto nodes is already defined.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"using Trixi\npolydeg = 3 #= polynomial degree = N =#\nbasis = LobattoLegendreBasis(polydeg)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"The Gauss-Lobatto nodes are","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"nodes = basis.nodes","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"with the corresponding weights","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"weights = basis.weights","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"To illustrate how you can integrate using numerical quadrature with this Legendre-Gauss-Lobatto nodes, we give an example for f(x)=x^3. Since f is of degree 3, a polynomial interpolation with N=3 is exact. Therefore, the integral on -1 1 can be calculated by","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"beginalign*\nint_-1^1 f(x) dx = int_-1^1 Big( sum_j=0^3 f(xi_j)l_j(x) Big) dx\n= sum_j=0^3 f(xi_j) int_-1^1 l_j(x)dx \n= sum_j=0^3 f(xi_j) w_j\n= sum_j=0^3 xi_j^3 w_j\nendalign*","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Let's use our nodes and weights for N=3 and plug in","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"integral = sum(nodes.^3 .* weights)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Using this polynomial approach leads to the equation","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"fracdx2 dotu^Q_l(xi t) + u^Q_l(xi t) = 0","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"with dotu=fracpartialpartial tu and u=fracpartialpartial xu. To approximate the solution, we need to get the polynomial coefficients u_j^Q_l_j=0^N for every element Q_l.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"After defining all nodes, we can implement the spatial coordinate x and its initial value u0 for every node.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"x = Matrix{Float64}(undef, length(nodes), n_elements)\nfor element in 1:n_elements\n    x_l = coordinates_min + (element - 1) * dx + dx/2\n    for i in 1:length(nodes)\n        ξ = nodes[i] # nodes in [-1, 1]\n        x[i, element] = x_l + dx/2 * ξ\n    end\nend\n\nu0 = initial_condition_sine_wave.(x)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"To have a look at the initial sinus curve, we plot it.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"using Plots\nplot(vec(x), vec(u0), label=\"initial condition\", legend=:topleft)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#iii.-Variational-formulation","page":"2 Introduction to DG methods","title":"iii. Variational formulation","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"After defining the equation and initial condition, we want to implement an algorithm to approximate the solution.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"From now on, we only write u instead of u^Q_l for simplicity, but consider that all the following calculation only concern one element. Multiplying the new equation with the smooth Lagrange polynomials l_i_i=0^N (test functions) and integrating over the reference element E=-11, we get the variational formulation of our transformed partial differential equation for i=0N:","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"beginalign*\nint_-1^1 Big( fracdx2 dotu(xi t) + u(xi t) Big) l_i(xi)dxi\n  = underbracefracdx2 int_-1^1 dotu(xi t) l_i(xi)dxi_textTerm I + underbraceint_-1^1 u(xi t) l_i(xi)dxi_textTerm II = 0\nendalign*","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We deal with the two terms separately. We write int_-1 N^1 cdot dxi for the approximation of the integral using numerical quadrature with N+1 basis points. We use the Gauss-Lobatto nodes again. The numerical scalar product langlecdot cdotrangle_N is defined by langle f grangle_N = int_-1 N^1 f(xi) g(xi) dxi.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Term-I:","page":"2 Introduction to DG methods","title":"Term I:","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"In the following calculation we approximate the integral numerically with quadrature on the Gauss-Lobatto nodes xi_i_i=0^N and then use the Kronecker property of the Lagrange polynomials. This approach of using the same nodes for the interpolation and quadrature is called collocation.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"beginalign*\nfracdx2 int_-1^1 dotu(xi t) l_i(xi)dxi\napprox fracdx2 int_-1 N^1 dotu(xi t) l_i(xi)dxi \n= fracdx2 sum_k=0^N underbracedotu(xi_k t)_=dotu_k(t) underbracel_i(xi_k)_=delta_kiw_k \n= fracdx2 dotu_i(t) w_i\nendalign*","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We define the Legendre-Gauss-Lobatto (LGL) mass matrix M and by the Kronecker property follows:","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"M_ij = langle l_j l_irangle_N = delta_ij w_j ij=0N","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"using LinearAlgebra\nM = diagm(weights)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Now, we can write the integral with this new matrix.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"fracdx2 int_-1 N^1 dotu(xi t) underlinel(xi)dxi = fracdx2 M underlinedotu(t)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"where underlinedotu = (dotu_0  dotu_N)^T and underlinel respectively.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Note: Since the LGL quadrature with N+1 nodes is exact up to functions of degree 2N-1 and dotu(xi t) l_i(xi) is of degree 2N, in general the following holds","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"int_-1^1 dotu(xi t) l_i(xi) dxi neq int_-1 N^1 dotu(xi t) l_i(xi) dxi","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"With an exact integration the mass matrix would be dense. Choosing numerical integrating and quadrature with the exact same nodes (collocation) leads to the sparse and diagonal mass matrix M. This is called mass lumping and has the big advantage of an easy invertation of the matrix.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Term-II:","page":"2 Introduction to DG methods","title":"Term II:","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We use spatial partial intergration for the second term:","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"int_-1^1 u(xi t) l_i(xi) dxi = u l_i_-1^1 - int_-1^1 u l_idxi","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"The resulting integral can be solved exactly with LGL quadrature since the polynomial is now of degree 2N-1.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Again, we split the calculation in two steps.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Surface-term","page":"2 Introduction to DG methods","title":"Surface term","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"As mentioned before, we approximate the solution with a polynomial in every element. Therefore, in general the value of this approximation at the interfaces between two elements is not unique. To solve this problem we introduce the idea of the numerical flux u^*, which will give an exact value at the interfaces. One of many different approaches and definitions for the calculation of the numerical flux we will deal with in 4. Numerical flux.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u l_i_-1^1 = u^*big^1 l_i(+1) - u^*big_-1 l_i(-1)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Since the Gauss-Lobatto nodes contain the element boundaries -1 and +1, we can use the Kronecker property of l_i for the calculation of l_i(-1) and l_i(+1).","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u underlinel_-1^1 = u^*big^1 left(beginarrayc 0  vdots  0  1 endarrayright)\n- u^*big_-1 left(beginarrayc 1  0  vdots  0endarrayright)\n= B underlineu^*(t)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"with the boundary matrix","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"B = beginpmatrix\n-1  0  cdots  0\n0  0  cdots  0\nvdots  vdots  0  0\n0  cdots  0  1\nendpmatrix\nqquadtextandqquad\nunderlineu^*(t) = left(beginarrayc u^*big_-1  0  vdots  0  u^*big^1endarrayright)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"B = diagm([-1; zeros(polydeg - 1); 1])","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Volume-term","page":"2 Introduction to DG methods","title":"Volume term","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"As mentioned before, the new integral can be solved exact since the function inside is of degree 2N-1.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"- int_-1^1 u l_idxi = - int_-1 N^1 u l_i dxi\n= - sum_k=0^N u(xi_k t) l_i(xi_k) w_k\n= - sum_k=0^N u_k(t) D_ki w_k","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"where D is the derivative matrix defined by D_ki = l_i(xi_k) for ik=0N.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"D = basis.derivative_matrix","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"To show why this matrix is called the derivative matrix, we go back to our example f(x)=x^3. We calculate the derivation of f at the Gauss-Lobatto nodes xi_k_k=0^N with N=8.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"f_x=xi_k = Big( sum_j=0^8 f(xi_j) l_j(x) Big)_x=xi_k = sum_j=0^8 f(xi_j) l_j(xi_k)\n= sum_j=0^8 f(xi_j) D_kj","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"for k=0N and therefore, underlinef = D underlinef.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"basis_N8 = LobattoLegendreBasis(8)\nplot(vec(x), x -> 3 * x^2, label=\"f'\", lw=2)\nscatter!(basis_N8.nodes, basis_N8.derivative_matrix * basis_N8.nodes.^3, label=\"Df\", lw=3)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Combining the volume term for every i=0N results in","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"int_-1^1 u underlinel dxi = - D^T M underlineu(t)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Putting all parts together we get the following equation for the element Q_l","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"fracdx2 M underlinedotu(t) = - B underlineu^*(t) + D^T M underlineu(t)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"or equivalent","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"underlinedotu^Q_l(t) = frac2dx Big - M^-1 B underlineu^Q_l^*(t) + M^-1 D^T M underlineu^Q_l(t)Big","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"This is called the weak form of the DGSEM.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Note: For every element Q_l we get a system of N+1 ordinary differential equations to calculate N+1 coefficients. Since the numerical flux u^* is depending on extern values at the interfaces, the equation systems of adjacent elements are weakly linked.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#numerical_flux","page":"2 Introduction to DG methods","title":"iv. Numerical flux","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"As mentioned above, we still have to handle the problem of different values at the same point at the interfaces. This happens with the ideas of the numerical flux f^*(u)=u^*. The role of f^* might seem minor in this simple example, but is important for more complicated problems. There are two values at the same spatial coordinate. Let's say we are looking at the interface between the elements Q_l and Q_l+1, while both elements got N+1 nodes as defined before. We call the first value of the right element u_R=u_0^Q_l+1 and the last one of the left element u_L=u_N^Q_l. So, for the value of the numerical flux on that interface the following holds","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u^* = u^*(u_L u_R)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"These values are interpreted as start values of a so-called Riemann problem. There are many different (approximate) Riemann solvers available and useful for different problems. We will use the local Lax-Friedrichs flux.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"surface_flux = flux_lax_friedrichs","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"The only missing ingredient is the flux calculation at the boundaries -1 and +1.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"u^Q_first^*big_-1 = u^Q_first^*big_-1(u^bound(-1) u_R)\nquadtextandquad\nu^Q_last^*big^1 = u^Q_last^*big^1(u_L u^bound(1))","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"The boundaries are periodic, which means that the last value of the last element u^Q_last_N is used as u_L at the first interface and accordingly for the other boundary.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Now, we implement a function, that calculates underlinedotu^Q_l for the given matrices, underlineu and underlineu^*.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"function rhs!(du, u, x, t)\n    # Reset du and flux matrix\n    du .= zero(eltype(du))\n    flux_numerical = copy(du)\n\n    # Calculate interface and boundary fluxes, $u^* = (u^*|_{-1}, 0, ..., 0, u^*|^1)^T$\n    # Since we use the flux Lax-Friedrichs from Trixi.jl, we have to pass some extra arguments.\n    # Trixi needs the equation we are dealing with and an additional `1`, that indicates the\n    # first coordinate direction.\n    equations = LinearScalarAdvectionEquation1D(1.0)\n    for element in 2:n_elements-1\n        # left interface\n        flux_numerical[1, element] = surface_flux(u[end, element-1], u[1, element], 1, equations)\n        flux_numerical[end, element-1] = flux_numerical[1, element]\n        # right interface\n        flux_numerical[end, element] = surface_flux(u[end, element], u[1, element+1], 1, equations)\n        flux_numerical[1, element+1] = flux_numerical[end, element]\n    end\n    # boundary flux\n    flux_numerical[1, 1] = surface_flux(u[end, end], u[1, 1], 1, equations)\n    flux_numerical[end, end] = flux_numerical[1, 1]\n\n    # Calculate surface integrals, $- M^{-1} * B * u^*$\n    for element in 1:n_elements\n        du[:, element] -= (M \\ B) * flux_numerical[:, element]\n    end\n\n    # Calculate volume integral, $+ M^{-1} * D^T * M * u$\n    for element in 1:n_elements\n        flux = u[:, element]\n        du[:, element] += (M \\ transpose(D)) * M * flux\n    end\n\n    # Apply Jacobian from mapping to reference element\n    for element in 1:n_elements\n        du[:, element] *= 2 / dx\n    end\n\n    return nothing\nend","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Combining all definitions and the function that calculates the right-hand side, we define the ODE and solve it until t=2 with OrdinaryDiffEq's solve function and the Runge-Kutta method RDPK3SpFSAL49(), which is optimized for discontinuous Galerkin methods and hyperbolic PDEs. We set some common error tolerances abstol=1.0e-6, reltol=1.0e-6 and pass save_everystep=false to avoid saving intermediate solution vectors in memory.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"using OrdinaryDiffEq\ntspan = (0.0, 2.0)\node = ODEProblem(rhs!, u0, tspan, x)\n\nsol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6, save_everystep=false)\n\nplot(vec(x), vec(sol.u[end]), label=\"solution at t=$(tspan[2])\", legend=:topleft, lw=3)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Alternative-Implementation-based-on-Trixi.jl","page":"2 Introduction to DG methods","title":"Alternative Implementation based on Trixi.jl","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Now, we implement the same example. But this time, we directly use the functionality that Trixi.jl provides.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"using Trixi, OrdinaryDiffEq, Plots","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"First, define the equation with a advection_velocity of 1.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"advection_velocity = 1.0\nequations = LinearScalarAdvectionEquation1D(advection_velocity)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Then, create a DG solver with polynomial degree = 3 and (local) Lax-Friedrichs/Rusanov flux as surface flux. The implementation of the basis and the numerical flux is now already done.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"solver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We will now create a mesh with 16 elements for the physical domain [-1, 1] with periodic boundaries. We use Trixi.jl's standard mesh TreeMesh. Since it's limited to hypercube domains, we choose 2^4=16 elements. The mesh type supports AMR, that' why n_cells_max has to be set, even if we don't need AMR here.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"coordinates_min = -1.0 # minimum coordinate\ncoordinates_max = 1.0  # maximum coordinate\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4, # number of elements = 2^4\n                n_cells_max=30_000) # set maximum capacity of tree data structure (only needed for AMR)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"A semidiscretization collects data structures and functions for the spatial discretization. In Trixi, an initial condition has the following parameter structure and is of the type SVector.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"initial_condition_sine_wave(x, t, equations) = SVector(1.0 + 0.5 * sin(pi * sum(x - equations.advection_velocity * t)))\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_sine_wave, solver)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"Again, combining all definitions and the function that calculates the right-hand side, we define the ODE and solve it until t=2 with OrdinaryDiffEq's solve function and the Runge-Kutta method RDPK3SpFSAL49().","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"tspan = (0.0, 2.0)\node_trixi  = semidiscretize(semi, tspan)\n\nsol_trixi = solve(ode_trixi, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6, save_everystep=false);\nnothing #hide","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"We add a plot of the new approximated solution to the one calculated before.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"plot!(sol_trixi, label=\"solution at t=$(tspan[2]) with Trixi.jl\", legend=:topleft, linestyle=:dash, lw=2)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Summary-of-the-code","page":"2 Introduction to DG methods","title":"Summary of the code","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"To sum up, here is the complete code that we used.","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Raw-implementation","page":"2 Introduction to DG methods","title":"Raw implementation","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"# basis: Legendre-Gauss-Lobatto\nusing Trixi, LinearAlgebra, OrdinaryDiffEq, Plots\npolydeg = 3 #= polynomial degree =#\nbasis = LobattoLegendreBasis(polydeg)\nnodes = basis.nodes # Gauss-Lobatto nodes in [-1, 1]\nD = basis.derivative_matrix\nM = diagm(basis.weights) # mass matrix\nB = diagm([-1; zeros(polydeg - 1); 1])\n\n# mesh\ncoordinates_min = -1.0 # minimum coordinate\ncoordinates_max = 1.0  # maximum coordinate\nn_elements      = 16   # number of elements\n\ndx = (coordinates_max - coordinates_min) / n_elements # length of one element\n\nx = Matrix{Float64}(undef, length(nodes), n_elements)\nfor element in 1:n_elements\n    x_l = -1 + (element - 1) * dx + dx/2\n    for i in 1:length(nodes) # basis points in [-1, 1]\n        ξ = nodes[i]\n        x[i, element] = x_l + dx/2 * ξ\n    end\nend\n\n# initial condition\ninitial_condition_sine_wave(x) = 1.0 + 0.5 * sin(pi * x)\nu0 = initial_condition_sine_wave.(x)\n\nplot(vec(x), vec(u0), label=\"initial condition\", legend=:topleft)\n\n# flux Lax-Friedrichs\nsurface_flux = flux_lax_friedrichs\n\n# rhs! method\nfunction rhs!(du, u, x, t)\n    # reset du\n    du .= zero(eltype(du))\n    flux_numerical = copy(du)\n\n    # calculate interface and boundary fluxes\n    equations = LinearScalarAdvectionEquation1D(1.0)\n    for element in 2:n_elements-1\n        # left interface\n        flux_numerical[1, element] = surface_flux(u[end, element-1], u[1, element], 1, equations)\n        flux_numerical[end, element-1] = flux_numerical[1, element]\n        # right interface\n        flux_numerical[end, element] = surface_flux(u[end, element], u[1, element+1], 1, equations)\n        flux_numerical[1, element+1] = flux_numerical[end, element]\n    end\n    # boundary flux\n    flux_numerical[1, 1] = surface_flux(u[end, end], u[1, 1], 1, equations)\n    flux_numerical[end, end] = flux_numerical[1, 1]\n\n    # calculate surface integrals\n    for element in 1:n_elements\n        du[:, element] -= (M \\ B) * flux_numerical[:, element]\n    end\n\n    # calculate volume integral\n    for element in 1:n_elements\n        flux = u[:, element]\n        du[:, element] += (M \\ transpose(D)) * M * flux\n    end\n\n    # apply Jacobian from mapping to reference element\n    for element in 1:n_elements\n        du[:, element] *= 2 / dx\n    end\n\n    return nothing\nend\n\n# create ODE problem\ntspan = (0.0, 2.0)\node = ODEProblem(rhs!, u0, tspan, x)\n\n# solve\nsol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6, save_everystep=false)\n\nplot(vec(x), vec(sol.u[end]), label=\"solution at t=$(tspan[2])\", legend=:topleft, lw=3)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html#Alternative-Implementation-based-on-Trixi.jl-2","page":"2 Introduction to DG methods","title":"Alternative Implementation based on Trixi.jl","text":"","category":"section"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"using Trixi, OrdinaryDiffEq, Plots\n\n# equation with a advection_velocity of `1`.\nadvection_velocity = 1.0\nequations = LinearScalarAdvectionEquation1D(advection_velocity)\n\n# create DG solver with flux lax friedrichs and LGL basis\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)\n\n# distretize domain with `TreeMesh`\ncoordinates_min = -1.0 # minimum coordinate\ncoordinates_max = 1.0 # maximum coordinate\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4, # number of elements = 2^4\n                n_cells_max=30_000)\n\n# create initial condition and semidiscretization\ninitial_condition_sine_wave(x, t, equations) = SVector(1.0 + 0.5 * sin(pi * sum(x - equations.advection_velocity * t)))\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_sine_wave, solver)\n\n# solve\ntspan = (0.0, 2.0)\node_trixi  = semidiscretize(semi, tspan)\nsol_trixi  = solve(ode_trixi, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6, save_everystep=false);\n\nplot!(sol_trixi, label=\"solution at t=$(tspan[2]) with Trixi.jl\", legend=:topleft, linestyle=:dash, lw=2)","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"","category":"page"},{"location":"tutorials/scalar_linear_advection_1d.html","page":"2 Introduction to DG methods","title":"2 Introduction to DG methods","text":"This page was generated using Literate.jl.","category":"page"},{"location":"testing.html#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"testing.html","page":"Testing","title":"Testing","text":"During the development of Trixi, we rely on continuous testing to ensure that modifications or new features do not break existing functionality or add other errors. In the main Trixi repository (and the repositories for the visualization tool Trixi2Vtk), this is facilitated by GitHub Actions, which allows to run tests automatically upon certain events. When, how, and what is tested by GitHub Actions is controlled by the workflow file .github/workflows/ci.yml. In Trixi and its related repositories, tests are triggered by","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"each git push to main and\neach git push to any pull request.","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"Besides checking functionality, we also analyse the Test coverage to ensure that we do not miss important parts during testing.","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"note: Test and coverage requirements\nBefore merging a pull request (PR) to main, we require thatthe code passes all functional tests\ncode coverage does not decrease.","category":"page"},{"location":"testing.html#Testing-setup","page":"Testing","title":"Testing setup","text":"","category":"section"},{"location":"testing.html","page":"Testing","title":"Testing","text":"The entry point for all testing is the file test/runtests.jl, which is run by the automated tests and which can be triggered manually by executing","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"julia> using Pkg; Pkg.test(\"Trixi\")","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"in the REPL. Since there already exist many tests, we have split them up into multiple files in the test directory to allow for faster testing of individual parts of the code. Thus in addition to performing all tests, you can also just include one of the files named test_xxx.jl to run only a specific subset, e.g.,","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"julia> # Run all 2D tests on the P4estMesh\r\n       include(joinpath(\"test\", \"test_p4est_2d.jl\"))\r\n\r\njulia> # Run all 1D tests for the Euler equations on the TreeMesh\r\n       include(joinpath(\"test\", \"test_tree_1d_euler.jl\"))","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"For the automated tests with GitHub Actions, we run multiple jobs in parallel to reduce the waiting time until all tests are finished. You can see the different components that are run as jobs by looking at the TRIXI_TEST variable in test/runtests.jl.","category":"page"},{"location":"testing.html#Adding-new-tests","page":"Testing","title":"Adding new tests","text":"","category":"section"},{"location":"testing.html","page":"Testing","title":"Testing","text":"We use Julia's built-in unit testing capabilities to configure tests. In general, newly added code must be covered by at least one test, and all new elixirs added to the examples/ directory must be used at least once during testing. New tests should be added to the corresponding test/test_xxx.jl file, e.g., a test involving the 3D linear advection equation on the TreeMesh would go into test/test_tree_3d_advection.jl. Please study one of the existing tests and stay consistent to the current style when creating new tests.","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"Since we want to test as much as possible, we have a lot of tests and frequently create new ones. Naturally, this increases the time to wait for all tests to pass with each novel feature added to Trixi. Therefore, new tests should be as short as reasonably possible, i.e., without being too insensitive to pick up changes or errors in the code.","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"When you add new tests, please check whether all CI jobs still take approximately the same time. If the job where you added new tests takes much longer than everything else, please consider moving some tests from one job to another (or report this incident and ask the main developers for help).","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"note: Test duration\nAs a general rule, tests should last no more than 10 seconds when run with a single thread and after compilation (i.e., excluding the first run).","category":"page"},{"location":"testing.html#Test-coverage","page":"Testing","title":"Test coverage","text":"","category":"section"},{"location":"testing.html","page":"Testing","title":"Testing","text":"In addition to ensuring that the code produces the expected results, the automated tests also record the code coverage. The resulting coverage reports, i.e., which lines of code were executed by at least one test and are thus considered \"covered\" by testing, are automatically uploaded to Coveralls for easy analysis. Typically, you see a number of Coveralls results at the bottom of each pull request: One for each parallel job (see Testing setup), which can usually be ignored since they only cover parts of the code by definition, and a cumulative coverage result named coverage/coveralls. The \"Details\" link takes you to a detailed report on which lines of code are covered by tests, which ones are missed, and especially which new lines the pull requests adds to Trixi's code base that are not yet covered by testing.","category":"page"},{"location":"testing.html","page":"Testing","title":"Testing","text":"note: Coverage requirements\nIn general, we require pull requests to not decrease the overall test coverage percentage in main, with a hard lower bound of 97%.","category":"page"},{"location":"troubleshooting.html#Troubleshooting-and-FAQ","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"","category":"section"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"In general, Trixi.jl works best with the newest Julia release and up-to-date dependencies. If something does not work as expected, try updating your installed Julia packages via the package manager, e.g., by running","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"julia> import Pkg; Pkg.update()","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"If you do  not use the latest stable release of Julia from the  official website, consider updating your Julia installation.","category":"page"},{"location":"troubleshooting.html#old-release","page":"Troubleshooting and FAQ","title":"Installing Trixi as a package only provides an older release","text":"","category":"section"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"Trixi requires fairly recent versions of several of its dependencies, which sometimes causes issues when other installed packages have conflicting version requirements.  In this case, Julia's package manager Pkg will try to handle this gracefully by going back in history until it finds a Trixi release whose version requirements can be met, resulting in an older - and usually outdated - version of Trixi being installed.","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"The following example illustrates this issue:","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"The current Trixi release v0.3.6 requires package Foo with a minimum version of v0.2.\nAn older Trixi release v0.2.1 requires package Foo only with a minimum version of v0.1.\nA user has already installed package Bar, which itself requires Foo with a maximum version of v0.1.","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"In this case, installing Trixi via Pkg will result in version v0.2.1 to be installed instead of the current release v0.3.6. That is, a specific release of Trixi may not be installable if it has a dependency with a higher minimum version that at the same time is restricted to a lower maximum version by another installed package.","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"You can check whether an outdated version of Trixi is installed by executing","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"julia> import Pkg; Pkg.update(\"Trixi\"); Pkg.status(\"Trixi\")","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"in the REPL and comparing the reported Trixi version with the version of the latest release. If the versions differ, you can confirm that it is due to a version conflict by forcing Pkg to install the latest Trixi release, where version is the current release:","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"julia> Pkg.add(name=\"Trixi\", version=\"0.3.6\")","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"In case of a conflict, the command above will produce an error that informs you about the offending packages, similar to the following:","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"   Updating registry at `~/.julia/registries/General`\r\n  Resolving package versions...\r\nERROR: Unsatisfiable requirements detected for package DataStructures [864edb3b]:\r\n DataStructures [864edb3b] log:\r\n ├─possible versions are: [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20, 0.18.0-0.18.8] or uninstalled\r\n ├─restricted by compatibility requirements with DiffEqCallbacks [459566f4] to versions: 0.18.0-0.18.8\r\n │ └─DiffEqCallbacks [459566f4] log:\r\n │   ├─possible versions are: [2.0.0, 2.1.0, 2.2.0, 2.3.0, 2.4.0, 2.5.0-2.5.2, 2.6.0, 2.7.0, 2.8.0, 2.9.0, 2.10.0, 2.11.0, 2.12.0-2.12.1, 2.13.0-2.13.5, 2.14.0-2.14.1, 2.15.0] or uninstalled\r\n │   ├─restricted by compatibility requirements with Trixi [a7f1ee26] to versions: [2.14.0-2.14.1, 2.15.0]\r\n │   │ └─Trixi [a7f1ee26] log:\r\n │   │   ├─possible versions are: [0.1.0-0.1.2, 0.2.0-0.2.6, 0.3.0-0.3.6] or uninstalled\r\n │   │   └─restricted to versions 0.3.6 by an explicit requirement, leaving only versions 0.3.6\r\n │   └─restricted by compatibility requirements with StaticArrays [90137ffa] to versions: 2.15.0 or uninstalled, leaving only versions: 2.15.0\r\n │     └─StaticArrays [90137ffa] log:\r\n │       ├─possible versions are: [0.8.0-0.8.3, 0.9.0-0.9.2, 0.10.0, 0.10.2-0.10.3, 0.11.0-0.11.1, 0.12.0-0.12.5, 1.0.0-1.0.1] or uninstalled\r\n │       └─restricted by compatibility requirements with Trixi [a7f1ee26] to versions: 1.0.0-1.0.1\r\n │         └─Trixi [a7f1ee26] log: see above\r\n └─restricted by compatibility requirements with JLD2 [033835bb] to versions: [0.9.0, 0.10.0, 0.11.0-0.11.1, 0.12.0, 0.13.0, 0.14.0-0.14.1, 0.15.0, 0.16.1, 0.17.0-0.17.20] — no versions left\r\n   └─JLD2 [033835bb] log:\r\n     ├─possible versions are: [0.1.0-0.1.14, 0.2.0-0.2.4, 0.3.0-0.3.1] or uninstalled\r\n     └─restricted by compatibility requirements with BinaryBuilder [12aac903] to versions: 0.1.0-0.1.14\r\n       └─BinaryBuilder [12aac903] log:\r\n         ├─possible versions are: [0.1.0-0.1.2, 0.1.4, 0.2.0-0.2.6] or uninstalled\r\n         └─restricted to versions * by an explicit requirement, leaving only versions [0.1.0-0.1.2, 0.1.4, 0.2.0-0.2.6]","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"From the error message, we can see that ultimately BinaryBuilder is the problem here: It restricts the package DataStructures to version v0.17 (via its dependency JLD2), while Trixi requires at least v0.18 (via its dependency DiffEqCallbacks). Following the official Pkg documentation, there are a number of things you can try to fix such errors:","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"Try updating all packages with julia -e 'using Pkg; Pkg.update()'. A newer version of the problematic package may exist that has updated version requirements.\nRemove the offending package. Running\njulia> import Pkg; Pkg.rm(\"BinaryBuilder\"); Pkg.update(); Pkg.status()\nin the REPL will remove BinaryBuilder and (hopefully) update Trixi to the latest version.\nReport the versioning issue to us and/or the development repository of the conflicting package.  Maybe it is possible to lift the version restrictions such that both packages can live side by side.\nInstead of installing Trixi and conflicting packages in the same (default) environment, consider creating new environments/projects and install only packages required for the specific tasks, as explained in the official Pkg documentation. For example, if you use Trixi for a research project (Bachelor/Master thesis or a paper), you should create a new Julia project/environment for that research and add Trixi as a dependency. If you track all your code and the Project.toml, Manifest.toml files (generated by Pkg) in a version control system such as git, you can make your research easily reproducible (if you also record the version of Julia you are using and leave some comments for others who do not know what you are trying to do, including your future self 😉).","category":"page"},{"location":"troubleshooting.html#font-issues","page":"Troubleshooting and FAQ","title":"There are many questions marks and weird symbols in the output of Trixi","text":"","category":"section"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"This probably means that the default font used by your operating system does not support enough Unicode symbols. Try installing a modern font with decent unicode support, e.g. JuliaMono. Detailed installation instructions are available there.","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"This problems affects users of Mac OS particularly often. At the time of writing, installing JuliaMono is as simple as","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"$ brew tap homebrew/cask-fonts\r\n$ brew install --cask font-juliamono","category":"page"},{"location":"troubleshooting.html#There-are-no-timing-results-of-the-initial-mesh-creation","page":"Troubleshooting and FAQ","title":"There are no timing results of the initial mesh creation","text":"","category":"section"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"By default, the SummaryCallback resets the timer used internally by Trixi when it is initialized (when solve is called). If this step needs to be timed, e.g. to debug performance problems, explicit timings can be used as follows.","category":"page"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"using Trixi\r\n\r\nbegin\r\n  Trixi.reset_timer!(Trixi.timer())\r\n\r\n  equations = LinearScalarAdvectionEquation2D(0.2, -0.7)\r\n  mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), n_cells_max=10^5, initial_refinement_level=5)\r\n  solver = DGSEM(3)\r\n  semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test, solver)\r\n\r\n  Trixi.print_timer(Trixi.timer())\r\nend","category":"page"},{"location":"troubleshooting.html#MPI-ranks-are-assigned-zero-cells-in-[P4estMesh](@ref)-even-though-there-are-enough-cells","page":"Troubleshooting and FAQ","title":"MPI ranks are assigned zero cells in P4estMesh even though there are enough cells","text":"","category":"section"},{"location":"troubleshooting.html","page":"Troubleshooting and FAQ","title":"Troubleshooting and FAQ","text":"The P4estMesh allows one to coarsen the mesh by default. When Trixi is parallelized with multiple MPI ranks, this has the consequence that sibling cells (i.e., child cells with the same parent cell) are kept on the same MPI rank to be able to coarsen them easily. This might cause an unbalanced distribution of cells on different ranks. For 2D meshes, this also means that initially each rank will at least own 4 cells, and for 3D meshes, initially each rank will at least own 8 cells. See issue #1329.","category":"page"},{"location":"authors.html#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors.html","page":"Authors","title":"Authors","text":"Trixi's development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about Trixi. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The Trixi Authors\" as mentioned under License.","category":"page"},{"location":"authors.html#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors.html","page":"Authors","title":"Authors","text":"Michael Schlottke-Lakemper, RWTH Aachen University, Germany\nGregor Gassner, University of Cologne, Germany\nHendrik Ranocha, University of Hamburg, Germany\nAndrew Winters, Linköping University, Sweden\nJesse Chan, Rice University, US","category":"page"},{"location":"authors.html#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors.html","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to Trixi and are listed in alphabetical order:","category":"page"},{"location":"authors.html","page":"Authors","title":"Authors","text":"Maximilian D. Bertrand\nBenjamin Bolm\nJesse Chan\nLars Christmann\nChristof Czernik\nErik Faulhaber\nGregor Gassner\nLucas Gemein\nSven Goldberg\nJoshua Lampert\nJulia Odenthal\nHendrik Ranocha\nAndrés M. Rueda-Ramírez\nFelipe Santillan\nMichael Schlottke-Lakemper\nToskan Theine\nAndrew Winters","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"EditURL = \"<unknown>/docs/literate/src/files/DGSEM_FluxDiff.jl\"","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html#DGSEM_FluxDiff","page":"3 DGSEM with flux differencing","title":"3: DGSEM with flux differencing","text":"","category":"section"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This tutorial starts with a presentation of the weak formulation of the discontinuous Galerkin spectral element method (DGSEM) in order to fix the notation of the used operators. Then, the DGSEM formulation with flux differencing (split form DGSEM) and its implementation in Trixi.jl is shown.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We start with the one-dimensional conservation law","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"u_t + f(u)_x = 0 qquad tin mathbbR^+ xinOmega","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"with the physical flux f.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We split the domain Omega into elements K with center x_K and size Delta x. With the transformation mapping x(xi)=x_K + fracDelta x2 xi we can transform the reference element -11 to every physical element. So, the equation can be restricted to the reference element using the determinant of the Jacobian matrix of the transformation mapping J=fracpartial xpartial xi=fracDelta x2.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"J u_t + f(u)_xi = 0 qquad tin mathbbR^+ xiin -11","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html#The-weak-form-of-the-DGSEM","page":"3 DGSEM with flux differencing","title":"The weak form of the DGSEM","text":"","category":"section"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We consider the so-called discontinuous Galerkin spectral element method (DGSEM) with collocation. It results from choosing a nodal DG ansatz using N+1 Gauss-Lobatto nodes xi_i in -11 with matching interpolation weights w_i, which are used for numerical integration and interpolation with the Lagrange polynomial basis l_i of degree N. The Lagrange functions are created with those nodes and hence fulfil a Kronecker property at the GL nodes. The weak formulation of the DGSEM for one element is","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"J underlinedotu(t) = - M^-1 B underlinef^* + M^-1 D^T M underlinef","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"where underlineu=(u_0 u_1 dots u_N)^TinmathbbR^N+1 is the collected pointwise evaluation of u at the discretization nodes and dotu = partial u  partial t = u_t is the temporal derivative. The nodal values of the flux function f results with collocation in underlinef, since underlinef_j=f(underlineu_j). Moreover, we got the numerical flux f^*=f^*(u^- u^+).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We will now have a short overview over the operators we used.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"The derivative matrix DinmathbbR^(N+1)times (N+1) mimics a spatial derivation on a discrete level with underlinef_x approx D underlinef. It is defined by D_ij = l_j(xi_i).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"The diagonal mass matrix M is defined by M_ij=langle l_j l_irangle_N with the numerical scalar product langle cdot cdotrangle_N defined for functions f and g by","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"langle f grangle_N = int_-1 N^1 f(xi) g(xi) dxi = sum_k=0^N f(xi_k) g(xi_k) w_k","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"The multiplication by M matches a discrete integration","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"  int_-1^1 f(xi) underlinel(xi) dxi approx M underlinef","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"The boundary matrix B=textdiag(-1 0 0 1) represents an evaluation of a function at the boundaries xi_0=-1 and xi_N=1.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"For these operators the following property holds:","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"  M D + (M D)^T = B","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This is called the summation-by-parts (SBP) property since it mimics integration by parts on a discrete level (Gassner (2013)).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"The explicit definitions of the operators and the contruction of the 1D algorithm can be found for instance in the tutorial introduction to DG methods or in more detail in Kopriva (2009).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This property shows the equivalence between the weak form and the following strong formulation of the DGSEM.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"beginalign*\nJ underlinedotu(t)\n= - M^-1 B underlinef^* + M^-1 D^T M underlinef5pt\n= - M^-1 B underlinef^* + M^-1 (B - MD) underlinef5pt\n= - M^-1 B (underlinef^* - underlinef) - D underlinef\nendalign*","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"More information about the equivalence you can find in Kopriva, Gassner (2010).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html#DGSEM-with-flux-differencing","page":"3 DGSEM with flux differencing","title":"DGSEM with flux differencing","text":"","category":"section"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"When using the diagonal SBP property it is possible to rewrite the application of the derivative operator D in the calculation of the volume integral into a subcell based finite volume type differencing formulation (Fisher, Carpenter (2013)). Generalizing","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"(D underlinef)_i = sum_j D_ij underlinef_j\n= 2sum_j frac12 D_ij (underlinef_j + underlinef_i)\neqqcolon 2sum_j  D_ij f_textcentral(u_i u_j)","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"we replace D underlinef in the strong form by 2D underlinef_vol(u^- u^+) with the consistent two-point volume flux f_vol and receive the DGSEM formulation with flux differencing (split form DGSEM) (Gassner, Winters, Kopriva (2016)).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"beginalign*\nJ underlinedotu(t) = - M^-1 B (underlinef^* - underlinef) - 2D underlinef_vol(u^- u^+)5pt\n= - M^-1 B (underlinef^* - underlinef_vol(underlineu underlineu)) - 2D underlinef_vol(u^- u^+)5pt\n= - M^-1 B underlinef_sur^* - (2D - M^-1 B) underlinef_vol5pt\n= - M^-1 B underlinef_sur^* - D_split underlinef_vol\nendalign*","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This formulation is in a weak form type formulation and can be implemented by using the derivative split matrix D_split=(2D-M^-1B) and two different fluxes. We divide between the surface flux f=f_sur used for the numerical flux f_sur^* and the already mentioned volume flux f_vol especially for this formulation.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This formulation creates a more stable version of DGSEM, because it fulfils entropy stability. Moreover it allows the construction of entropy conserving discretizations without relying on exact integration. This is achieved when using a two-point entropy conserving flux function as volume flux in the volume flux differencing formulation. Then, the numerical surface flux can be used to control the dissipation of the discretization and to guarantee decreasing entropy, i.e. entropy stability.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html#fluxDiffExample","page":"3 DGSEM with flux differencing","title":"Implementation in Trixi","text":"","category":"section"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"Now, we have a look at the implementation of DGSEM with flux differencing with Trixi.jl.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"using OrdinaryDiffEq, Trixi","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We implement a simulation for the compressible Euler equations in 2D","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"partial_t beginpmatrix rho  rho v_1  rho v_2  rho e endpmatrix\n+ partial_x beginpmatrix rho v_1  rho v_1^2 + p  rho v_1 v_2  (rho e +p) v_1 endpmatrix\n+ partial_y beginpmatrix rho v_2  rho v_1 v_2  rho v_2^2 + p  (rho e +p) v_2 endpmatrix\n= beginpmatrix 0  0  0  0 endpmatrix","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"for an ideal gas with ratio of specific heats gamma=14. Here, rho is the density, v_1, v_2 the velocities, e the specific total energy and","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"p = (gamma - 1) left( rho e - frac12 rho (v_1^2+v_2^2) right)","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"the pressure.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"gamma = 1.4\nequations = CompressibleEulerEquations2D(gamma)","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"As our initial condition we will use a weak blast wave from Hennemann, Gassner (2020). The primitive variables are defined by","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"beginpmatrix rho  v_1  v_2  p endpmatrix\n= beginpmatrix 10  00  00  10 endpmatrix textif  x_2  05\ntextand  beginpmatrix rho  v_1  v_2  p endpmatrix\n= beginpmatrix 11691  01882 * cos(phi)  01882 * sin(phi)  1245 endpmatrix textelse","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"with phi = tan^-1(fracx_2x_1).","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This initial condition is implemented in Trixi under the name initial_condition_weak_blast_wave.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"initial_condition = initial_condition_weak_blast_wave","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"In Trixi, flux differencing for the volume integral can be implemented with VolumeIntegralFluxDifferencing using symmetric two-point volume fluxes. First, we set up a simulation with the entropy conserving and kinetic energy preserving flux flux_ranocha by Hendrik Ranocha (2018) as surface and volume flux.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We will confirm the entropy conservation property numerically.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"volume_flux = flux_ranocha # = f_vol\nsolver = DGSEM(polydeg=3, surface_flux=volume_flux,\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"Now, we implement Trixi's mesh, semi and ode in a simple framework. For more information please have a look at the documentation, the basic tutorial introduction to DG methods or some basic elixirs.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"coordinates_min = (-2.0, -2.0)\ncoordinates_max = ( 2.0,  2.0)\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=5,\n                n_cells_max=10_000,\n                periodicity=true)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    boundary_conditions=boundary_condition_periodic)\n\n# ODE solvers\ntspan = (0.0, 0.4)\node = semidiscretize(semi, tspan);\nnothing #hide","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"To analyse the entropy conservation of the approximation, we will use the analysis calllback implemented in Trixi. It provides some information about the approximation including the entropy change.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"analysis_callback = AnalysisCallback(semi, interval=100);\nnothing #hide","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We now run the simulation using flux_ranocha for both surface and volume flux.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"sol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6,\n            callback=analysis_callback, save_everystep=false);\nnothing #hide","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"A look at the change in entropy sum partial Spartial U cdot U_t in the analysis callback confirms that the flux is entropy conserving since the change is about machine precision.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We can plot the approximated solution at the time t=0.4.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"Now, we can use for instance the dissipative flux flux_lax_friedrichs as surface flux to get an entropy stable method.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"using OrdinaryDiffEq, Trixi\n\ngamma = 1.4\nequations = CompressibleEulerEquations2D(gamma)\n\ninitial_condition = initial_condition_weak_blast_wave\n\nvolume_flux = flux_ranocha # = f_vol\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs,\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))\n\ncoordinates_min = (-2.0, -2.0)\ncoordinates_max = ( 2.0,  2.0)\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=5,\n                n_cells_max=10_000,\n                periodicity=true)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    boundary_conditions=boundary_condition_periodic)\n\n# ODE solvers\ntspan = (0.0, 0.4)\node = semidiscretize(semi, tspan);\n\nanalysis_callback = AnalysisCallback(semi, interval=100);\nnothing #hide","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"We now run the simulation using the volume flux flux_ranocha and surface flux flux_lax_friedrichs.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"sol = solve(ode, RDPK3SpFSAL49(), abstol=1.0e-6, reltol=1.0e-6,\n            callback=analysis_callback, save_everystep=false);\nnothing #hide","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"The change in entropy confirms the expected entropy stability.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"using Plots\nplot(sol)","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"Of course, you can use more than these two fluxes in Trixi. Here, we will give a short list of possible fluxes for the compressible Euler equations. For the volume flux Trixi provides for example flux_ranocha, flux_shima_etal, flux_chandrashekar, flux_kennedy_gruber. As surface flux you can use all volume fluxes and additionally for instance flux_lax_friedrichs, flux_hll, flux_hllc.","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"","category":"page"},{"location":"tutorials/DGSEM_FluxDiff.html","page":"3 DGSEM with flux differencing","title":"3 DGSEM with flux differencing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"EditURL = \"<unknown>/docs/literate/src/files/time_stepping.jl\"","category":"page"},{"location":"tutorials/time_stepping.html#time_stepping","page":"16 Explicit time stepping","title":"16: Explicit time stepping","text":"","category":"section"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"For the time integration, Trixi.jl uses the package OrdinaryDiffEq.jl from the SciML ecosystem. The interface to this package is the solve(...) function. It always requires an ODE problem and a time integration algorithm as input parameters.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"solve(ode, alg; kwargs...)","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"In Trixi, the ODE problem is created by semidiscretize(semi, tspan) for a semidiscretization semi and the time span tspan. In particular, semidiscretize returns an ODEProblem used by OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"OrdinaryDiffEq.jl provides many integration algorithms, which are summarized in the documentation. Particularly interesting for Trixi.jl are their strong stability preserving (SSP) methods and low-storage methods. There are some differences regarding the choice of the used time step.","category":"page"},{"location":"tutorials/time_stepping.html#Error-based-adaptive-step-sizes","page":"16 Explicit time stepping","title":"Error-based adaptive step sizes","text":"","category":"section"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"First, we treat time integration algorithms with adaptive step sizes, such as SSPRK43. It is used in some elixirs, like elixir_euler_colliding_flow.jl or elixir_euler_astro_jet_amr.jl.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"Other error-based adaptive integration algorithms are for instance RDPK3SpFSAL35, RDPK3Sp35, RDPK3SpFSAL49, RDPK3Sp49, RDPK3SpFSAL510, RDPK3Sp510.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"They already contain an error-based adaptive step size control and heuristics to guess a starting step size. If this heuristic fails in your case, you can specify an appropriately small initial step size as keyword argument dt=... of solve.","category":"page"},{"location":"tutorials/time_stepping.html#CFL-based-step-size-control","page":"16 Explicit time stepping","title":"CFL-based step size control","text":"","category":"section"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"The SciML ecosystem also provides time integration algorithms without adaptive time stepping on their own, such as CarpenterKennedy2N54. Moreover, you also can deactivate the automatic adaptivity of adaptive integration algorithms by passing adaptive=false in the solve function.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"These algorithms require another way of setting the step size. You have to pass dt=... in the solve function. Without other settings, the simulation uses this fixed time step.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"For hyperbolic PDEs, it is natural to use an adaptive CFL-based step size control. Here, the time step is proportional to a ratio of the local measure of mesh spacing Delta x_i for an element i and the maximum (local) wave speed lambda_max related to the largest-magnitude eigenvalue of the flux Jacobian of the hyperbolic system.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"Delta t_n = textCFL * min_i fracDelta x_ilambda_max(u_i^n)","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"We compute Delta x_i by scaling the element size by a factor of 1(N+1), cf. Gassner and Kopriva (2011), Section 5.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"Trixi provides such a CFL-based step size control. It is implemented as the callback StepsizeCallback.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"stepsize_callback = StepsizeCallback(; cfl=1.0)","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"A suitable CFL number depends on many parameters such as the chosen grid, the integration algorithm and the polynomial degree of the spatial DG discretization. So, the optimal number for an example is mostly determined experimentally.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"You can add this CFL-based step size control to your simulation like any other callback.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"callbacks = CallbackSet(stepsize_callback)\nalg = CarpenterKennedy2N54(williamson_condition=false)\nsolve(ode, alg;\n      dt=1.0 # solve needs some value here but it will be overwritten by the stepsize_callback\n      callback=callbacks)","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"You can find simple examples with a CFL-based step size control for instance in the elixirs elixir_advection_basic.jl or elixir_euler_source_terms.jl.","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"","category":"page"},{"location":"tutorials/time_stepping.html","page":"16 Explicit time stepping","title":"16 Explicit time stepping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"EditURL = \"<unknown>/docs/literate/src/files/hohqmesh_tutorial.jl\"","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#hohqmesh_tutorial","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15: Unstructured meshes with HOHQMesh.jl","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Trixi.jl supports numerical approximations on unstructured quadrilateral meshes with the UnstructuredMesh2D mesh type.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The purpose of this tutorial is to demonstrate how to use the UnstructuredMesh2D functionality of Trixi.jl. This begins by running and visualizing an available unstructured quadrilateral mesh example. Then, the tutorial will demonstrate how to conceptualize a problem with curved boundaries, generate a curvilinear mesh using the available software in the Trixi.jl ecosystem, and then run a simulation using Trixi.jl on said mesh.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Unstructured quadrilateral meshes can be made with the High-Order Hex-Quad Mesh (HOHQMesh) generator created and developed by David Kopriva. HOHQMesh is a mesh generator specifically designed for spectral element methods. It provides high-order boundary curve information (needed to accurately set boundary conditions) and elements can be larger (due to the high accuracy of the spatial approximation) compared to traditional finite element mesh generators. For more information about the design and features of HOHQMesh one can refer to its official documentation.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"HOHQMesh is incorporated into the Trixi.jl framework via the registered Julia package HOHQMesh.jl. This package provides a Julia wrapper for the HOHQMesh generator that allows users to easily create mesh files without the need to build HOHQMesh from source. To install the HOHQMesh package execute","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"import Pkg; Pkg.add(\"HOHQMesh\")","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Now we are ready to generate an unstructured quadrilateral mesh that can be used by Trixi.jl.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#Running-and-visualizing-an-unstructured-simulation","page":"15 Unstructured meshes with HOHQMesh.jl","title":"Running and visualizing an unstructured simulation","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Trixi.jl supports solving hyperbolic problems on several mesh types. There is a default example for this mesh type that can be executed by","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"using Trixi\nredirect_stdio(stdout=devnull, stderr=devnull) do # code that prints annoying stuff we don't want to see here #hide\ntrixi_include(default_example_unstructured())\nend #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"This will compute a smooth, manufactured solution test case for the 2D compressible Euler equations on the curved quadrilateral mesh described in the Trixi documentation.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Apart from the usual error and timing output provided by the Trixi.jl run, it is useful to visualize and inspect the solution. One option available in the Trixi.jl framework to visualize the solution on unstructured quadrilateral meshes is post-processing the Trixi.jl output file(s) with the Trixi2Vtk tool and plotting them with ParaView.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"To convert the HDF5-formatted .h5 output file(s) from Trixi into VTK format execute the following","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"using Trixi2Vtk\nredirect_stdio(stdout=devnull, stderr=devnull) do # code that prints annoying stuff we don't want to see here #hide\ntrixi2vtk(\"out/solution_000180.h5\", output_directory=\"out\")\nend #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Note this step takes about 15-30 seconds as the package Trixi2Vtk must be precompiled and executed for the first time in your REPL session. The trixi2vtk command above will convert the solution file at the final time into a .vtu file which can be read in and visualized with ParaView. Optional arguments for trixi2vtk are: (1) Pointing to the output_directory where the new files will be saved; it defaults to the current directory. (2) Specifying a higher number of visualization nodes. For instance, if we want to use 12 uniformly spaced nodes for visualization we can execute","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"redirect_stdio(stdout=devnull, stderr=devnull) do # code that prints annoying stuff we don't want to see here #hide\ntrixi2vtk(\"out/solution_000180.h5\", output_directory=\"out\", nvisnodes=12)\nend #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"By default trixi2vtk sets nvisnodes to be the same as the number of nodes specified in the elixir file used to run the simulation.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Finally, if you want to convert all the solution files to VTK execute","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"redirect_stdio(stdout=devnull, stderr=devnull) do # code that prints annoying stuff we don't want to see here #hide\ntrixi2vtk(\"out/solution_000*.h5\", output_directory=\"out\", nvisnodes=12)\nend #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"then it is possible to open the .pvd file with ParaView and create a video of the simulation.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#Creating-a-mesh-using-HOHQMesh","page":"15 Unstructured meshes with HOHQMesh.jl","title":"Creating a mesh using HOHQMesh","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The creation of an unstructured quadrilateral mesh using HOHQMesh.jl is driven by a control file. In this file the user dictates the domain to be meshed, prescribes any desired boundary curvature, the polynomial order of said boundaries, etc. In this tutorial we cover several basic features of the possible control inputs. For a complete discussion on this topic see the HOHQMesh control file documentation.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"To begin, we provide a complete control file in this tutorial. After this we give a breakdown of the control file components to explain the chosen parameters.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Suppose we want to create a mesh of a domain with straight sided outer boundaries and a curvilinear \"ice cream cone\" shaped object at its center.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: mesh_boundary_cartoon)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The associated ice_cream_straight_sides.control file is created below.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"open(\"out/ice_cream_straight_sides.control\", \"w\") do io\n  println(io, raw\"\"\"\n\\begin{CONTROL_INPUT}\n    \\begin{RUN_PARAMETERS}\n        mesh file name   = ice_cream_straight_sides.mesh\n        plot file name   = ice_cream_straight_sides.tec\n        stats file name  = none\n        mesh file format = ISM-v2\n        polynomial order = 4\n        plot file format = skeleton\n    \\end{RUN_PARAMETERS}\n\n    \\begin{BACKGROUND_GRID}\n        x0 = [-8.0, -8.0, 0.0]\n        dx = [1.0, 1.0, 0.0]\n        N  = [16,16,1]\n    \\end{BACKGROUND_GRID}\n\n    \\begin{SPRING_SMOOTHER}\n        smoothing            = ON\n        smoothing type       = LinearAndCrossBarSpring\n        number of iterations = 25\n    \\end{SPRING_SMOOTHER}\n\n\\end{CONTROL_INPUT}\n\n\\begin{MODEL}\n\n    \\begin{INNER_BOUNDARIES}\n\n        \\begin{CHAIN}\n            name = IceCreamCone\n            \\begin{END_POINTS_LINE}\n                name = LeftSlant\n                xStart = [-2.0, 1.0, 0.0]\n                xEnd   = [ 0.0, -3.0, 0.0]\n            \\end{END_POINTS_LINE}\n\n            \\begin{END_POINTS_LINE}\n                name = RightSlant\n                xStart = [ 0.0, -3.0, 0.0]\n                xEnd   = [ 2.0, 1.0, 0.0]\n            \\end{END_POINTS_LINE}\n\n            \\begin{CIRCULAR_ARC}\n                name        = IceCream\n                units       = degrees\n                center      = [ 0.0, 1.0, 0.0]\n                radius      = 2.0\n                start angle = 0.0\n                end angle   = 180.0\n            \\end{CIRCULAR_ARC}\n        \\end{CHAIN}\n\n    \\end{INNER_BOUNDARIES}\n\n\\end{MODEL}\n\\end{FILE}\n\"\"\")\nend","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The first three blocks of information are wrapped within a CONTROL_INPUT environment block as they define the core components of the quadrilateral mesh that will be generated.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The first block of information in RUN_PARAMETERS is","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"\\begin{RUN_PARAMETERS}\n   mesh file name   = ice_cream_straight_sides.mesh\n   plot file name   = ice_cream_straight_sides.tec\n   stats file name  = none\n   mesh file format = ISM-v2\n   polynomial order = 4\n   plot file format = skeleton\n\\end{RUN_PARAMETERS}","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The mesh and plot file names will be the files created by HOHQMesh once successfully executed. The stats file name is available if you wish to also save a collection of mesh statistics. For this example it is deactivated. These file names given within RUN_PARAMETERS should match that of the control file, and although this is not required by HOHQMesh, it is a useful style convention. The mesh file format ISM-v2 in the format currently required by Trixi. The polynomial order prescribes the order of an interpolant constructed on the Chebyshev-Gauss-Lobatto nodes that is used to represent any curved boundaries on a particular element. The plot file format of skeleton means that visualizing the plot file will only draw the element boundaries (and no internal nodes). Alternatively, the format can be set to sem to visualize the interior nodes of the approximation as well.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The second block of information in BACKGROUND_GRID is","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"\\begin{BACKGROUND_GRID}\n  x0 = [-8.0, -8.0, 0.0]\n  dx = [1.0, 1.0, 0.0]\n  N  = [16,16,1]\n\\end{BACKGROUND_GRID}","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"This lays a grid of Cartesian elements for the domain beginning at the point x0 as its bottom-left corner. The value of dx, which could differ in each direction if desired, controls the step size taken in each Cartesian direction. The values in N set how many Cartesian box elements are set in each coordinate direction. The above parameters define a 16times 16 element square mesh on -88^2. Further, this sets up four outer boundaries of the domain that are given the default names: Top, Left, Bottom, Right.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The third block of information in SPRING_SMOOTHER is","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"\\begin{SPRING_SMOOTHER}\n   smoothing            = ON\n   smoothing type       = LinearAndCrossBarSpring\n   number of iterations = 25\n\\end{SPRING_SMOOTHER}","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Once HOHQMesh generates the mesh, a spring-mass-dashpot model is created to smooth the mesh and create \"nicer\" quadrilateral elements. The default parameters of Hooke's law for the spring-mass-dashpot model have been selected after a fair amount of experimentation across many meshes. If you wish to deactivate this feature you can set smoothing = OFF (or remove this block from the control file).","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"After the CONTROL_INPUT environment block comes the MODEL environment block. It is here where the user prescribes curved boundary information with either:","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"An OUTER_BOUNDARY (covered in the next section of this tutorial).\nOne or more INNER_BOUNDARIES.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"There are several options to describe the boundary curve data to HOHQMesh like splines or parametric curves.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"For the example ice_cream_straight_sides.control we define three internal boundaries; two straight-sided and one as a circular arc. Within the HOHQMesh control input each curve must be assigned to a CHAIN as shown below in the complete INNER_BOUNDARIES block.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"\\begin{INNER_BOUNDARIES}\n\n   \\begin{CHAIN}\n   name = IceCreamCone\n   \\begin{END_POINTS_LINE}\n      name = LeftSlant\n      xStart = [-2.0, 1.0, 0.0]\n      xEnd   = [ 0.0, -3.0, 0.0]\n   \\end{END_POINTS_LINE}\n\n   \\begin{END_POINTS_LINE}\n      name = RightSlant\n      xStart = [ 0.0, -3.0, 0.0]\n      xEnd   = [ 2.0, 1.0, 0.0]\n   \\end{END_POINTS_LINE}\n\n   \\begin{CIRCULAR_ARC}\n      name        = IceCream\n      units       = degrees\n      center      = [ 0.0, 1.0, 0.0]\n      radius      = 2.0\n      start angle = 0.0\n      end angle   = 180.0\n   \\end{CIRCULAR_ARC}\n   \\end{CHAIN}\n\n\\end{INNER_BOUNDARIES}","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"It is important to note there are two name quantities one for the CHAIN and one for the PARAMETRIC_EQUATION_CURVE. The name for the CHAIN is used internally by HOHQMesh, so if you have multiple CHAINs they must be given a unique name. The name for the PARAMETRIC_EQUATION_CURVE will be printed to the appropriate boundaries within the .mesh file produced by HOHQMesh.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"We create the mesh file ice_cream_straight_sides.mesh and its associated file for plotting ice_cream_straight_sides.tec by using HOHQMesh.jl's function generate_mesh.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"using HOHQMesh\ncontrol_file = joinpath(\"out\", \"ice_cream_straight_sides.control\")\noutput = generate_mesh(control_file);\nnothing #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The mesh file ice_cream_straight_sides.mesh and its associated file for plotting ice_cream_straight_sides.tec are placed in the out folder. The resulting mesh generated by HOHQMesh.jl is given in the following figure.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: mesh_straight_sides)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"We note that Trixi.jl uses the boundary name information from the control file to assign boundary conditions in an elixir file. Therefore, the name should start with a letter and consist only of alphanumeric characters and underscores. Please note that the name will be treated as case sensitive.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#Example-simulation-on-ice_cream_straight_sides.mesh","page":"15 Unstructured meshes with HOHQMesh.jl","title":"Example simulation on ice_cream_straight_sides.mesh","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"With this newly generated mesh we are ready to run a Trixi.jl simulation on an unstructured quadrilateral mesh. For this we must create a new elixir file.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The elixir file given below creates an initial condition for a uniform background flow state with a free stream Mach number of 0.3. A focus for this part of the tutorial is to specify the boundary conditions and to construct the new mesh from the file that was generated in the previous exercise.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"It is straightforward to set the different boundary condition types in an elixir by assigning a particular function to a boundary name inside a Julia dictionary, Dict, variable. Observe that the names of these boundaries match those provided by HOHQMesh either by default, e.g. Bottom, or user assigned, e.g. IceCream. For this problem setup use","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Freestream boundary conditions on the four box edges.\nFree slip wall boundary condition on the interior curved boundaries.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"To construct the unstructured quadrilateral mesh from the HOHQMesh file we point to the appropriate location with the variable mesh_file and then feed this into the constructor for the UnstructuredMesh2D type in Trixi.jl","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"# create the unstructured mesh from your mesh file\nusing Trixi\nmesh_file = joinpath(\"out\", \"ice_cream_straight_sides.mesh\")\nmesh = UnstructuredMesh2D(mesh_file);","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The complete elixir file for this simulation example is given below.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"using OrdinaryDiffEq, Trixi\n\nequations = CompressibleEulerEquations2D(1.4) # set gas gamma = 1.4\n\n# freestream flow state with Ma_inf = 0.3\n@inline function uniform_flow_state(x, t, equations::CompressibleEulerEquations2D)\n\n  # set the freestream flow parameters\n  rho_freestream = 1.0\n  u_freestream = 0.3\n  p_freestream = inv(equations.gamma)\n\n  theta = 0.0 # zero angle of attack\n  si, co = sincos(theta)\n  v1 = u_freestream * co\n  v2 = u_freestream * si\n\n  prim = SVector(rho_freestream, v1, v2, p_freestream)\n  return prim2cons(prim, equations)\nend\n\n# initial condition\ninitial_condition = uniform_flow_state\n\n# boundary condition types\nboundary_condition_uniform_flow = BoundaryConditionDirichlet(uniform_flow_state)\n\n# boundary condition dictionary\nboundary_conditions = Dict( :Bottom     => boundary_condition_uniform_flow,\n                            :Top        => boundary_condition_uniform_flow,\n                            :Right      => boundary_condition_uniform_flow,\n                            :Left       => boundary_condition_uniform_flow,\n                            :LeftSlant  => boundary_condition_slip_wall,\n                            :RightSlant => boundary_condition_slip_wall,\n                            :IceCream   => boundary_condition_slip_wall );\n\n# DGSEM solver.\n#    1) polydeg must be >= the polynomial order set in the HOHQMesh control file to guarantee\n#       freestream preservation. As a extra task try setting polydeg=3\n#    2) VolumeIntegralFluxDifferencing with central volume flux is activated\n#       for dealiasing\nvolume_flux = flux_ranocha\nsolver = DGSEM(polydeg=4, surface_flux=flux_hll,\n               volume_integral=VolumeIntegralFluxDifferencing(volume_flux))\n\n# create the unstructured mesh from your mesh file\nmesh_file = joinpath(\"out\", \"ice_cream_straight_sides.mesh\")\nmesh = UnstructuredMesh2D(mesh_file)\n\n# Create semidiscretization with all spatial discretization-related components\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    boundary_conditions=boundary_conditions)\n\n# Create ODE problem from semidiscretization with time span from 0.0 to 2.0\ntspan = (0.0, 2.0)\node = semidiscretize(semi, tspan)\n\n\n# Create the callbacks to output solution files and adapt the time step\nsummary_callback = SummaryCallback()\nsave_solution = SaveSolutionCallback(interval=10,\n                                     save_initial_solution=true,\n                                     save_final_solution=true)\nstepsize_callback = StepsizeCallback(cfl=1.0)\n\ncallbacks = CallbackSet(summary_callback, save_solution, stepsize_callback)\n\nredirect_stdio(stdout=devnull, stderr=devnull) do # code that prints annoying stuff we don't want to see here #hide\n# Evolve ODE problem in time using `solve` from OrdinaryDiffEq\nsol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1.0, # solve needs some value here but it will be overwritten by the stepsize_callback\n            save_everystep=false, callback=callbacks);\n# print the timer summary\nsummary_callback()\nend #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Visualization of the solution is carried out in a similar way as above. That is, one converts the .h5 output files with trixi2vtk and then plot the solution in ParaView. An example plot of the pressure at the final time is shown below.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: simulation_straight_sides)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#Making-a-mesh-with-a-curved-outer-boundary","page":"15 Unstructured meshes with HOHQMesh.jl","title":"Making a mesh with a curved outer boundary","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Let us modify the mesh from the previous task and place a circular outer boundary instead of straight-sided outer boundaries. Note, the \"ice cream cone\" shape is still placed at the center of the domain.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"We create the new control file ice_cream_curved_sides.control file below and will then highlight the major differences compared to ice_cream_straight_sides.control.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"open(\"out/ice_cream_curved_sides.control\", \"w\") do io\n  println(io, raw\"\"\"\n\\begin{CONTROL_INPUT}\n    \\begin{RUN_PARAMETERS}\n        mesh file name   = ice_cream_curved_sides.mesh\n        plot file name   = ice_cream_curved_sides.tec\n        stats file name  = none\n        mesh file format = ISM-v2\n        polynomial order = 4\n        plot file format = skeleton\n    \\end{RUN_PARAMETERS}\n\n    \\begin{BACKGROUND_GRID}\n        background grid size = [1.0, 1.0, 0.0]\n    \\end{BACKGROUND_GRID}\n\n    \\begin{SPRING_SMOOTHER}\n        smoothing            = ON\n        smoothing type       = LinearAndCrossBarSpring\n        number of iterations = 25\n    \\end{SPRING_SMOOTHER}\n\n\\end{CONTROL_INPUT}\n\n\\begin{MODEL}\n\n    \\begin{OUTER_BOUNDARY}\n        \\begin{PARAMETRIC_EQUATION_CURVE}\n            name = OuterCircle\n            xEqn = x(t) = 8.0*sin(2.0*pi*t)\n            yEqn = y(t) = 8.0*cos(2.0*pi*t)\n            zEqn = z(t) = 0.0\n        \\end{PARAMETRIC_EQUATION_CURVE}\n\n    \\end{OUTER_BOUNDARY}\n\n    \\begin{INNER_BOUNDARIES}\n\n        \\begin{CHAIN}\n            name = IceCreamCone\n            \\begin{END_POINTS_LINE}\n                name = LeftSlant\n                xStart = [-2.0, 1.0, 0.0]\n                xEnd   = [ 0.0, -3.0, 0.0]\n            \\end{END_POINTS_LINE}\n\n            \\begin{END_POINTS_LINE}\n                name = RightSlant\n                xStart = [ 0.0, -3.0, 0.0]\n                xEnd   = [ 2.0, 1.0, 0.0]\n            \\end{END_POINTS_LINE}\n\n            \\begin{CIRCULAR_ARC}\n                name        = IceCream\n                units       = degrees\n                center      = [ 0.0, 1.0, 0.0]\n                radius      = 2.0\n                start angle = 0.0\n                end angle   = 180.0\n            \\end{CIRCULAR_ARC}\n        \\end{CHAIN}\n\n    \\end{INNER_BOUNDARIES}\n\n\\end{MODEL}\n\\end{FILE}\n\"\"\")\nend","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The first alteration is that we have altered the second block of information BACKGROUND_GRID within the CONTROL_INPUT to be","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"\\begin{BACKGROUND_GRID}\n   background grid size = [1.0, 1.0, 0.0]\n\\end{BACKGROUND_GRID}","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"This mesh control file has an outer boundary that determines the extent of the domain to be meshed. Therefore, we only need to supply the background grid size to the BACKGROUND_GRID control input.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The second alteration is that the MODEL now contains information for an OUTER_BOUNDARY. In this case it is a circle of radius 8 centered at [0.0, 0.0, 0.0] written as a set of PARAMETRIC_EQUATION_CURVEs.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"   \\begin{OUTER_BOUNDARY}\n\n      \\begin{PARAMETRIC_EQUATION_CURVE}\n         name = OuterCircle\n         xEqn = x(t) = 8.0*sin(2.0*pi*t)\n         yEqn = y(t) = 8.0*cos(2.0*pi*t)\n         zEqn = z(t) = 0.0\n      \\end{PARAMETRIC_EQUATION_CURVE}\n\n   \\end{OUTER_BOUNDARY}","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Just as with the inner boundary curves, we must assign a name to the OUTER_BOUNDARY. It will be included in the generated .mesh file and is used within the Trixi.jl elixir file to set boundary conditions.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Again, we create the .mesh and .tec files with HOHQMesh.jl's function generate_mesh","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"control_file = joinpath(\"out\", \"ice_cream_curved_sides.control\")\noutput = generate_mesh(control_file);\nnothing #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The files are placed in the out folder.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The resulting mesh generated by HOHQMesh.jl is given in the following figure.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: mesh_curved_sides)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#Running-Trixi.jl-on-ice_cream_curved_sides.mesh","page":"15 Unstructured meshes with HOHQMesh.jl","title":"Running Trixi.jl on ice_cream_curved_sides.mesh","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"We can reuse much of the elixir file to setup the uniform flow over an ice cream cone from the previous part of this tutorial. The only component of the elixir file that must be changed is the boundary condition dictionary because we now have a boundary named OuterCirle instead of four edges of a bounding box.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"# boundary condition dictionary\nboundary_conditions = Dict( :OuterCircle => boundary_condition_uniform_flow,\n                            :LeftSlant   => boundary_condition_slip_wall,\n                            :RightSlant  => boundary_condition_slip_wall,\n                            :IceCream    => boundary_condition_slip_wall );\nnothing #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Also, we must update the construction of the mesh from our new mesh file ice_cream_curved_sides.mesh that is located in the out folder.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"# create the unstructured mesh from your mesh file\nmesh_file = joinpath(\"out\", \"ice_cream_curved_sides.mesh\")\nmesh = UnstructuredMesh2D(mesh_file);\nnothing #hide","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"We can then post-process the solution file at the final time on the new mesh with Trixi2Vtk and visualize with ParaView.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: simulation_curved_sides)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html#Setting-up-a-simulation-with-AMR-via-P4estMesh","page":"15 Unstructured meshes with HOHQMesh.jl","title":"Setting up a simulation with AMR via P4estMesh","text":"","category":"section"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"The above explained mesh file format of ISM-V2 only works with UnstructuredMesh2D and so does not support AMR. On the other hand, the mesh type P4estMesh allows AMR. The mesh constructor for the P4estMesh imports an unstructured, conforming mesh from an Abaqus mesh file (.inp).","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"As described above, the first block of the HOHQMesh control file contains the parameter mesh file format. If you set mesh file format = ABAQUS instead of ISM-V2, HOHQMesh.jl's function generate_mesh creates an Abaqus mesh file .inp.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"using HOHQMesh\ncontrol_file = joinpath(\"out\", \"ice_cream_straight_sides.control\")\noutput = generate_mesh(control_file);","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Now, you can create a P4estMesh from your mesh file. It is described in detail in the P4est-based mesh part of the Trixi docs.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"using Trixi\nmesh_file = joinpath(\"out\", \"ice_cream_straight_sides.inp\")\nmesh = P4estMesh{2}(mesh_file)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"Since P4estMesh supports AMR, we just have to extend the setup from the first example by the standard AMR procedure. For more information about AMR in Trixi, see the matching tutorial.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"amr_indicator = IndicatorLöhner(semi, variable=density)\n\namr_controller = ControllerThreeLevel(semi, amr_indicator,\n                                      base_level=0,\n                                      med_level =1, med_threshold=0.05,\n                                      max_level =3, max_threshold=0.1)\n\namr_callback = AMRCallback(semi, amr_controller,\n                           interval=5,\n                           adapt_initial_condition=true,\n                           adapt_initial_condition_only_refine=true)\n\ncallbacks = CallbackSet(..., amr_callback)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"We can then post-process the solution file at the final time on the new mesh with Trixi2Vtk and visualize with ParaView, see the appropriate visualization section for details.","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"(Image: simulation_straight_sides_p4est_amr)","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"","category":"page"},{"location":"tutorials/hohqmesh_tutorial.html","page":"15 Unstructured meshes with HOHQMesh.jl","title":"15 Unstructured meshes with HOHQMesh.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"parallelization.html#Parallelization","page":"Parallelization","title":"Parallelization","text":"","category":"section"},{"location":"parallelization.html#Shared-memory-parallelization-with-threads","page":"Parallelization","title":"Shared-memory parallelization with threads","text":"","category":"section"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"Many compute-intensive loops in Trixi.jl are parallelized using the multi-threading support provided by Julia. You can recognize those loops by the @threaded macro prefixed to them, e.g.,","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"@threaded for element in eachelement(dg, cache)\r\n  ...\r\nend","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"This will statically assign an equal iteration count to each available thread.","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"To use multi-threading, you need to tell Julia at startup how many threads you want to use by either setting the environment variable JULIA_NUM_THREADS or by providing the -t/--threads command line argument. For example, to start Julia with four threads, start Julia with","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"julia --threads=4","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"If both the environment variable and the command line argument are specified at the same time, the latter takes precedence.","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"If you use time integration methods from  OrdinaryDiffEq.jl and want to use multiple threads therein, you need to set the keyword argument thread=OrdinaryDiffEq.True() of the algorithms, as described in the section on time integration methods.","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"warning: Warning\nNot everything is parallelized yet and there are likely opportunities to improve scalability. Multi-threading isn't considered part of the public API of Trixi yet.","category":"page"},{"location":"parallelization.html#Distributed-computing-with-MPI","page":"Parallelization","title":"Distributed computing with MPI","text":"","category":"section"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"In addition to the shared memory parallelization with multi-threading, Trixi.jl supports distributed parallelism via MPI.jl, which leverages the Message Passing Interface (MPI). MPI.jl comes with its own MPI library binaries such that there is no need to install MPI yourself. However, it is also possible to instead use an existing MPI installation, which is recommended if you are running MPI programs on a cluster or supercomputer (see the MPI.jl docs to find out how to select the employed MPI library). Additional notes on how to use a system-provided MPI installation with Trixi.jl can be found in the following subsection.","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"warning: Work in progress\nMPI-based parallelization is work in progress and not finished yet. Nothing related to MPI is part of the official API of Trixi yet.","category":"page"},{"location":"parallelization.html#parallel_system_MPI","page":"Parallelization","title":"Using a system-provided MPI installation","text":"","category":"section"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"When using Trixi.jl with a system-provided MPI backend the underlying p4est library needs to be compiled with the same MPI installation. Therefore, you also need to use a system-provided p4est installation (for notes on how to install p4est see e.g. here, use the configure option --enable-mpi). In addition, P4est.jl needs to be configured to use the custom p4est installation. Follow the steps described here for the configuration. In total, in your active Julia project you should have a LocalPreferences.toml file with sections [MPIPreferences] and [P4est] as well as an entry MPIPreferences in your Project.toml to use a custom MPI installation.","category":"page"},{"location":"parallelization.html#parallel_usage","page":"Parallelization","title":"Usage","text":"","category":"section"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"To start Trixi in parallel with MPI, there are three options:","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"Run from the REPL with mpiexec(): You can start a parallel execution directly from the REPL by executing ```julia julia> using MPI","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"julia> mpiexec() do cmd             run($cmd -n 3 $(Base.julia_cmd()) --threads=1 --project=@. -e 'using Trixi; trixi_include(default_example())')           end    ``The parameter-n 3specifies that Trixi should run with three processes (or    *ranks* in MPI parlance) and should be adapted to your available    computing resources and problem size. TheBase.julia_cmd()argument    ensures that Julia is executed in parallel with the same optimization level    etc. as you used for the REPL; if this is unnecessary or undesired, you can    also just usejulia.  Further, if you are not running Trixi from a local    clone but have installed it as a package, you need to omit the–project=@.`.","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"Run from the command line with mpiexecjl: Alternatively, you can use the mpiexecjl script provided by MPI.jl, which allows you to start Trixi in parallel directly from the command line. As a preparation, you need to install the script once by running ```julia julia> using MPI","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"julia> MPI.installmpiexecjl(destdir=\"/somewhere/in/your/PATH\")    Then, to execute Trixi in parallel, execute the following command from your    command line:bash    mpiexecjl -n 3 julia –threads=1 –project=@. -e 'using Trixi; trixiinclude(default_example())'    ```","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"Run interactively with tmpi (Linux/MacOS only): If you are on a Linux/macOS system, you have a third option which lets you run Julia in parallel interactively from the REPL. This comes in handy especially during development, as in contrast to the first two options, it allows to reuse the compilation cache and thus facilitates much faster startup times after the first execution. It requires tmux and the OpenMPI library to be installed before, both of which are usually available through a package manager. Once you have installed both tools, you need to configure MPI.jl to use the OpenMPI for your system, which is explained here. Then, you can download and install the tmpi script by executing\ncurl https://raw.githubusercontent.com/Azrael3000/tmpi/master/tmpi -o /somewhere/in/your/PATH/tmpi\nFinally, you can start and control multiple Julia REPLs simultaneously by running\ntmpi 3 julia --threads=1 --project=@.\nThis will start Julia inside tmux three times and multiplexes all commands you enter in one REPL to all other REPLs (try for yourself to understand what it means). If you have no prior experience with tmux, handling the REPL this way feels slightly weird in the beginning. However, there is a lot of documentation for tmux available and once you get the hang of it, developing Trixi in parallel becomes much smoother this way. Some helpful commands are the following. To close a single pane you can press Ctrl+b and then x followed by y to confirm. To quit the whole session you press Ctrl+b followed by :kill-session. Often you would like to scroll up. You can do that by pressing Ctrl+b and then [, which allows you to use the arrow keys to scroll up and down. To leave the scroll mode you press q. Switching between panes can be done by Ctrl+b followed by o. As of March 2022, newer versions of tmpi also support mpich, which is the default backend of MPI.jl (via MPICH_Jll.jl). To use this setup, you need to install mpiexecjl as described in the  documentation of MPI.jl and make it available as mpirun, e.g., via a symlink of the form\nln -s ~/.julia/bin/mpiexecjl /somewhere/in/your/path/mpirun\n(assuming default installations).","category":"page"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"note: Hybrid parallelism\nIt is possible to combine MPI with shared memory parallelism via threads by starting Julia with more than one thread, e.g. by passing the command line argument julia --threads=2 instead of julia --threads=1 used in the examples above. In that case, you should make sure that your system supports the number of processes/threads that you try to start.","category":"page"},{"location":"parallelization.html#parallel_performance","page":"Parallelization","title":"Performance","text":"","category":"section"},{"location":"parallelization.html","page":"Parallelization","title":"Parallelization","text":"For information on how to evaluate the parallel performance of Trixi, please have a look at the  section, specifically at the descriptions of the performance index (PID).","category":"page"},{"location":"license.html#License","page":"License","title":"License","text":"","category":"section"},{"location":"license.html","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2020-present The Trixi Authors (see Authors)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"EditURL = \"<unknown>/docs/literate/src/files/differentiable_programming.jl\"","category":"page"},{"location":"tutorials/differentiable_programming.html#differentiable_programming","page":"17 Differentiable programming","title":"17: Differentiable programming","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Julia and its ecosystem provide some tools for differentiable programming. Trixi.jl is designed to be flexible, extendable, and composable with Julia's growing ecosystem for scientific computing and machine learning. Thus, the ultimate goal is to have fast implementations that allow automatic differentiation (AD) without too much hassle for users. If some parts do not meet these requirements, please feel free to open an issue or propose a fix in a PR.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"In the following, we will walk through some examples demonstrating how to differentiate through Trixi.jl.","category":"page"},{"location":"tutorials/differentiable_programming.html#Forward-mode-automatic-differentiation","page":"17 Differentiable programming","title":"Forward mode automatic differentiation","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Trixi integrates well with ForwardDiff.jl for forward mode AD.","category":"page"},{"location":"tutorials/differentiable_programming.html#Computing-the-Jacobian","page":"17 Differentiable programming","title":"Computing the Jacobian","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"The high-level interface to compute the Jacobian this way is jacobian_ad_forward. First, we load the required packages and compute the Jacobian of a semidiscretization of the compressible Euler equations, a system of nonlinear conservation laws.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"using Trixi, LinearAlgebra, Plots\n\nequations = CompressibleEulerEquations2D(1.4)\n\nsolver = DGSEM(3, flux_central)\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver)\n\nJ = jacobian_ad_forward(semi);\nsize(J)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Next, we compute the eigenvalues of the Jacobian.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"λ = eigvals(J)\nscatter(real.(λ), imag.(λ), label=\"central flux\")","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"As you can see here, the maximal real part is close to zero.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"relative_maximum = maximum(real, λ) / maximum(abs, λ)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Interestingly, if we add dissipation by switching to the flux_lax_friedrichs at the interfaces, the maximal real part of the eigenvalues increases.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"solver = DGSEM(3, flux_lax_friedrichs)\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver)\n\nJ = jacobian_ad_forward(semi)\nλ = eigvals(J)\n\nscatter!(real.(λ), imag.(λ), label=\"Lax-Friedrichs flux\")","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Although the maximal real part is still somewhat small, it's larger than for the purely central discretization.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"relative_maximum = maximum(real, λ) / maximum(abs, λ)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"However, we should be careful when using this analysis, since the eigenvectors are not necessarily well-conditioned.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"λ, V = eigen(J)\ncondition_number = cond(V)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"In one space dimension, the situation is a bit different.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"equations = CompressibleEulerEquations1D(1.4)\n\nsolver = DGSEM(3, flux_central)\nmesh = TreeMesh((-1.0,), (1.0,), initial_refinement_level=6, n_cells_max=10^5)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver)\n\nJ = jacobian_ad_forward(semi)\n\nλ = eigvals(J)\n\nscatter(real.(λ), imag.(λ), label=\"central flux\")","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Here, the maximal real part is basically zero to machine accuracy.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"relative_maximum = maximum(real, λ) / maximum(abs, λ)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Moreover, the eigenvectors are not as ill-conditioned as in 2D.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"λ, V = eigen(J)\ncondition_number = cond(V)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"If we add dissipation, the maximal real part is still approximately zero.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"solver = DGSEM(3, flux_lax_friedrichs)\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver)\n\nJ = jacobian_ad_forward(semi)\nλ = eigvals(J)\n\nscatter!(real.(λ), imag.(λ), label=\"Lax-Friedrichs flux\")","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"As you can see from the plot generated above, the maximal real part is still basically zero to machine precision.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"relative_maximum = maximum(real, λ) / maximum(abs, λ)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Let's check the condition number of the eigenvectors.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"λ, V = eigen(J)\n\ncondition_number = cond(V)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Note that the condition number of the eigenvector matrix increases but is still smaller than for the example in 2D.","category":"page"},{"location":"tutorials/differentiable_programming.html#Computing-other-derivatives","page":"17 Differentiable programming","title":"Computing other derivatives","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"It is also possible to compute derivatives of other dependencies using AD in Trixi. For example, you can compute the gradient of an entropy-dissipative semidiscretization with respect to the ideal gas constant of the compressible Euler equations as described in the following. This example is also available as the elixir examples/special_elixirs/elixir_euler_ad.jl","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"First, we create a semidiscretization of the compressible Euler equations.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"using Trixi, LinearAlgebra, ForwardDiff\n\nequations = CompressibleEulerEquations2D(1.4)\n\n\"\"\"\n    initial_condition_isentropic_vortex(x, t, equations::CompressibleEulerEquations2D)\n\nThe classical isentropic vortex test case of\n- Chi-Wang Shu (1997)\n  Essentially Non-Oscillatory and Weighted Essentially Non-Oscillatory\n  Schemes for Hyperbolic Conservation Laws\n  [NASA/CR-97-206253](https://ntrs.nasa.gov/citations/19980007543)\n\"\"\"\nfunction initial_condition_isentropic_vortex(x, t, equations::CompressibleEulerEquations2D)\n  inicenter = SVector(0.0, 0.0) # initial center of the vortex\n  iniamplitude = 5.0            # size and strength of the vortex\n\n  rho = 1.0  # base flow\n  v1 = 1.0\n  v2 = 1.0\n  vel = SVector(v1, v2)\n  p = 25.0\n\n  rt = p / rho                      # ideal gas equation\n  t_loc = 0.0\n\n  cent = inicenter + vel*t_loc      # shift advection of center to handle periodic BC, but only for v1 = v2 = 1.0\n  cent = x - cent                   # distance to center point\n  cent = SVector(-cent[2], cent[1])\n\n  r2 = cent[1]^2 + cent[2]^2\n  du = iniamplitude / (2*π) * exp(0.5 * (1 - r2)) # vel. perturbation\n  dtemp = -(equations.gamma - 1) / (2 * equations.gamma * rt) * du^2 # isentropic\n\n  rho = rho * (1 + dtemp)^(1 / (equations.gamma - 1))\n  vel = vel + du * cent\n  v1, v2 = vel\n  p = p * (1 + dtemp)^(equations.gamma / (equations.gamma - 1))\n\n  prim = SVector(rho, v1, v2, p)\n  return prim2cons(prim, equations)\nend\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5)\n\nsolver = DGSEM(3, flux_lax_friedrichs, VolumeIntegralFluxDifferencing(flux_ranocha))\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_isentropic_vortex, solver)\n\nu0_ode = Trixi.compute_coefficients(0.0, semi)\nsize(u0_ode)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Next, we compute the Jacobian using ForwardDiff.jacobian.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"J = ForwardDiff.jacobian((du_ode, γ) -> begin\n    equations_inner = CompressibleEulerEquations2D(first(γ))\n    semi_inner = Trixi.remake(semi, equations=equations_inner, uEltype=eltype(γ))\n    Trixi.rhs!(du_ode, u0_ode, semi_inner, 0.0)\nend, similar(u0_ode), [1.4]); # γ needs to be an `AbstractArray`\n\nround.(extrema(J), sigdigits=2)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Note that we create a semidiscretization semi at first to determine the state u0_ode around which we want to perform the linearization. Next, we wrap the RHS evaluation inside a closure and pass that to ForwardDiff.jacobian. There, we need to make sure that the internal caches are able to store dual numbers from ForwardDiff.jl by setting uEltype appropriately. A similar approach is used by jacobian_ad_forward.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Note that the ideal gas constant does not influence the semidiscrete rate of change of the density, as demonstrated by","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"norm(J[1:4:end])","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Here, we used some knowledge about the internal memory layout of Trixi, an array of structs with the conserved variables as fastest-varying index in memory.","category":"page"},{"location":"tutorials/differentiable_programming.html#Differentiating-through-a-complete-simulation","page":"17 Differentiable programming","title":"Differentiating through a complete simulation","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"It is also possible to differentiate through a complete simulation. As an example, let's differentiate the total energy of a simulation using the linear scalar advection equation with respect to the wave number (frequency) of the initial data.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"using Trixi, OrdinaryDiffEq, ForwardDiff, Plots\n\nfunction energy_at_final_time(k) # k is the wave number of the initial condition\n    equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n    mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\n    solver = DGSEM(3, flux_lax_friedrichs)\n    initial_condition = (x, t, equation) -> begin\n            x_trans = Trixi.x_trans_periodic_2d(x - equation.advection_velocity * t)\n            return SVector(sinpi(k * sum(x_trans)))\n    end\n    semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                               uEltype=typeof(k))\n    ode = semidiscretize(semi, (0.0, 1.0))\n    sol = solve(ode, BS3(), save_everystep=false)\n    Trixi.integrate(energy_total, sol.u[end], semi)\nend\n\nk_values = range(0.9, 1.1, length=101)\n\nplot(k_values, energy_at_final_time.(k_values), label=\"Energy\")","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"You see a plot of a curve that resembles a parabola with local maximum around k = 1.0. Why's that? Well, the domain is fixed but the wave number changes. Thus, if the wave number is not chosen as an integer, the initial condition will not be a smooth periodic function in the given domain. Hence, the dissipative surface flux (flux_lax_friedrichs in this example) will introduce more dissipation. In particular, it will introduce more dissipation for \"less smooth\" initial data, corresponding to wave numbers k further away from integers.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"We can compute the discrete derivative of the energy at the final time with respect to the wave number k as follows.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"round(ForwardDiff.derivative(energy_at_final_time, 1.0), sigdigits=2)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"This is rather small and we can treat it as zero in comparison to the value of this derivative at other wave numbers k.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"dk_values = ForwardDiff.derivative.((energy_at_final_time,), k_values);\n\nplot(k_values, dk_values, label=\"Derivative\")","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"If you remember basic calculus, a sufficient condition for a local maximum is that the first derivative vanishes and the second derivative is negative. We can also check this discretely.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"second_derivative = round(ForwardDiff.derivative(\n        k -> Trixi.ForwardDiff.derivative(energy_at_final_time, k), 1.0),\n      sigdigits=2)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Having seen this application, let's break down what happens step by step.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"function energy_at_final_time(k) # k is the wave number of the initial condition\n    equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n    mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\n    solver = DGSEM(3, flux_lax_friedrichs)\n    initial_condition = (x, t, equation) -> begin\n        x_trans = Trixi.x_trans_periodic_2d(x - equation.advection_velocity * t)\n        return SVector(sinpi(k * sum(x_trans)))\n    end\n    semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                               uEltype=typeof(k))\n    ode = semidiscretize(semi, (0.0, 1.0))\n    sol = solve(ode, BS3(), save_everystep=false)\n    Trixi.integrate(energy_total, sol.u[end], semi)\nend\n\nk = 1.0\nround(ForwardDiff.derivative(energy_at_final_time, k), sigdigits=2)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"When calling ForwardDiff.derivative(energy_at_final_time, k) with k=1.0, ForwardDiff.jl will basically use the chain rule and known derivatives of existing basic functions to calculate the derivative of the energy at the final time with respect to the wave number k at k0 = 1.0. To do this, ForwardDiff.jl uses dual numbers, which basically store the result and its derivative w.r.t. a specified parameter at the same time. Thus, we need to make sure that we can treat these ForwardDiff.Dual numbers everywhere during the computation. Fortunately, generic Julia code usually supports these operations. The most basic problem for a developer is to ensure that all types are generic enough, in particular the ones of internal caches.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"The first step in this example creates some basic ingredients of our simulation.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\nsolver = DGSEM(3, flux_lax_friedrichs);\nnothing #hide","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"These do not have internal caches storing intermediate values of the numerical solution, so we do not need to adapt them. In fact, we could also define them outside of energy_at_final_time (but would need to take care of globals or wrap everything in another function).","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Next, we define the initial condition","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"initial_condition = (x, t, equation) -> begin\n    x_trans = Trixi.x_trans_periodic_2d(x - equation.advection_velocity * t)\n    return SVector(sinpi(k * sum(x_trans)))\nend;\nnothing #hide","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"as a closure capturing the wave number k passed to energy_at_final_time. If you call energy_at_final_time(1.0), k will be a Float64. Thus, the return values of initial_condition will be SVectors of Float64s. When calculating the ForwardDiff.derivative, k will be a ForwardDiff.Dual number. Hence, the initial_condition will return SVectors of ForwardDiff.Dual numbers.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"The semidiscretization semi uses some internal caches to avoid repeated allocations and speed up the computations, e.g. for numerical fluxes at interfaces. Thus, we need to tell Trixi to allow ForwardDiff.Dual numbers in these caches. That's what the keyword argument uEltype=typeof(k) in","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    uEltype=typeof(k));\nnothing #hide","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"does. This is basically the only part where you need to modify your standard Trixi code to enable automatic differentiation. From there on, the remaining steps","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"ode = semidiscretize(semi, (0.0, 1.0))\nsol = solve(ode, BS3(), save_everystep=false)\nround(Trixi.integrate(energy_total, sol.u[end], semi), sigdigits=5)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"do not need any modifications since they are sufficiently generic (and enough effort has been spend to allow general types inside these calls).","category":"page"},{"location":"tutorials/differentiable_programming.html#Propagating-errors-using-Measurements.jl","page":"17 Differentiable programming","title":"Propagating errors using Measurements.jl","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"(Image: Error bars by Randall Munroe) \"Error bars\" by Randall Munroe, linked from https://xkcd.com/2110","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Similar to AD, Trixi also allows propagating uncertainties using linear error propagation theory via Measurements.jl. As an example, let's create a system representing the linear advection equation in 1D with an uncertain velocity. Then, we create a semidiscretization using a sine wave as initial condition, solve the ODE, and plot the resulting uncertainties in the primitive variables.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"using Trixi, OrdinaryDiffEq, Measurements, Plots, LaTeXStrings\n\nequations = LinearScalarAdvectionEquation1D(1.0 ± 0.1)\n\nmesh = TreeMesh((-1.0,), (1.0,), n_cells_max=10^5, initial_refinement_level=5)\n\nsolver = DGSEM(3)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test,\n                                    solver, uEltype=Measurement{Float64})\n\node = semidiscretize(semi, (0.0, 1.5))\n\nsol = solve(ode, BS3(), save_everystep=false);\n\nplot(sol)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"You should see a plot where small error bars are shown around the extrema and larger error bars are shown in the remaining parts. This result is in accordance with expectations. Indeed, the uncertain propagation speed will affect the extrema less since the local variation of the solution is relatively small there. In contrast, the local variation of the solution is large around the turning points of the sine wave, so the uncertainties will be relatively large there.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"All this is possible due to allowing generic types and having good abstractions in Julia that allow packages to work together seamlessly.","category":"page"},{"location":"tutorials/differentiable_programming.html#Finite-difference-approximations","page":"17 Differentiable programming","title":"Finite difference approximations","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Trixi provides the convenience function jacobian_fd to approximate the Jacobian via central finite differences.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"using Trixi, LinearAlgebra\n\nequations = CompressibleEulerEquations2D(1.4)\n\nsolver = DGSEM(3, flux_central)\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver)\n\nJ_fd = jacobian_fd(semi)\n\nJ_ad = jacobian_ad_forward(semi)\n\nrelative_difference = norm(J_fd - J_ad) / size(J_fd, 1)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"This discrepancy is of the expected order of magnitude for central finite difference approximations.","category":"page"},{"location":"tutorials/differentiable_programming.html#Linear-systems","page":"17 Differentiable programming","title":"Linear systems","text":"","category":"section"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"When a linear PDE is discretized using a linear scheme such as a standard DG method, the resulting semidiscretization yields an affine ODE of the form","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"partial_t u(t) = A u(t) + b","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"where A is a linear operator (\"matrix\") and b is a vector. Trixi allows you to obtain this linear structure in a matrix-free way by using linear_structure. The resulting operator A can be used in multiplication, e.g. mul! from LinearAlgebra, converted to a sparse matrix using sparse from SparseArrays, or converted to a dense matrix using Matrix for detailed eigenvalue analyses. For example,","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"using Trixi, LinearAlgebra, Plots\n\nequations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n\nsolver = DGSEM(3, flux_lax_friedrichs)\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5)\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test, solver)\n\nA, b = linear_structure(semi)\n\nsize(A), size(b)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"Next, we compute the eigenvalues of the linear operator.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"λ = eigvals(Matrix(A))\n\nscatter(real.(λ), imag.(λ))","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"As you can see here, the maximal real part is close to machine precision.","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"λ = eigvals(Matrix(A))\nrelative_maximum = maximum(real, λ) / maximum(abs, λ)","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"","category":"page"},{"location":"tutorials/differentiable_programming.html","page":"17 Differentiable programming","title":"17 Differentiable programming","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference-trixi.html#Trixi.jl-API","page":"Trixi.jl","title":"Trixi.jl API","text":"","category":"section"},{"location":"reference-trixi.html","page":"Trixi.jl","title":"Trixi.jl","text":"CurrentModule = Trixi","category":"page"},{"location":"reference-trixi.html","page":"Trixi.jl","title":"Trixi.jl","text":"Modules = [Trixi]","category":"page"},{"location":"reference-trixi.html#Trixi.Trixi","page":"Trixi.jl","title":"Trixi.Trixi","text":"Trixi\n\nTrixi.jl is a numerical simulation framework for hyperbolic conservation laws. A key objective for the framework is to be useful to both scientists and students. Therefore, next to having an extensible design with a fast implementation, Trixi is focused on being easy to use for new or inexperienced users, including the installation and postprocessing procedures.\n\nTo get started, run your first simulation with Trixi using\n\ntrixi_include(default_example())\n\nSee also: trixi-framework/Trixi.jl\n\n\n\n\n\n","category":"module"},{"location":"reference-trixi.html#Trixi.boundary_condition_do_nothing","page":"Trixi.jl","title":"Trixi.boundary_condition_do_nothing","text":"boundary_condition_do_nothing = Trixi.BoundaryConditionDoNothing()\n\nImposing no boundary condition just evaluates the flux at the inner state.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi.html#Trixi.boundary_condition_periodic","page":"Trixi.jl","title":"Trixi.boundary_condition_periodic","text":"boundary_condition_periodic = Trixi.BoundaryConditionPeriodic()\n\nA singleton struct indicating periodic boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi.html#Trixi.flux_hll","page":"Trixi.jl","title":"Trixi.flux_hll","text":"flux_hll\n\nSee FluxHLL.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi.html#Trixi.flux_lax_friedrichs","page":"Trixi.jl","title":"Trixi.flux_lax_friedrichs","text":"flux_lax_friedrichs\n\nSee FluxLaxFriedrichs.\n\n\n\n\n\n","category":"constant"},{"location":"reference-trixi.html#Trixi.AMRCallback","page":"Trixi.jl","title":"Trixi.AMRCallback","text":"AMRCallback(semi, controller [,adaptor=AdaptorAMR(semi)];\n            interval,\n            adapt_initial_condition=true,\n            adapt_initial_condition_only_refine=true,\n            dynamic_load_balancing=true)\n\nPerforms adaptive mesh refinement (AMR) every interval time steps for a given semidiscretization semi using the chosen controller.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.AbstractEquations","page":"Trixi.jl","title":"Trixi.AbstractEquations","text":"AbstractEquations{NDIMS, NVARS}\n\nAn abstract supertype of specific equations such as the compressible Euler equations. The type parameters encode the number of spatial dimensions (NDIMS) and the number of primary variables (NVARS) of the physics model.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.AbstractMesh","page":"Trixi.jl","title":"Trixi.AbstractMesh","text":"AbstractMesh{NDIMS}\n\nAn abstract supertype of specific mesh types such as TreeMesh or StructuredMesh. The type parameters encode the number of spatial dimensions (NDIMS).\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.AcousticPerturbationEquations2D","page":"Trixi.jl","title":"Trixi.AcousticPerturbationEquations2D","text":"AcousticPerturbationEquations2D(v_mean_global, c_mean_global, rho_mean_global)\n\nAcoustic perturbation equations (APE) in two space dimensions. The equations are given by\n\nbeginaligned\n  fracpartialmathbfvpartial t + nabla (barmathbfvcdotmathbfv)\n    + nablaleft( fracbarc^2 tildepbarrho right) = 0 \r\n  fracpartial tildeppartial t +\n    nablacdot (barrho mathbfv + barmathbfv tildep) = 0\nendaligned\n\nThe bar bar(cdot) indicates time-averaged quantities. The unknowns of the APE are the perturbed velocities mathbfv = (v_1 v_2)^T and the scaled perturbed pressure tildep = fracpbarc^2, where p denotes the perturbed pressure and the perturbed variables are defined by phi = phi - barphi.\n\nIn addition to the unknowns, Trixi currently stores the mean values in the state vector, i.e. the state vector used internally is given by\n\nmathbfu =\n  beginpmatrix\n    v_1  v_2  tildep  barv_1  barv_2  barc  barrho\n  endpmatrix\n\nThis affects the implementation and use of these equations in various ways:\n\nThe flux values corresponding to the mean values must be zero.\nThe mean values have to be considered when defining initial conditions, boundary conditions or source terms.\nAnalysisCallback analyzes these variables too.\nTrixi's visualization tools will visualize the mean values by default.\n\nThe constructor accepts a 2-tuple v_mean_global and scalars c_mean_global and rho_mean_global which can be used to make the definition of initial conditions for problems with constant mean flow more flexible. These values are ignored if the mean values are defined internally in an initial condition.\n\nThe equations are based on the APE-4 system introduced in the following paper:\n\nRoland Ewert and Wolfgang Schröder (2003) Acoustic perturbation equations based on flow decomposition via source filtering DOI: 10.1016/S0021-9991(03)00168-2\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.Adiabatic","page":"Trixi.jl","title":"Trixi.Adiabatic","text":"struct Adiabatic\n\nUsed to create a no-slip boundary condition with BoundaryConditionNavierStokesWall. The field boundary_value_normal_flux_function should be a function with signature boundary_value_normal_flux_function(x, t, equations) and return a scalar value for the normal heat flux at point x and time t.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.AliveCallback","page":"Trixi.jl","title":"Trixi.AliveCallback","text":"AliveCallback(analysis_interval=0, alive_interval=analysis_interval÷10)\n\nInexpensive callback showing that a simulation is still running by printing some information such as the current time to the screen every alive_interval time steps. If analysis_interval ≂̸ 0, the output is omitted every analysis_interval time steps.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.AnalysisCallback","page":"Trixi.jl","title":"Trixi.AnalysisCallback","text":"AnalysisCallback(semi; interval=0,\n                       save_analysis=false,\n                       output_directory=\"out\",\n                       analysis_filename=\"analysis.dat\",\n                       extra_analysis_errors=Symbol[],\n                       extra_analysis_integrals=())\n\nAnalyze a numerical solution every interval time steps and print the results to the screen. If save_analysis, the results are also saved in joinpath(output_directory, analysis_filename).\n\nAdditional errors can be computed, e.g. by passing extra_analysis_errors = [:primitive].\n\nFurther scalar functions func in extra_analysis_integrals are applied to the numerical solution and integrated over the computational domain. See Trixi.analyze, Trixi.pretty_form_utf, Trixi.pretty_form_ascii for further information on how to create custom analysis quantities.\n\nIn addition, the analysis callback records and outputs a number of quantitites that are useful for evaluating the computational performance, such as the total runtime, the performance index (time/DOF/rhs!), the time spent in garbage collection (GC), or the current memory usage (alloc'd memory).\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.AveragingCallback","page":"Trixi.jl","title":"Trixi.AveragingCallback","text":"AveragingCallback(semi::SemidiscretizationHyperbolic, tspan; output_directory=\"out\",\n                  filename=\"averaging.h5\")\n\nwarning: Experimental code\nThis callback is experimental and may change in any future release.\n\nA callback that averages the flow field described by semi which must be a semidiscretization of the compressible Euler equations in two dimensions. The callback records the mean velocity, mean speed of sound, mean density, and mean vorticity for each node over the time interval given by tspan and stores the results in an HDF5 file filename in the directory output_directory. Note that this callback does not support adaptive mesh refinement (AMRCallback).\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.BoundaryConditionDirichlet","page":"Trixi.jl","title":"Trixi.BoundaryConditionDirichlet","text":"BoundaryConditionDirichlet(boundary_value_function)\n\nCreate a Dirichlet boundary condition that uses the function boundary_value_function to specify the values at the boundary. This can be used to create a boundary condition that specifies exact boundary values by passing the exact solution of the equation. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as\n\nboundary_value_function(x, t, equations)\n\nwhere x specifies the coordinates, t is the current time, and equation is the corresponding system of equations.\n\nExamples\n\njulia> BoundaryConditionDirichlet(initial_condition_convergence_test)\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.BoundaryConditionNavierStokesWall","page":"Trixi.jl","title":"Trixi.BoundaryConditionNavierStokesWall","text":"struct BoundaryConditionNavierStokesWall\n\nCreates a wall-type boundary conditions for the compressible Navier-Stokes equations. The fields boundary_condition_velocity and boundary_condition_heat_flux are intended to be boundary condition types such as the NoSlip velocity boundary condition and the Adiabatic or Isothermal heat boundary condition.\n\nwarning: Experimental feature\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.BoundaryConditionNeumann","page":"Trixi.jl","title":"Trixi.BoundaryConditionNeumann","text":"BoundaryConditionNeumann(boundary_normal_flux_function)\n\nSimilar to BoundaryConditionDirichlet, but creates a Neumann boundary condition for parabolic equations that uses the function boundary_normal_flux_function to specify the values of the normal flux at the boundary. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as\n\nboundary_normal_flux_function(x, t, equations)\n\nwhere x specifies the coordinates, t is the current time, and equation is the corresponding system of equations.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CarpenterKennedy2N43","page":"Trixi.jl","title":"Trixi.CarpenterKennedy2N43","text":"  CarpenterKennedy2N43()\n\nCarpenter, Kennedy (1994) Third order 2N storage RK schemes with error control\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CarpenterKennedy2N54","page":"Trixi.jl","title":"Trixi.CarpenterKennedy2N54","text":"CarpenterKennedy2N54()\n\nThe following structures and methods provide a minimal implementation of the low-storage explicit Runge-Kutta method of\n\nCarpenter, Kennedy (1994) Fourth order 2N storage RK schemes, Solution 3\n\nusing the same interface as OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleEulerEquations1D","page":"Trixi.jl","title":"Trixi.CompressibleEulerEquations1D","text":"CompressibleEulerEquations1D(gamma)\n\nThe compressible Euler equations\n\nfracpartialpartial t\nbeginpmatrix\nrho  rho v_1  rho e\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\nrho v_1  rho v_1^2 + p  (rho e +p) v_1\nendpmatrix\n=\nbeginpmatrix\n0  0  0\nendpmatrix\n\nfor an ideal gas with ratio of specific heats gamma in one space dimension. Here, rho is the density, v_1 the velocity, e the specific total energy rather than specific internal energy, and\n\np = (gamma - 1) left( rho e - frac12 rho v_1^2 right)\n\nthe pressure.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleEulerEquations2D","page":"Trixi.jl","title":"Trixi.CompressibleEulerEquations2D","text":"CompressibleEulerEquations2D(gamma)\n\nThe compressible Euler equations\n\nfracpartialpartial t\nbeginpmatrix\nrho  rho v_1  rho v_2  rho e\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\n rho v_1  rho v_1^2 + p  rho v_1 v_2  (rho e +p) v_1\nendpmatrix\n+\nfracpartialpartial y\nbeginpmatrix\nrho v_2  rho v_1 v_2  rho v_2^2 + p  (rho e +p) v_2\nendpmatrix\n=\nbeginpmatrix\n0  0  0  0\nendpmatrix\n\nfor an ideal gas with ratio of specific heats gamma in two space dimensions. Here, rho is the density, v_1,v_2 the velocities, e the specific total energy rather than specific internal energy, and\n\np = (gamma - 1) left( rho e - frac12 rho (v_1^2+v_2^2) right)\n\nthe pressure.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleEulerEquations3D","page":"Trixi.jl","title":"Trixi.CompressibleEulerEquations3D","text":"CompressibleEulerEquations3D(gamma)\n\nThe compressible Euler equations\n\nfracpartialpartial t\nbeginpmatrix\nrho  rho v_1  rho v_2  rho v_3   rho e\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\n rho v_1  rho v_1^2 + p  rho v_1 v_2  rho v_1 v_3  ( rho e +p) v_1\nendpmatrix\n+\nfracpartialpartial y\nbeginpmatrix\nrho v_2  rho v_1 v_2  rho v_2^2 + p  rho v_1 v_3  ( rho e +p) v_2\nendpmatrix\n+\nfracpartialpartial z\nbeginpmatrix\nrho v_3  rho v_1 v_3  rho v_2 v_3  rho v_3^2 + p  ( rho e +p) v_3\nendpmatrix\n=\nbeginpmatrix\n0  0  0  0  0\nendpmatrix\n\nfor an ideal gas with ratio of specific heats gamma in three space dimensions. Here, rho is the density, v_1,v_2, v_3 the velocities, e the specific total energy rather than specific internal energy, and\n\np = (gamma - 1) left( rho e - frac12 rho (v_1^2+v_2^2+v_3^2) right)\n\nthe pressure.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleEulerMulticomponentEquations1D","page":"Trixi.jl","title":"Trixi.CompressibleEulerMulticomponentEquations1D","text":"CompressibleEulerMulticomponentEquations1D(; gammas, gas_constants)\n\nMulticomponent version of the compressible Euler equations\n\nfracpartialpartial t\nbeginpmatrix\nrho v_1  rho e  rho_1  rho_2  vdots  rho_n\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\nrho v_1^2 + p  (rho e +p) v_1  rho_1 v_1  rho_2 v_1  vdots  rho_n v_1\nendpmatrix\n\n=\nbeginpmatrix\n0  0  0  0  vdots  0\nendpmatrix\n\nfor calorically perfect gas in one space dimension. Here, rho_i is the density of component i, rho=sum_i=1^nrho_i the sum of the individual rho_i, v_1 the velocity, e the specific total energy rather than specific internal energy, and\n\np = (gamma - 1) left( rho e - frac12 rho v_1^2 right)\n\nthe pressure,\n\ngamma=fracsum_i=1^nrho_i C_vigamma_isum_i=1^nrho_i C_vi\n\ntotal heat capacity ratio, gamma_i heat capacity ratio of component i,\n\nC_vi=fracRgamma_i-1\n\nspecific heat capacity at constant volume of component i.\n\nIn case of more than one component, the specific heat ratios gammas and the gas constants gas_constants should be passed as tuples, e.g., gammas=(1.4, 1.667).\n\nThe remaining variables like the specific heats at constant volume 'cv' or the specific heats at constant pressure 'cp' are then calculated considering a calorically perfect gas.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleEulerMulticomponentEquations2D","page":"Trixi.jl","title":"Trixi.CompressibleEulerMulticomponentEquations2D","text":"CompressibleEulerMulticomponentEquations2D(; gammas, gas_constants)\n\nMulticomponent version of the compressible Euler equations\n\nfracpartialpartial t\nbeginpmatrix\nrho v_1  rho v_2  rho e  rho_1  rho_2  vdots  rho_n\nendpmatrix\n+\nfracpartialpartial x\nbeginpmatrix\nrho v_1^2 + p  rho v_1 v_2  ( rho e +p) v_1  rho_1 v_1  rho_2 v_1  vdots  rho_n v_1\nendpmatrix\n+\nfracpartialpartial y\nbeginpmatrix\nrho v_1 v_2  rho v_2^2 + p  ( rho e +p) v_2  rho_1 v_2  rho_2 v_2  vdots  rho_n v_2\nendpmatrix\n=\nbeginpmatrix\n0  0  0  0  0  vdots  0\nendpmatrix\n\nfor calorically perfect gas in two space dimensions. Here, rho_i is the density of component i, rho=sum_i=1^nrho_i the sum of the individual rho_i, v_1, v_2 the velocities, e the specific total energy rather than specific internal energy, and\n\np = (gamma - 1) left( rho e - frac12 rho (v_1^2 + v_2^2) right)\n\nthe pressure,\n\ngamma=fracsum_i=1^nrho_i C_vigamma_isum_i=1^nrho_i C_vi\n\ntotal heat capacity ratio, gamma_i heat capacity ratio of component i,\n\nC_vi=fracRgamma_i-1\n\nspecific heat capacity at constant volume of component i.\n\nIn case of more than one component, the specific heat ratios gammas and the gas constants gas_constants in [kJ/(kg*K)] should be passed as tuples, e.g., gammas=(1.4, 1.667).\n\nThe remaining variables like the specific heats at constant volume 'cv' or the specific heats at constant pressure 'cp' are then calculated considering a calorically perfect gas.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleNavierStokesDiffusion2D","page":"Trixi.jl","title":"Trixi.CompressibleNavierStokesDiffusion2D","text":"CompressibleNavierStokesDiffusion2D(equations; mu, Pr,\n                                    gradient_variables=GradientVariablesPrimitive())\n\nContains the diffusion (i.e. parabolic) terms applied to mass, momenta, and total energy together with the advective terms from the CompressibleEulerEquations2D.\n\nequations: instance of the CompressibleEulerEquations2D\nmu: dynamic viscosity,\nPr: Prandtl number,\ngradient_variables: which variables the gradients are taken with respect to.                       Defaults to GradientVariablesPrimitive().\n\nFluid properties such as the dynamic viscosity mu can be provided in any consistent unit system, e.g., [mu] = kg m⁻¹ s⁻¹.\n\nThe particular form of the compressible Navier-Stokes implemented is\n\nfracpartialpartial t\nbeginpmatrix\nrho  rho mathbfv  rho e\nendpmatrix\n+\nnabla cdot\nbeginpmatrix\n rho mathbfv  rho mathbfvmathbfv^T + p underlineI  (rho e + p) mathbfv\nendpmatrix\n=\nnabla cdot\nbeginpmatrix\n0  underlinetau  underlinetaumathbfv - nabla q\nendpmatrix\n\nwhere the system is closed with the ideal gas assumption giving\n\np = (gamma - 1) left( rho e - frac12 rho (v_1^2+v_2^2) right)\n\nas the pressure. The value of the adiabatic constant gamma is taken from the CompressibleEulerEquations2D. The terms on the right hand side of the system above are built from the viscous stress tensor\n\nunderlinetau = mu left(nablamathbfv + left(nablamathbfvright)^Tright) - frac23 mu left(nablacdotmathbfvright)underlineI\n\nwhere underlineI is the 2times 2 identity matrix and the heat flux is\n\nnabla q = -kappanablaleft(Tright)quad T = fracpRrho\n\nwhere T is the temperature and kappa is the thermal conductivity for Fick's law. Under the assumption that the gas has a constant Prandtl number, the thermal conductivity is\n\nkappa = fracgamma mu R(gamma - 1)textrmPr\n\nFrom this combination of temperature T and thermal conductivity kappa we see that the gas constant R cancels and the heat flux becomes\n\nnabla q = -kappanablaleft(Tright) = -fracgamma mu(gamma - 1)textrmPrnablaleft(fracprhoright)\n\nwhich is the form implemented below in the flux function.\n\nIn two spatial dimensions we require gradients for three quantities, e.g., primitive quantities\n\nnabla v_1 nabla v_2 nabla T\n\nor the entropy variables\n\nnabla w_2 nabla w_3 nabla w_4\n\nwhere\n\nw_2 = fracrho v_1p w_3 = fracrho v_2p w_4 = -fracrhop\n\n#!!! warning \"Experimental code\"\n\nThis code is experimental and may be changed or removed in any future release.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.CompressibleNavierStokesDiffusion3D","page":"Trixi.jl","title":"Trixi.CompressibleNavierStokesDiffusion3D","text":"CompressibleNavierStokesDiffusion3D(equations; mu, Pr,\n                                    gradient_variables=GradientVariablesPrimitive())\n\nContains the diffusion (i.e. parabolic) terms applied to mass, momenta, and total energy together with the advective terms from the CompressibleEulerEquations3D.\n\nequations: instance of the CompressibleEulerEquations3D\nmu: dynamic viscosity,\nPr: Prandtl number,\ngradient_variables: which variables the gradients are taken with respect to.                       Defaults to GradientVariablesPrimitive().\n\nFluid properties such as the dynamic viscosity mu can be provided in any consistent unit system, e.g., [mu] = kg m⁻¹ s⁻¹.\n\nThe particular form of the compressible Navier-Stokes implemented is\n\nfracpartialpartial t\nbeginpmatrix\nrho  rho mathbfv  rho e\nendpmatrix\n+\nnabla cdot\nbeginpmatrix\n rho mathbfv  rho mathbfvmathbfv^T + p underlineI  (rho e + p) mathbfv\nendpmatrix\n=\nnabla cdot\nbeginpmatrix\n0  underlinetau  underlinetaumathbfv - nabla q\nendpmatrix\n\nwhere the system is closed with the ideal gas assumption giving\n\np = (gamma - 1) left( rho e - frac12 rho (v_1^2+v_2^2+v_3^2) right)\n\nas the pressure. The value of the adiabatic constant gamma is taken from the CompressibleEulerEquations2D. The terms on the right hand side of the system above are built from the viscous stress tensor\n\nunderlinetau = mu left(nablamathbfv + left(nablamathbfvright)^Tright) - frac23 mu left(nablacdotmathbfvright)underlineI\n\nwhere underlineI is the 3times 3 identity matrix and the heat flux is\n\nnabla q = -kappanablaleft(Tright)quad T = fracpRrho\n\nwhere T is the temperature and kappa is the thermal conductivity for Fick's law. Under the assumption that the gas has a constant Prandtl number, the thermal conductivity is\n\nkappa = fracgamma mu R(gamma - 1)textrmPr\n\nFrom this combination of temperature T and thermal conductivity kappa we see that the gas constant R cancels and the heat flux becomes\n\nnabla q = -kappanablaleft(Tright) = -fracgamma mu(gamma - 1)textrmPrnablaleft(fracprhoright)\n\nwhich is the form implemented below in the flux function.\n\nIn two spatial dimensions we require gradients for three quantities, e.g., primitive quantities\n\nnabla v_1 nabla v_2 nabla v_3 nabla T\n\nor the entropy variables\n\nnabla w_2 nabla w_3 nabla w_4 nabla w_5\n\nwhere\n\nw_2 = fracrho v_1p w_3 = fracrho v_2p w_4 = fracrho v_3p w_5 = -fracrhop\n\n#!!! warning \"Experimental code\"\n\nThis code is experimental and may be changed or removed in any future release.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ControllerThreeLevel","page":"Trixi.jl","title":"Trixi.ControllerThreeLevel","text":"ControllerThreeLevel(semi, indicator; base_level=1,\n                                      med_level=base_level, med_threshold=0.0,\n                                      max_level=base_level, max_threshold=1.0)\n\nAn AMR controller based on three levels (in decending order of precedence):\n\nset the target level to max_level if indicator > max_threshold\nset the target level to med_level if indicator > med_threshold; if med_level < 0, set the target level to the current level\nset the target level to base_level otherwise\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ControllerThreeLevelCombined","page":"Trixi.jl","title":"Trixi.ControllerThreeLevelCombined","text":"ControllerThreeLevelCombined(semi, indicator_primary, indicator_secondary;\n                             base_level=1,\n                             med_level=base_level, med_threshold=0.0,\n                             max_level=base_level, max_threshold=1.0,\n                             max_threshold_secondary=1.0)\n\nAn AMR controller based on three levels (in decending order of precedence):\n\nset the target level to max_level if indicator_primary > max_threshold\nset the target level to med_level if indicator_primary > med_threshold; if med_level < 0, set the target level to the current level\nset the target level to base_level otherwise\n\nIf indicator_secondary >= max_threshold_secondary, set the target level to max_level.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.DG","page":"Trixi.jl","title":"Trixi.DG","text":"DG(; basis, mortar, surface_integral, volume_integral)\n\nCreate a discontinuous Galerkin method. If basis isa LobattoLegendreBasis, this creates a DGSEM.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.DGMulti-Tuple{SummationByPartsOperators.AbstractDerivativeOperator}","page":"Trixi.jl","title":"Trixi.DGMulti","text":"DGMulti(approximation_type::AbstractDerivativeOperator;\n        element_type::AbstractElemShape,\n        surface_flux=flux_central,\n        surface_integral=SurfaceIntegralWeakForm(surface_flux),\n        volume_integral=VolumeIntegralWeakForm(),\n        kwargs...)\n\nCreate a summation by parts (SBP) discretization on the given element_type using a tensor product structure based on the 1D SBP derivative operator passed as approximation_type.\n\nFor more info, see the documentations of StartUpDG.jl and SummationByPartsOperators.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGMulti-Tuple{}","page":"Trixi.jl","title":"Trixi.DGMulti","text":"DGMulti(; polydeg::Integer,\n          element_type::AbstractElemShape,\n          approximation_type=Polynomial(),\n          surface_flux=flux_central,\n          surface_integral=SurfaceIntegralWeakForm(surface_flux),\n          volume_integral=VolumeIntegralWeakForm(),\n          RefElemData_kwargs...)\n\nCreate a discontinuous Galerkin method which uses\n\napproximations of polynomial degree polydeg\nelement type element_type (Tri(), Quad(), Tet(), and Hex() currently supported)\n\nOptional:\n\napproximation_type (default is Polynomial(); SBP() also supported for Tri(), Quad(), and Hex() element types).\nRefElemData_kwargs are additional keyword arguments for RefElemData, such as quad_rule_vol. For more info, see the StartUpDG.jl docs.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGMultiMesh","page":"Trixi.jl","title":"Trixi.DGMultiMesh","text":"DGMultiMesh{NDIMS, ...}\n\nDGMultiMesh describes a mesh type which wraps StartUpDG.MeshData and boundary_faces in a dispatchable type. This is intended to store geometric data and connectivities for any type of mesh (Cartesian, affine, curved, structured/unstructured).\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.DGMultiMesh-Tuple{DGMulti{2, Tri, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, <:StartUpDG.RefElemData{2, Tri, ApproxType}} where {ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, Dict{Symbol, Int64}}","page":"Trixi.jl","title":"Trixi.DGMultiMesh","text":"DGMultiMesh(dg::DGMulti{2, Tri}, triangulateIO, boundary_dict::Dict{Symbol, Int})\n\ndg::DGMulti contains information associated with to the reference element (e.g., quadrature, basis evaluation, differentiation, etc).\ntriangulateIO is a TriangulateIO mesh representation\nboundary_dict is a Dict{Symbol, Int} which associates each integer TriangulateIO boundary tag with a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGMultiMesh-Union{Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, <:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}}, Tuple{NDIMS}} where NDIMS","page":"Trixi.jl","title":"Trixi.DGMultiMesh","text":"DGMultiMesh(dg::DGMulti; cells_per_dimension,\n            coordinates_min=(-1.0, -1.0), coordinates_max=(1.0, 1.0),\n            is_on_boundary=nothing,\n            periodicity=ntuple(_ -> false, NDIMS))\n\nConstructs a Cartesian DGMultiMesh with element type dg.basis.element_type. The domain is the tensor product of the intervals [coordinates_min[i], coordinates_max[i]].\n\nis_on_boundary specifies boundary using a Dict{Symbol, <:Function}\nperiodicity is a tuple of Bools specifying periodicity = true/false in the (x,y,z) direction.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGMultiMesh-Union{Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, <:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType<:SummationByPartsOperators.AbstractPeriodicDerivativeOperator, SurfaceIntegral, VolumeIntegral, Mortar}}, Tuple{NDIMS}} where NDIMS","page":"Trixi.jl","title":"Trixi.DGMultiMesh","text":"DGMultiMesh(dg::DGMulti)\n\nConstructs a single-element DGMultiMesh for a single periodic element given a DGMulti with approximation_type set to a periodic (finite difference) SBP operator from SummationByPartsOperators.jl.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, <:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, AbstractArray}} where NDIMS","page":"Trixi.jl","title":"Trixi.DGMultiMesh","text":"DGMultiMesh(dg::DGMulti{NDIMS}, vertexcoordinates, EToV;               isonboundary=nothing,               periodicity=ntuple(->false, NDIMS)) where {NDIMS}\n\ndg::DGMulti contains information associated with to the reference element (e.g., quadrature, basis evaluation, differentiation, etc).\nvertex_coordinates is a tuple of vectors containing x,y,... components of the vertex coordinates\nEToV is a 2D array containing element-to-vertex connectivities for each element\nis_on_boundary specifies boundary using a Dict{Symbol, <:Function}\nperiodicity is a tuple of booleans specifying if the domain is periodic true/false in the (x,y,z) direction.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGMultiMesh-Union{Tuple{NDIMS}, Tuple{DGMulti{NDIMS, ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar, <:StartUpDG.RefElemData{NDIMS, ElemType, ApproxType}} where {ElemType, ApproxType, SurfaceIntegral, VolumeIntegral, Mortar}, Any, Any}} where NDIMS","page":"Trixi.jl","title":"Trixi.DGMultiMesh","text":"DGMultiMesh(dg::DGMulti{NDIMS}, cells_per_dimension, mapping;\n            is_on_boundary=nothing,\n            periodicity=ntuple(_ -> false, NDIMS), kwargs...) where {NDIMS}\n\nConstructs a Curved() DGMultiMesh with element type dg.basis.element_type.\n\nmapping is a function which maps from a reference [-1, 1]^NDIMS domain to a mapped domain,  e.g., xy = mapping(x, y) in 2D.\nis_on_boundary specifies boundary using a Dict{Symbol, <:Function}\nperiodicity is a tuple of Bools specifying periodicity = true/false in the (x,y,z) direction.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.DGSEM","page":"Trixi.jl","title":"Trixi.DGSEM","text":"DGSEM(; RealT=Float64, polydeg::Integer,\n        surface_flux=flux_central,\n        surface_integral=SurfaceIntegralWeakForm(surface_flux),\n        volume_integral=VolumeIntegralWeakForm(),\n        mortar=MortarL2(basis))\n\nCreate a discontinuous Galerkin spectral element method (DGSEM) using a LobattoLegendreBasis with polynomials of degree polydeg.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.DissipationGlobalLaxFriedrichs","page":"Trixi.jl","title":"Trixi.DissipationGlobalLaxFriedrichs","text":"DissipationGlobalLaxFriedrichs(λ)\n\nCreate a global Lax-Friedrichs dissipation operator with dissipation coefficient λ.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.DissipationLocalLaxFriedrichs","page":"Trixi.jl","title":"Trixi.DissipationLocalLaxFriedrichs","text":"DissipationLocalLaxFriedrichs(max_abs_speed=max_abs_speed_naive)\n\nCreate a local Lax-Friedrichs dissipation operator where the maximum absolute wave speed is estimated as max_abs_speed(u_ll, u_rr, orientation_or_normal_direction, equations), defaulting to max_abs_speed_naive.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.EulerAcousticsCouplingCallback","page":"Trixi.jl","title":"Trixi.EulerAcousticsCouplingCallback","text":"EulerAcousticsCouplingCallback\n\nwarning: Experimental code\nThis callback is experimental and may change in any future release.\n\nA callback that couples the acoustic perturbation equations and compressible Euler equations. Must be used in conjunction with SemidiscretizationEulerAcoustics. This callback manages the flow solver - which is always one time step ahead of the acoustics solver - and calculates the acoustic source term after each time step. The linearized Lamb vector is used as the source term, i.e.\n\nmathbfs = -(mathbfomega times barmathbfv\n  + barmathbfomega times mathbfv)\n\nwhere mathbfv denotes the velocity, mathbfomega denotes the vorticity, the bar bar(cdot) indicates time-averaged quantities (see AveragingCallback) and prime (cdot) denotes perturbed quantities defined by phi = phi - barphi. Note that the perturbed quantities here are based entirely on the pure flow solution and should not be confused with the state variables of the acoustic perturbation equations.\n\nIn addition, this callback manages the time step size for both solvers and initializes the mean values of the acoustic perturbation equations using results obtained with the AveragingCallback.\n\nMichael Schlottke-Lakemper (2017) A direct-hybrid method for aeroacoustic analysis DOI: 10.18154/RWTH-2017-04082\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.EulerAcousticsCouplingCallback-Tuple{Any, AbstractString, Any, Real, Real}","page":"Trixi.jl","title":"Trixi.EulerAcousticsCouplingCallback","text":"EulerAcousticsCouplingCallback(ode_euler, averaging_file::AbstractString, alg,\n                               cfl_acoustics::Real, cfl_euler::Real; kwargs...)\n\nwarning: Experimental code\nThis callback is experimental and may change in any future release.\n\nCreates an EulerAcousticsCouplingCallback based on the pure flow ODEProblem given by ode_euler. Creates an integrator using the time integration method alg and the keyword arguments to solve ode_euler (consult the OrdinaryDiffEq documentation for further information). Manages the step size for both solvers by using the minimum of the maximum step size obtained with CFL numbers cfl_acoustics for the acoustics solver and cfl_euler for and flow solver, respectively. The mean values for the acoustic perturbation equations are read from averaging_file (see AveragingCallback).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.EulerAcousticsCouplingCallback-Tuple{Any, DiscreteCallback{<:Any, <:AveragingCallback}, Any, Real, Real}","page":"Trixi.jl","title":"Trixi.EulerAcousticsCouplingCallback","text":"EulerAcousticsCouplingCallback(ode_euler,\n                               averaging_callback::DiscreteCallback{<:Any, <:AveragingCallback},\n                               alg, cfl_acoustics::Real, cfl_euler::Real; kwargs...)\n\nwarning: Experimental code\nThis callback is experimental and may change in any future release.\n\nCreates an EulerAcousticsCouplingCallback based on the pure flow ODEProblem given by ode_euler. Creates an integrator using the time integration method alg and the keyword arguments to solve ode_euler (consult the OrdinaryDiffEq documentation for further information). Manages the step size for both solvers by using the minimum of the maximum step size obtained with CFL numbers cfl_acoustics for the acoustics solver and cfl_euler for and flow solver, respectively. The mean values for the acoustic perturbation equations are read from averaging_callback (see AveragingCallback).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.FDSBP","page":"Trixi.jl","title":"Trixi.FDSBP","text":"FDSBP(D_SBP; surface_integral, volume_integral)\n\nSpecialization of DG methods that uses general summation by parts (SBP) operators from SummationByPartsOperators.jl. In particular, this includes classical finite difference (FD) SBP methods. These methods have the same structure as classical DG methods - local operations on elements with connectivity through interfaces without imposing any continuity constraints.\n\nD_SBP is an SBP derivative operator from SummationByPartsOperators.jl. The other arguments have the same meaning as in DG or DGSEM.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxHLL","page":"Trixi.jl","title":"Trixi.FluxHLL","text":"FluxHLL(min_max_speed=min_max_speed_naive)\n\nCreate an HLL (Harten, Lax, van Leer) numerical flux where the minimum and maximum wave speeds are estimated as λ_min, λ_max = min_max_speed(u_ll, u_rr, orientation_or_normal_direction, equations), defaulting to min_max_speed_naive.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxHydrostaticReconstruction","page":"Trixi.jl","title":"Trixi.FluxHydrostaticReconstruction","text":"FluxHydrostaticReconstruction(numerical_flux, hydrostatic_reconstruction)\n\nwarning: Experimental code\nThis numerical flux is experimental and may change in any future release.\n\nAllow for some kind of hydrostatic reconstruction of the solution state prior to the surface flux computation. This is a particular strategy to ensure that the method remains well-balanced for the shallow water equations, see ShallowWaterEquations1D or ShallowWaterEquations2D.\n\nFor example, the hydrostatic reconstruction from Audusse et al. is implemented in one and two spatial dimensions, see hydrostatic_reconstruction_audusse_etal or the original paper\n\nEmmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows DOI: 10.1137/S1064827503431090\n\nOther hydrostatic reconstruction techniques are available, particularly to handle wet / dry fronts. A good overview of the development and application of hydrostatic reconstruction can be found in\n\nGuoxian Chen and Sebastian Noelle A unified surface-gradient and hydrostatic reconstruction scheme for the shallow water equations (2021) RWTH Aachen preprint\nAndreas Buttinger-Kreuzhuber, Zsolt Horváth, Sebastian Noelle, Günter Blöschl and Jürgen Waser (2019) A fast second-order shallow water scheme on two-dimensional structured grids over abrupt topography DOI: 10.1016/j.advwatres.2019.03.010\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxLMARS","page":"Trixi.jl","title":"Trixi.FluxLMARS","text":"FluxLMARS(c)(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerEquations3D)\n\nLow Mach number approximate Riemann solver (LMARS) for atmospheric flows using an estimate c of the speed of sound.\n\nReferences:\n\nXi Chen et al. (2013) A Control-Volume Model of the Compressible Euler Equations with a Vertical Lagrangian Coordinate DOI: 10.1175/MWR-D-12-00129.1\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxLaxFriedrichs","page":"Trixi.jl","title":"Trixi.FluxLaxFriedrichs","text":"FluxLaxFriedrichs(max_abs_speed=max_abs_speed_naive)\n\nLocal Lax-Friedrichs (Rusanov) flux with maximum wave speed estimate provided by max_abs_speed, cf. DissipationLocalLaxFriedrichs and max_abs_speed_naive.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxPlusDissipation","page":"Trixi.jl","title":"Trixi.FluxPlusDissipation","text":"FluxPlusDissipation(numerical_flux, dissipation)\n\nCombine a numerical_flux with a dissipation operator to create a new numerical flux.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxRotated","page":"Trixi.jl","title":"Trixi.FluxRotated","text":"FluxRotated(numerical_flux)\n\nCompute a numerical_flux flux in direction of a normal vector by rotating the solution, computing the numerical flux in x-direction, and rotating the calculated flux back.\n\nRequires a rotationally invariant equation with equation-specific functions rotate_to_x and rotate_from_x.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.FluxUpwind","page":"Trixi.jl","title":"Trixi.FluxUpwind","text":"FluxUpwind(splitting)\n\nA numerical flux f(u_left, u_right) = f⁺(u_left) + f⁻(u_right) based on flux vector splitting.\n\nThe SurfaceIntegralUpwind with a given splitting is equivalent to the SurfaceIntegralStrongForm with FluxUpwind(splitting) as numerical flux (up to floating point differences).\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.GlmSpeedCallback","page":"Trixi.jl","title":"Trixi.GlmSpeedCallback","text":"GlmSpeedCallback(; glm_scale=0.5, cfl)\n\nUpdate the divergence cleaning wave speed c_h according to the time step computed in StepsizeCallback for the ideal GLM-MHD equations. The cfl number should be set to the same value as for the time step size calculation. The glm_scale ensures that the GLM wave speed is lower than the fastest physical waves in the MHD solution and should thus be set to a value within the interval [0,1]. Note that glm_scale = 0 deactivates the divergence cleaning.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.GradientVariablesPrimitive","page":"Trixi.jl","title":"Trixi.GradientVariablesPrimitive","text":"#!!! warning \"Experimental code\"\n\nThis code is experimental and may be changed or removed in any future release.\n\nGradientVariablesPrimitive and GradientVariablesEntropy are gradient variable type parameters for CompressibleNavierStokesDiffusion2D. By default, the gradient variables are set to be GradientVariablesPrimitive. Specifying GradientVariablesEntropy instead uses the entropy variable formulation from\n\nHughes, Mallet, Franca (1986) A new finite element formulation for computational fluid dynamics: I. Symmetric forms of the compressible Euler and Navier-Stokes equations and the second law of thermodynamics. https://doi.org/10.1016/0045-7825(86)90127-1\n\nUnder GradientVariablesEntropy, the Navier-Stokes discretization is provably entropy stable.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.HypDiffN3Erk3Sstar52","page":"Trixi.jl","title":"Trixi.HypDiffN3Erk3Sstar52","text":"HypDiffN3Erk3Sstar52()\n\nFive stage, second-order acurate explicit Runge-Kutta scheme with stability region optimized for the hyperbolic diffusion equation with LLF flux and polynomials of degree polydeg=3.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.HyperbolicDiffusionEquations1D","page":"Trixi.jl","title":"Trixi.HyperbolicDiffusionEquations1D","text":"HyperbolicDiffusionEquations1D\n\nThe linear hyperbolic diffusion equations in one space dimension. A description of this system can be found in Sec. 2.5 of the book\n\nMasatsuka (2013) I Do Like CFD, Too: Vol 1. Freely available at http://www.cfdbooks.com/\n\nFurther analysis can be found in the paper\n\nNishikawa (2007) A first-order system approach for diffusion equation. I: Second-order residual-distribution schemes DOI: 10.1016/j.jcp.2007.07.029\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.HyperbolicDiffusionEquations2D","page":"Trixi.jl","title":"Trixi.HyperbolicDiffusionEquations2D","text":"HyperbolicDiffusionEquations2D\n\nThe linear hyperbolic diffusion equations in two space dimensions. A description of this system can be found in Sec. 2.5 of the book \"I Do Like CFD, Too: Vol 1\". The book is freely available at http://www.cfdbooks.com/ and further analysis can be found in the paper by Nishikawa DOI: 10.1016/j.jcp.2007.07.029\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.HyperbolicDiffusionEquations3D","page":"Trixi.jl","title":"Trixi.HyperbolicDiffusionEquations3D","text":"HyperbolicDiffusionEquations3D\n\nThe linear hyperbolic diffusion equations in three space dimensions. A description of this system can be found in Sec. 2.5 of the book \"I Do Like CFD, Too: Vol 1\". The book is freely available at http://www.cfdbooks.com/ and further analysis can be found in the paper by Nishikawa DOI: 10.1016/j.jcp.2007.07.029\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IdealGlmMhdEquations1D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdEquations1D","text":"IdealGlmMhdEquations1D(gamma)\n\nThe ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats gamma in one space dimension.\n\nnote: Note\nThere is no divergence cleaning variable psi because the divergence-free constraint is satisfied trivially in one spatial dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IdealGlmMhdEquations2D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdEquations2D","text":"IdealGlmMhdEquations2D(gamma)\n\nThe ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats gamma in two space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IdealGlmMhdEquations3D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdEquations3D","text":"IdealGlmMhdEquations3D(gamma)\n\nThe ideal compressible GLM-MHD equations for an ideal gas with ratio of specific heats gamma in three space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IdealGlmMhdMulticomponentEquations1D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdMulticomponentEquations1D","text":"IdealGlmMhdMulticomponentEquations1D\n\nThe ideal compressible multicomponent GLM-MHD equations in one space dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IdealGlmMhdMulticomponentEquations2D","page":"Trixi.jl","title":"Trixi.IdealGlmMhdMulticomponentEquations2D","text":"IdealGlmMhdMulticomponentEquations2D\n\nThe ideal compressible multicomponent GLM-MHD equations in two space dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IndicatorHennemannGassner","page":"Trixi.jl","title":"Trixi.IndicatorHennemannGassner","text":"IndicatorHennemannGassner(equations::AbstractEquations, basis;\n                          alpha_max=0.5,\n                          alpha_min=0.001,\n                          alpha_smooth=true,\n                          variable)\nIndicatorHennemannGassner(semi::AbstractSemidiscretization;\n                          alpha_max=0.5,\n                          alpha_min=0.001,\n                          alpha_smooth=true,\n                          variable)\n\nIndicator used for shock-capturing (when passing the equations and the basis) or adaptive mesh refinement (AMR, when passing the semi).\n\nSee also VolumeIntegralShockCapturingHG.\n\nReferences\n\nHennemann, Gassner (2020) \"A provably entropy stable subcell shock capturing approach for high order split form DG\" arXiv: 2008.12044\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IndicatorLöhner","page":"Trixi.jl","title":"Trixi.IndicatorLöhner","text":"IndicatorLöhner (equivalent to IndicatorLoehner)\n\nIndicatorLöhner(equations::AbstractEquations, basis;\n                f_wave=0.2, variable)\nIndicatorLöhner(semi::AbstractSemidiscretization;\n                f_wave=0.2, variable)\n\nAMR indicator adapted from a FEM indicator by Löhner (1987), also used in the FLASH code as standard AMR indicator. The indicator estimates a weighted second derivative of a specified variable locally.\n\nWhen constructed to be used for AMR, pass the semi. Pass the equations, and basis if this indicator should be used for shock capturing.\n\nReferences\n\nLöhner (1987) \"An adaptive finite element scheme for transient problems in CFD\" doi: 10.1016/0045-7825(87)90098-3\nhttp://flash.uchicago.edu/site/flashcode/usersupport/flash4ug_4p62/node59.html#SECTION05163100000000000000\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IndicatorMax","page":"Trixi.jl","title":"Trixi.IndicatorMax","text":"IndicatorMax(equations::AbstractEquations, basis; variable)\nIndicatorMax(semi::AbstractSemidiscretization; variable)\n\nA simple indicator returning the maximum of variable in an element. When constructed to be used for AMR, pass the semi. Pass the equations, and basis if this indicator should be used for shock capturing.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.IndicatorNeuralNetwork","page":"Trixi.jl","title":"Trixi.IndicatorNeuralNetwork","text":"IndicatorNeuralNetwork\n\nArtificial neural network based indicator used for shock-capturing or AMR. Depending on the indicator_type, different input values and corresponding trained networks are used.\n\nindicator_type = NeuralNetworkPerssonPeraire()\n\nInput: The energies in lower modes as well as nnodes(dg).\n\nindicator_type = NeuralNetworkRayHesthaven()\n\n1d Input: Cell average of the cell and its neighboring cells as well as the interface values.\n2d Input: Linear modal values of the cell and its neighboring cells.\nRay, Hesthaven (2018) \"An artificial neural network as a troubled-cell indicator\" doi:10.1016/j.jcp.2018.04.029\nRay, Hesthaven (2019) \"Detecting troubled-cells on two-dimensional unstructured grids using a neural network\" doi:10.1016/j.jcp.2019.07.043\n\nindicator_type = CNN (Only in 2d)\n\nBased on convolutional neural network.\n2d Input: Interpolation of the nodal values of the indicator.variable to the 4x4 LGL nodes.\n\nIf alpha_continuous == true the continuous network output for troubled cells (alpha > 0.5) is considered. If the cells are good (alpha < 0.5), alpha is set to 0. If alpha_continuous == false, the blending factor is set to alpha = 0 for good cells and alpha = 1 for troubled cells.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.InviscidBurgersEquation1D","page":"Trixi.jl","title":"Trixi.InviscidBurgersEquation1D","text":"InviscidBurgersEquation1D\n\nThe inviscid Burgers' equation\n\npartial_t u + frac12 partial_1 u^2 = 0\n\nin one space dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.Isothermal","page":"Trixi.jl","title":"Trixi.Isothermal","text":"struct Isothermal\n\nUsed to create a no-slip boundary condition with BoundaryConditionNavierStokesWall. The field boundary_value_function should be a function with signature boundary_value_function(x, t, equations) and return a scalar value for the temperature at point x and time t.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LaplaceDiffusion2D","page":"Trixi.jl","title":"Trixi.LaplaceDiffusion2D","text":"LaplaceDiffusion2D(diffusivity, equations)\n\nLaplaceDiffusion2D represents a scalar diffusion term nabla cdot (kappanabla u)) with diffusivity kappa applied to each solution component defined by equations.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LatticeBoltzmannEquations2D","page":"Trixi.jl","title":"Trixi.LatticeBoltzmannEquations2D","text":"LatticeBoltzmannEquations2D(; Ma, Re, collision_op=collision_bgk,\n                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)\n\nThe Lattice-Boltzmann equations\n\npartial_t u_alpha + v_alpha1 partial_1 u_alpha + v_alpha2 partial_2 u_alpha = 0\n\nin two space dimensions for the D2Q9 scheme.\n\nThe characteristic Mach number and Reynolds numbers are specified as Ma and Re. By the default, the collision operator collision_op is set to the BGK model. c, L, and rho0 specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity u0 directly (Ma needs to be set to nothing in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity nu directly (in this case, Re needs to be set to nothing).\n\nThe nine discrete velocity directions of the D2Q9 scheme are sorted as follows [4]:\n\n  6     2     5       y\n    ┌───┼───┐         │\n    │       │         │\n  3 ┼   9   ┼ 1        ──── x\n    │       │        ╱\n    └───┼───┘       ╱\n  7     4     8    z\n\nNote that usually the velocities are numbered from 0 to 8, where 0 corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from 1 to 9, where 1 through 8 correspond to the velocity directions in [4] and 9 is the zero velocity.\n\nThe corresponding opposite directions are:\n\n1 ←→ 3\n2 ←→ 4\n3 ←→ 1\n4 ←→ 2\n5 ←→ 7\n6 ←→ 8\n7 ←→ 5\n8 ←→ 6\n9 ←→ 9\n\nThe main sources for the base implementation were\n\nMisun Min, Taehun Lee, A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows, J Comput Phys 230(1), 2011 doi:10.1016/j.jcp.2010.09.024\nKarsten Golly, Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum, Master Thesis, University of Cologne, 2018.\nDieter Hänel, Molekulare Gasdynamik, Springer-Verlag Berlin Heidelberg, 2004 doi:10.1007/3-540-35047-0\nDieter Krüger et al., The Lattice Boltzmann Method, Springer International Publishing, 2017 doi:10.1007/978-3-319-44649-3\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LatticeBoltzmannEquations3D","page":"Trixi.jl","title":"Trixi.LatticeBoltzmannEquations3D","text":"LatticeBoltzmannEquations3D(; Ma, Re, collision_op=collision_bgk,\n                           c=1, L=1, rho0=1, u0=nothing, nu=nothing)\n\nThe Lattice-Boltzmann equations\n\npartial_t u_alpha + v_alpha1 partial_1 u_alpha + v_alpha2 partial_2 u_alpha + v_alpha3 partial_3 u_alpha = 0\n\nin three space dimensions for the D3Q27 scheme.\n\nThe characteristic Mach number and Reynolds numbers are specified as Ma and Re. By the default, the collision operator collision_op is set to the BGK model. c, L, and rho0 specify the mean thermal molecular velocity, the characteristic length, and the reference density, respectively. They can usually be left to the default values. If desired, instead of the Mach number, one can set the macroscopic reference velocity u0 directly (Ma needs to be set to nothing in this case). Likewise, instead of the Reynolds number one can specify the kinematic viscosity nu directly (in this case, Re needs to be set to nothing).\n\nThe twenty-seven discrete velocity directions of the D3Q27 scheme are sorted as follows [4]:\n\nplane at z = -1:\n  24    17     21       y\n     ┌───┼───┐          │\n     │       │          │\n  10 ┼   6   ┼ 15        ──── x\n     │       │         ╱\n     └───┼───┘        ╱\n  20    12     26    z\nplane at z = 0:\n  14     3     7        y\n     ┌───┼───┐          │\n     │       │          │\n   2 ┼  27   ┼ 1         ──── x\n     │       │         ╱\n     └───┼───┘        ╱\n   8     4     13    z\nplane at z = +1:\n  25    11     19       y\n     ┌───┼───┐          │\n     │       │          │\n  16 ┼   5   ┼ 9         ──── x\n     │       │         ╱\n     └───┼───┘        ╱\n  22    18     23    z\n\nNote that usually the velocities are numbered from 0 to 26, where 0 corresponds to the zero velocity. Due to Julia using 1-based indexing, here we use indices from 1 to 27, where 1 through 26 correspond to the velocity directions in [4] and 27 is the zero velocity.\n\nThe corresponding opposite directions are:\n\n1 ←→  2\n2 ←→  1\n3 ←→  4\n4 ←→  3\n5 ←→  6\n6 ←→  5\n7 ←→  8\n8 ←→  7\n9 ←→ 10\n10 ←→  9\n11 ←→ 12\n12 ←→ 11\n13 ←→ 14\n14 ←→ 13\n15 ←→ 16\n16 ←→ 15\n17 ←→ 18\n18 ←→ 17\n19 ←→ 20\n20 ←→ 19\n21 ←→ 22\n22 ←→ 21\n23 ←→ 24\n24 ←→ 23\n25 ←→ 26\n26 ←→ 25\n27 ←→ 27\n\nThe main sources for the base implementation were\n\nMisun Min, Taehun Lee, A spectral-element discontinuous Galerkin lattice Boltzmann method for nearly incompressible flows, J Comput Phys 230(1), 2011 doi:10.1016/j.jcp.2010.09.024\nKarsten Golly, Anwendung der Lattice-Boltzmann Discontinuous Galerkin Spectral Element Method (LB-DGSEM) auf laminare und turbulente nahezu inkompressible Strömungen im dreidimensionalen Raum, Master Thesis, University of Cologne, 2018.\nDieter Hänel, Molekulare Gasdynamik, Springer-Verlag Berlin Heidelberg, 2004 doi:10.1007/3-540-35047-0\nDieter Krüger et al., The Lattice Boltzmann Method, Springer International Publishing, 2017 doi:10.1007/978-3-319-44649-3\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LinearScalarAdvectionEquation1D","page":"Trixi.jl","title":"Trixi.LinearScalarAdvectionEquation1D","text":"LinearScalarAdvectionEquation1D\n\nThe linear scalar advection equation\n\npartial_t u + a partial_1 u  = 0\n\nin one space dimension with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LinearScalarAdvectionEquation2D","page":"Trixi.jl","title":"Trixi.LinearScalarAdvectionEquation2D","text":"LinearScalarAdvectionEquation2D\n\nThe linear scalar advection equation\n\npartial_t u + a_1 partial_1 u + a_2 partial_2 u = 0\n\nin two space dimensions with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LinearScalarAdvectionEquation3D","page":"Trixi.jl","title":"Trixi.LinearScalarAdvectionEquation3D","text":"LinearScalarAdvectionEquation3D\n\nThe linear scalar advection equation\n\npartial_t u + a_1 partial_1 u + a_2 partial_2 u + a_3 partial_3 u = 0\n\nin three space dimensions with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LinearizedEulerEquations2D","page":"Trixi.jl","title":"Trixi.LinearizedEulerEquations2D","text":"LinearizedEulerEquations2D(v_mean_global, c_mean_global, rho_mean_global)\n\nLinearized euler equations in two space dimensions. The equations are given by\n\npartial_t\nbeginpmatrix\n    rho  v_1  v_2  p\nendpmatrix\n+\npartial_x\nbeginpmatrix\n    barrho v_1 + barv_1 rho   barv_1 v_1 + fracpbarrho  barv_1 v_2  barv_1 p + c^2 barrho v_1\nendpmatrix\n+\npartial_y\nbeginpmatrix\n    barrho v_2 + barv_2 rho   barv_2 v_1  barv_2 v_2 + fracpbarrho  barv_2 p + c^2 barrho v_2\nendpmatrix\n=\nbeginpmatrix\n    0  0  0  0\nendpmatrix\n\nThe bar bar(cdot) indicates uniform mean flow variables and c is the speed of sound. The unknowns are the acoustic velocities v = (v_1 v_2), the pressure p and the density rho.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.LobattoLegendreBasis","page":"Trixi.jl","title":"Trixi.LobattoLegendreBasis","text":"LobattoLegendreBasis([RealT=Float64,] polydeg::Integer)\n\nCreate a nodal Lobatto-Legendre basis for polynomials of degree polydeg.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.NeuralNetworkCNN","page":"Trixi.jl","title":"Trixi.NeuralNetworkCNN","text":"NeuralNetworkCNN\n\nIndicator type for creating an IndicatorNeuralNetwork indicator.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: IndicatorNeuralNetwork\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.NeuralNetworkPerssonPeraire","page":"Trixi.jl","title":"Trixi.NeuralNetworkPerssonPeraire","text":"NeuralNetworkPerssonPeraire\n\nIndicator type for creating an IndicatorNeuralNetwork indicator.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: IndicatorNeuralNetwork\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.NeuralNetworkRayHesthaven","page":"Trixi.jl","title":"Trixi.NeuralNetworkRayHesthaven","text":"NeuralNetworkRayHesthaven\n\nIndicator type for creating an IndicatorNeuralNetwork indicator.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: IndicatorNeuralNetwork\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.NoSlip","page":"Trixi.jl","title":"Trixi.NoSlip","text":"struct NoSlip\n\nUse to create a no-slip boundary condition with BoundaryConditionNavierStokesWall. The field boundary_value_function should be a function with signature boundary_value_function(x, t, equations) and should return a SVector{NDIMS} whose entries are the velocity vector at a point x and time t.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.P4estMesh","page":"Trixi.jl","title":"Trixi.P4estMesh","text":"P4estMesh{NDIMS} <: AbstractMesh{NDIMS}\n\nAn unstructured curved mesh based on trees that uses the C library p4est to manage trees and mesh refinement.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.P4estMesh-Tuple{Any}","page":"Trixi.jl","title":"Trixi.P4estMesh","text":"P4estMesh(trees_per_dimension; polydeg,\n          mapping=nothing, faces=nothing, coordinates_min=nothing, coordinates_max=nothing,\n          RealT=Float64, initial_refinement_level=0, periodicity=true, unsaved_changes=true,\n          p4est_partition_allow_for_coarsening=true)\n\nCreate a structured curved P4estMesh of the specified size.\n\nThere are three ways to map the mesh to the physical domain.\n\nDefine a mapping that maps the hypercube [-1, 1]^n.\nSpecify a Tuple faces of functions that parametrize each face.\nCreate a rectangular mesh by specifying coordinates_min and coordinates_max.\n\nNon-periodic boundaries will be called :x_neg, :x_pos, :y_neg, :y_pos, :z_neg, :z_pos.\n\nArguments\n\ntrees_per_dimension::NTupleE{NDIMS, Int}: the number of trees in each dimension.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nmapping: a function of NDIMS variables to describe the mapping that transforms            the reference mesh ([-1, 1]^n) to the physical domain.            Use only one of mapping, faces and coordinates_min/coordinates_max.\nfaces::NTuple{2*NDIMS}: a tuple of 2 * NDIMS functions that describe the faces of the domain.                           Each function must take NDIMS-1 arguments.                           faces[1] describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by faces[2].                           faces[3:4] describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           faces[5:6] describe the faces in positive and negative z-direction respectively (in 3D).                           Use only one of mapping, faces and coordinates_min/coordinates_max.\ncoordinates_min: vector or tuple of the coordinates of the corner in the negative direction of each dimension                    to create a rectangular mesh.                    Use only one of mapping, faces and coordinates_min/coordinates_max.\ncoordinates_max: vector or tuple of the coordinates of the corner in the positive direction of each dimension                    to create a rectangular mesh.                    Use only one of mapping, faces and coordinates_min/coordinates_max.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool}                deciding for each dimension if the boundaries in this dimension are periodic.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity                                               independent of domain partitioning. Should be false for static meshes                                               to permit more fine-grained partitioning.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.P4estMesh-Union{Tuple{String}, Tuple{NDIMS}} where NDIMS","page":"Trixi.jl","title":"Trixi.P4estMesh","text":"P4estMesh{NDIMS}(meshfile::String;\n                 mapping=nothing, polydeg=1, RealT=Float64,\n                 initial_refinement_level=0, unsaved_changes=true,\n                 p4est_partition_allow_for_coarsening=true)\n\nMain mesh constructor for the P4estMesh that imports an unstructured, conforming mesh from an Abaqus mesh file (.inp). Each element of the conforming mesh parsed from the meshfile is created as a p4est tree datatype.\n\nTo create a curved unstructured mesh P4estMesh two strategies are available:\n\np4est_mesh_from_hohqmesh_abaqus: High-order, curved boundary information created by                                    HOHQMesh.jl is                                    available in the meshfile. The mesh polynomial degree polydeg                                    of the boundaries is provided from the meshfile. The computation of                                    the mapped tree coordinates is done with transfinite interpolation                                    with linear blending similar to UnstructuredMesh2D. Boundary name                                    information is also parsed from the meshfile such that different boundary                                    conditions can be set at each named boundary on a given tree.\np4est_mesh_from_standard_abaqus: By default, with mapping=nothing and polydeg=1, this creates a                                    straight-sided from the information parsed from the meshfile. If a mapping                                    function is specified then it computes the mapped tree coordinates via polynomial                                    interpolants with degree polydeg. The mesh created by this function will only                                    have one boundary :all, as distinguishing different physical boundaries is                                    non-trivial.\n\nNote that the mapping and polydeg keyword arguments are only used by the p4est_mesh_from_standard_abaqus function. The p4est_mesh_from_hohqmesh_abaqus function obtains the mesh polydeg directly from the meshfile and constructs the transfinite mapping internally.\n\nThe particular strategy is selected according to the header present in the meshfile where the constructor checks whether or not the meshfile was created with HOHQMesh.jl. If the Abaqus file header is not present in the meshfile then the P4estMesh is created with the function p4est_mesh_from_standard_abaqus.\n\nThe default keyword argument initial_refinement_level=0 corresponds to a forest where the number of trees is the same as the number of elements in the original meshfile. Increasing the initial_refinement_level allows one to uniformly refine the base mesh given in the meshfile to create a forest with more trees before the simulation begins. For example, if a two-dimensional base mesh contains 25 elements then setting initial_refinement_level=1 creates an initial forest of 2^2 * 25 = 100 trees.\n\nArguments\n\nmeshfile::String: an uncurved Abaqus mesh file that can be imported by p4est.\nmapping: a function of NDIMS variables to describe the mapping that transforms            the imported mesh to the physical domain. Use nothing for the identity map.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.                     The default of 1 creates an uncurved geometry. Use a higher value if the mapping                     will curve the imported uncurved mesh.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity                                               independent of domain partitioning. Should be false for static meshes                                               to permit more fine-grained partitioning.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ParametersEulerGravity","page":"Trixi.jl","title":"Trixi.ParametersEulerGravity","text":"ParametersEulerGravity(; background_density=0.0,\n                         gravitational_constant=1.0,\n                         cfl=1.0,\n                         resid_tol=1.0e-4,\n                         n_iterations_max=10^4,\n                         timestep_gravity=timestep_gravity_erk52_3Sstar!)\n\nSet up parameters for the gravitational part of a SemidiscretizationEulerGravity.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ParsaniKetchesonDeconinck3Sstar32","page":"Trixi.jl","title":"Trixi.ParsaniKetchesonDeconinck3Sstar32","text":"ParsaniKetchesonDeconinck3Sstar32()\n\nParsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems DOI: 10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ParsaniKetchesonDeconinck3Sstar94","page":"Trixi.jl","title":"Trixi.ParsaniKetchesonDeconinck3Sstar94","text":"ParsaniKetchesonDeconinck3Sstar94()\n\nParsani, Ketcheson, Deconinck (2013)   Optimized explicit RK schemes for the spectral difference method applied to wave propagation problems DOI: 10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.PerformanceCounter","page":"Trixi.jl","title":"Trixi.PerformanceCounter","text":"PerformanceCounter()\n\nA PerformanceCounter can be used to track the runtime performance of some calls. Add a new runtime measurement via put!(counter, runtime) and get the averaged runtime of all measurements added so far via take!(counter), resetting the counter.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.PerformanceCounterList","page":"Trixi.jl","title":"Trixi.PerformanceCounterList","text":"PerformanceCounterList{N}()\n\nA PerformanceCounterList{N} can be used to track the runtime performance of calls to multiple functions, adding them up. Add a new runtime measurement via put!(counter.counters[i], runtime) and get the averaged runtime of all measurements added so far via take!(counter), resetting the counter.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.PlotData1D","page":"Trixi.jl","title":"Trixi.PlotData1D","text":"PlotData1D\n\nHolds all relevant data for creating 1D plots of multiple solution variables and to visualize the mesh.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.PlotData1D-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.PlotData1D","text":"PlotData1D(u, semi [or mesh, equations, solver, cache];\n           solution_variables=nothing, nvisnodes=nothing)\n\nCreate a new PlotData1D object that can be used for visualizing 1D DGSEM solution data array u with Plots.jl. All relevant geometrical information is extracted from the semidiscretization semi. By default, the primitive variables (if existent) or the conservative variables (otherwise) from the solution are used for plotting. This can be changed by passing an appropriate conversion function to solution_variables.\n\nnvisnodes specifies the number of visualization nodes to be used. If it is nothing, twice the number of solution DG nodes are used for visualization, and if set to 0, exactly the number of nodes in the DG elements are used.\n\nWhen visualizing data from a two-dimensional simulation, a 1D slice is extracted for plotting. slice specifies the axis along which the slice is extracted and may be :x, or :y. The slice position is specified by a point that lies on it, which defaults to (0.0, 0.0). Both of these values are ignored when visualizing 1D data. This applies analogously to three-dimensonal simulations, where slice may be :xy, :xz, or :yz.\n\nAnother way to visualize 2D/3D data is by creating a plot along a given curve. This is done with the keyword argument curve. It can be set to a list of 2D/3D points which define the curve. When using curve any other input from slice or point will be ignored.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.PlotData1D-Tuple{Union{ODESolution{T, N, uType, uType2, DType, tType, rateType, P} where {T, N, uType, uType2, DType, tType, rateType, P<:(ODEProblem{uType_, tType_, isinplace, P_} where {uType_, tType_, isinplace, P_<:Trixi.AbstractSemidiscretization})}, Trixi.TimeIntegratorSolution}}","page":"Trixi.jl","title":"Trixi.PlotData1D","text":"PlotData1D(sol; kwargs...)\n\nCreate a PlotData1D object from a solution object created by either OrdinaryDiffEq.solve! (which returns a SciMLBase.ODESolution) or Trixi's own solve! (which returns a TimeIntegratorSolution).\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.PlotData2DCartesian","page":"Trixi.jl","title":"Trixi.PlotData2DCartesian","text":"PlotData2D\n\nHolds all relevant data for creating 2D plots of multiple solution variables and to visualize the mesh.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.PositivityPreservingLimiterZhangShu","page":"Trixi.jl","title":"Trixi.PositivityPreservingLimiterZhangShu","text":"PositivityPreservingLimiterZhangShu(; threshold, variables)\n\nThe fully-discrete positivity-preserving limiter of\n\nZhang, Shu (2011) Maximum-principle-satisfying and positivity-preserving high-order schemes for conservation laws: survey and new developments doi: 10.1098/rspa.2011.0153\n\nThe limiter is applied to all scalar variables in their given order using the associated thresholds to determine the minimal acceptable values. The order of the variables is important and might have a strong influence on the robustness.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SaveRestartCallback","page":"Trixi.jl","title":"Trixi.SaveRestartCallback","text":"SaveRestartCallback(; interval=0,\n                      save_final_restart=true,\n                      output_directory=\"out\")\n\nSave the current numerical solution in a restart file every interval time steps.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SaveSolutionCallback","page":"Trixi.jl","title":"Trixi.SaveSolutionCallback","text":"SaveSolutionCallback(; interval=0,\n                       save_initial_solution=true,\n                       save_final_solution=true,\n                       output_directory=\"out\",\n                       solution_variables=cons2prim)\n\nSave the current numerical solution every interval time steps. solution_variables can be any callable that converts the conservative variables at a single point to a set of solution variables. The first parameter passed to solution_variables will be the set of conservative variables and the second parameter is the equation struct.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SemidiscretizationEulerAcoustics","page":"Trixi.jl","title":"Trixi.SemidiscretizationEulerAcoustics","text":"SemidiscretizationEulerAcoustics(semi_acoustics::SemiAcoustics, semi_euler::SemiEuler;\n                                 source_region=x->true, weights=x->1.0)\n\nwarning: Experimental code\nThis semidiscretization is experimental and may change in any future release.\n\nConstruct a semidiscretization of the acoustic perturbation equations that is coupled with the compressible Euler equations via source terms for the perturbed velocity. Both semidiscretizations have to use the same mesh and solvers with a shared basis. The coupling region is described by a function source_region that maps the coordinates of a single node to true or false depending on whether the point lies within the coupling region or not. A weighting function weights that maps coordinates to weights is applied to the acoustic source terms. Note that this semidiscretization should be used in conjunction with EulerAcousticsCouplingCallback and only works in two dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SemidiscretizationEulerGravity","page":"Trixi.jl","title":"Trixi.SemidiscretizationEulerGravity","text":"SemidiscretizationEulerGravity\n\nA struct containing everything needed to describe a spatial semidiscretization of a the compressible Euler equations with self-gravity, reformulating the Poisson equation for the gravitational potential as steady-state problem of the hyperblic diffusion equations.\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) \"A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics\" arXiv: 2008.10593\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SemidiscretizationEulerGravity-Union{Tuple{SemiGravity}, Tuple{SemiEuler}, Tuple{Mesh}, Tuple{SemiEuler, SemiGravity, Any}} where {Mesh, SemiEuler<:(SemidiscretizationHyperbolic{Mesh, <:Trixi.AbstractCompressibleEulerEquations}), SemiGravity<:(SemidiscretizationHyperbolic{Mesh, <:Trixi.AbstractHyperbolicDiffusionEquations})}","page":"Trixi.jl","title":"Trixi.SemidiscretizationEulerGravity","text":"SemidiscretizationEulerGravity(semi_euler::SemiEuler, semi_gravity::SemiGravity, parameters)\n\nConstruct a semidiscretization of the compressible Euler equations with self-gravity. parameters should be given as ParametersEulerGravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.SemidiscretizationHyperbolic","page":"Trixi.jl","title":"Trixi.SemidiscretizationHyperbolic","text":"SemidiscretizationHyperbolic\n\nA struct containing everything needed to describe a spatial semidiscretization of a hyperbolic conservation law.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SemidiscretizationHyperbolic-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.SemidiscretizationHyperbolic","text":"SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver;\n                             source_terms=nothing,\n                             boundary_conditions=boundary_condition_periodic,\n                             RealT=real(solver),\n                             uEltype=RealT,\n                             initial_cache=NamedTuple())\n\nConstruct a semidiscretization of a hyperbolic PDE.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.SemidiscretizationHyperbolicParabolic","page":"Trixi.jl","title":"Trixi.SemidiscretizationHyperbolicParabolic","text":"SemidiscretizationHyperbolicParabolic\n\nA struct containing everything needed to describe a spatial semidiscretization of a mixed hyperbolic-parabolic conservation law.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SemidiscretizationHyperbolicParabolic-Tuple{Any, Tuple, Any, Any}","page":"Trixi.jl","title":"Trixi.SemidiscretizationHyperbolicParabolic","text":"SemidiscretizationHyperbolicParabolic(mesh, both_equations, initial_condition, solver;\n                                      solver_parabolic=default_parabolic_solver(),\n                                      source_terms=nothing,\n                                      both_boundary_conditions=(boundary_condition_periodic, boundary_condition_periodic),\n                                      RealT=real(solver),\n                                      uEltype=RealT,\n                                      both_initial_caches=(NamedTuple(), NamedTuple()))\n\nConstruct a semidiscretization of a hyperbolic-parabolic PDE.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ShallowWaterEquations1D","page":"Trixi.jl","title":"Trixi.ShallowWaterEquations1D","text":"ShallowWaterEquations1D(gravity, H0)\n\nShallow water equations (SWE) in one space dimension. The equations are given by\n\nbeginaligned\n  fracpartial hpartial t + fracpartialpartial x(h v) = 0 \r\n    fracpartialpartial t(h v) + fracpartialpartial xleft(h v^2 + fracg2h^2right)\n    + g h fracpartial bpartial x = 0\nendaligned\n\nThe unknown quantities of the SWE are the water height h and the velocity v. The gravitational constant is denoted by g and the (possibly) variable bottom topography function b(x). Conservative variable water height h is measured from the bottom topography b, therefore one also defines the total water height as H = h + b.\n\nThe additional quantity H_0 is also available to store a reference value for the total water height that is useful to set initial conditions or test the \"lake-at-rest\" well-balancedness.\n\nThe bottom topography function b(x) is set inside the initial condition routine for a particular problem setup. To test the conservative form of the SWE one can set the bottom topography variable b to zero.\n\nIn addition to the unknowns, Trixi currently stores the bottom topography values at the approximation points despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height H or the entropy variables. This affects the implementation and use of these equations in various ways:\n\nThe flux values corresponding to the bottom topography must be zero.\nThe bottom topography values must be included when defining initial conditions, boundary conditions or source terms.\nAnalysisCallback analyzes this variable.\nTrixi's visualization tools will visualize the bottom topography by default.\n\nReferences for the SWE are many but a good introduction is available in Chapter 13 of the book:\n\nRandall J. LeVeque (2002) Finite Volume Methods for Hyperbolic Problems DOI: 10.1017/CBO9780511791253\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ShallowWaterEquations2D","page":"Trixi.jl","title":"Trixi.ShallowWaterEquations2D","text":"ShallowWaterEquations2D(gravity, H0)\n\nShallow water equations (SWE) in two space dimensions. The equations are given by\n\nbeginaligned\n  fracpartial hpartial t + fracpartialpartial x(h v_1)\n    + fracpartialpartial y(h v_2) = 0 \r\n    fracpartialpartial t(h v_1) + fracpartialpartial xleft(h v_1^2 + fracg2h^2right)\n    + fracpartialpartial y(h v_1 v_2) + g h fracpartial bpartial x = 0 \r\n    fracpartialpartial t(h v_2) + fracpartialpartial x(h v_1 v_2)\n    + fracpartialpartial yleft(h v_2^2 + fracg2h^2right) + g h fracpartial bpartial y = 0\nendaligned\n\nThe unknown quantities of the SWE are the water height h and the velocities mathbfv = (v_1 v_2)^T. The gravitational constant is denoted by g and the (possibly) variable bottom topography function b(xy). Conservative variable water height h is measured from the bottom topography b, therefore one also defines the total water height as H = h + b.\n\nThe additional quantity H_0 is also available to store a reference value for the total water height that is useful to set initial conditions or test the \"lake-at-rest\" well-balancedness.\n\nThe bottom topography function b(xy) is set inside the initial condition routine for a particular problem setup. To test the conservative form of the SWE one can set the bottom topography variable b to zero.\n\nIn addition to the unknowns, Trixi currently stores the bottom topography values at the approximation points despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height H or the entropy variables. This affects the implementation and use of these equations in various ways:\n\nThe flux values corresponding to the bottom topography must be zero.\nThe bottom topography values must be included when defining initial conditions, boundary conditions or source terms.\nAnalysisCallback analyzes this variable.\nTrixi's visualization tools will visualize the bottom topography by default.\n\nReferences for the SWE are many but a good introduction is available in Chapter 13 of the book:\n\nRandall J. LeVeque (2002) Finite Volume Methods for Hyperbolic Problems DOI: 10.1017/CBO9780511791253\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SteadyStateCallback","page":"Trixi.jl","title":"Trixi.SteadyStateCallback","text":"SteadyStateCallback(; abstol=1.0e-8, reltol=1.0e-6)\n\nTerminates the integration when the residual_steady_state(du, equations) falls below the threshold specified by abstol, reltol.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.StepsizeCallback","page":"Trixi.jl","title":"Trixi.StepsizeCallback","text":"StepsizeCallback(; cfl=1.0)\n\nSet the time step size according to a CFL condition with CFL number cfl if the time integration method isn't adaptive itself.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.StructuredMesh","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh{NDIMS} <: AbstractMesh{NDIMS}\n\nA structured curved mesh.\n\nDifferent numbers of cells per dimension are possible and arbitrary functions can be used as domain faces.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.StructuredMesh-Tuple{Any, Any, Any}","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh(cells_per_dimension, coordinates_min, coordinates_max; periodicity=true)\n\nCreate a StructuredMesh that represents a uncurved structured mesh with a rectangular domain.\n\nArguments\n\ncells_per_dimension::NTuple{NDIMS, Int}: the number of cells in each dimension.\ncoordinates_min::NTuple{NDIMS, RealT}: coordinate of the corner in the negative direction of each dimension.\ncoordinates_max::NTuple{NDIMS, RealT}: coordinate of the corner in the positive direction of each dimension.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool} deciding for                each dimension if the boundaries in this dimension are periodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.StructuredMesh-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh(cells_per_dimension, mapping; RealT=Float64, unsaved_changes=true, mapping_as_string=mapping2string(mapping, length(cells_per_dimension)))\n\nCreate a StructuredMesh of the given size and shape that uses RealT as coordinate type.\n\nArguments\n\ncells_per_dimension::NTupleE{NDIMS, Int}: the number of cells in each dimension.\nmapping: a function of NDIMS variables to describe the mapping, which transforms            the reference mesh to the physical domain.            If no mapping_as_string is defined, this function must be defined with the name mapping            to allow for restarts.            This will be changed in the future, see https://github.com/trixi-framework/Trixi.jl/issues/541.\nRealT::Type: the type that should be used for coordinates.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool}                deciding for each dimension if the boundaries in this dimension are periodic.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\nmapping_as_string::String: the code that defines the mapping.                              If CodeTracking can't find the function definition, it can be passed directly here.                              The code string must define the mapping function with the name mapping.                              This will be changed in the future, see https://github.com/trixi-framework/Trixi.jl/issues/541.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.StructuredMesh-Tuple{Any, Tuple}","page":"Trixi.jl","title":"Trixi.StructuredMesh","text":"StructuredMesh(cells_per_dimension, faces; RealT=Float64, unsaved_changes=true, faces_as_string=faces2string(faces))\n\nCreate a StructuredMesh of the given size and shape that uses RealT as coordinate type.\n\nArguments\n\ncells_per_dimension::NTupleE{NDIMS, Int}: the number of cells in each dimension.\nfaces::NTuple{2*NDIMS}: a tuple of 2 * NDIMS functions that describe the faces of the domain.                           Each function must take NDIMS-1 arguments.                           faces[1] describes the face onto which the face in negative x-direction                           of the unit hypercube is mapped. The face in positive x-direction of                           the unit hypercube will be mapped onto the face described by faces[2].                           faces[3:4] describe the faces in positive and negative y-direction respectively                           (in 2D and 3D).                           faces[5:6] describe the faces in positive and negative z-direction respectively (in 3D).\nRealT::Type: the type that should be used for coordinates.\nperiodicity: either a Bool deciding if all of the boundaries are periodic or an NTuple{NDIMS, Bool} deciding for                each dimension if the boundaries in this dimension are periodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.SurfaceIntegralStrongForm","page":"Trixi.jl","title":"Trixi.SurfaceIntegralStrongForm","text":"SurfaceIntegralStrongForm(surface_flux=flux_central)\n\nThe classical strong form surface integral type for FD/DG methods.\n\nSee also VolumeIntegralStrongForm.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SurfaceIntegralUpwind","page":"Trixi.jl","title":"Trixi.SurfaceIntegralUpwind","text":"SurfaceIntegralUpwind(splitting)\n\nCouple elements with upwind simultaneous approximation terms (SATs) that use a particular flux splitting, e.g., splitting_steger_warming.\n\nSee also VolumeIntegralUpwind.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.SurfaceIntegralWeakForm","page":"Trixi.jl","title":"Trixi.SurfaceIntegralWeakForm","text":"SurfaceIntegralWeakForm(surface_flux=flux_central)\n\nThe classical weak form surface integral type for DG methods as explained in standard textbooks.\n\nSee also VolumeIntegralWeakForm.\n\nReferences\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\nHesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications doi: 10.1007/978-0-387-72067-8\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.TimeSeriesCallback","page":"Trixi.jl","title":"Trixi.TimeSeriesCallback","text":"TimeSeriesCallback(semi, point_coordinates;\n                   interval=1, solution_variables=cons2cons,\n                   output_directory=\"out\", filename=\"time_series.h5\",\n                   RealT=real(solver), uEltype=eltype(cache.elements))\n\nCreate a callback that records point-wise data at points given in point_coordinates every interval time steps. The point coordinates are to be specified either as a vector of coordinate tuples or as a two-dimensional array where the first dimension is the point number and the second dimension is the coordinate dimension. By default, the conservative variables are recorded, but this can be controlled by passing a different conversion function to solution_variables.\n\nAfter the last time step, the results are stored in an HDF5 file filename in directory output_directory.\n\nThe real data type RealT and data type for solution variables uEltype default to the respective types used in the solver and the cache.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.TreeMesh","page":"Trixi.jl","title":"Trixi.TreeMesh","text":"TreeMesh{NDIMS} <: AbstractMesh{NDIMS}\n\nA Cartesian mesh based on trees of hypercubes to support adaptive mesh refinement.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.UnstructuredMesh2D","page":"Trixi.jl","title":"Trixi.UnstructuredMesh2D","text":"UnstructuredMesh2D <: AbstractMesh{2}\n\nAn unstructured (possibly curved) quadrilateral mesh.\n\nUnstructuredMesh2D(filename; RealT=Float64, periodicity=false)\n\nAll mesh information, neighbour coupling, and boundary curve information is read in from a mesh file filename.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.UnstructuredSortedBoundaryTypes","page":"Trixi.jl","title":"Trixi.UnstructuredSortedBoundaryTypes","text":"UnstructuredSortedBoundaryTypes\n\nGeneral container to sort the boundary conditions by type for some unstructured meshes/solvers. It stores a set of global indices for each boundary condition type to expedite computation during the call to calc_boundary_flux!. The original dictionary form of the boundary conditions set by the user in the elixir file is also stored for printing.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ViscousFormulationBassiRebay1","page":"Trixi.jl","title":"Trixi.ViscousFormulationBassiRebay1","text":"ViscousFormulationBassiRebay1()\n\nThe classical BR1 flux from\n\nF. Bassi, S. Rebay (1997) A High-Order Accurate Discontinuous Finite Element Method for the Numerical Solution of the Compressible Navier-Stokes Equations DOI: 10.1006/jcph.1996.5572\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.ViscousFormulationLocalDG","page":"Trixi.jl","title":"Trixi.ViscousFormulationLocalDG","text":"ViscousFormulationLocalDG(penalty_parameter)\n\nThe local DG (LDG) flux from \"The Local Discontinuous Galerkin Method for Time-Dependent Convection-Diffusion Systems\" by Cockburn and Shu (1998).\n\nNote that, since this implementation does not involve the parabolic \"upwinding\" vector, the LDG solver is equivalent to ViscousFormulationBassiRebay1 with an LDG-type penalization.\n\nCockburn and Shu (1998). The Local Discontinuous Galerkin Method for Time-Dependent Convection-Diffusion Systems DOI: 10.1137/S0036142997316712\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.VisualizationCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.VisualizationCallback","text":"VisualizationCallback(; interval=0,\n                        solution_variables=cons2prim,\n                        variable_names=[],\n                        show_mesh=false,\n                        plot_data_creator=PlotData2D,\n                        plot_creator=show_plot,\n                        plot_arguments...)\n\nCreate a callback that visualizes results during a simulation, also known as in-situ visualization.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in any future releases.\n\nThe interval specifies the number of time step iterations after which a new plot is generated. The available variables to plot are configured with the solution_variables parameter, which acts the same way as for the SaveSolutionCallback. The variables to be actually plotted can be selected by providing a single string or a list of strings to variable_names, and if show_mesh is true, an additional plot with the mesh will be generated.\n\nTo customize the generated figure, plot_data_creator allows to use different plot data types. With plot_creator you can further specify an own function to visualize results, which must support the same interface as the default implementation show_plot. All remaining keyword arguments are collected and passed as additional arguments to the plotting command.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.VolumeIntegralFluxDifferencing","page":"Trixi.jl","title":"Trixi.VolumeIntegralFluxDifferencing","text":"VolumeIntegralFluxDifferencing(volume_flux)\n\nVolume integral type for DG methods based on SBP operators and flux differencing using a symmetric two-point volume_flux. This volume_flux needs to satisfy the interface of numerical fluxes in Trixi.jl.\n\nReferences\n\nLeFloch, Mercier, Rohde (2002) Fully Discrete, Entropy Conservative Schemes of Arbitrary Order doi: 10.1137/S003614290240069X\nFisher, Carpenter (2013) High-order entropy stable finite difference schemes for nonlinear conservation laws: Finite domains doi: 10.1016/j.jcp.2013.06.014\nHendrik Ranocha (2017) Comparison of Some Entropy Conservative Numerical Fluxes for the Euler Equations arXiv: 1701.02264 doi: 10.1007/s10915-017-0618-1\nChen, Shu (2017) Entropy stable high order discontinuous Galerkin methods with suitable quadrature rules for hyperbolic conservation laws doi: 10.1016/j.jcp.2017.05.025\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.VolumeIntegralPureLGLFiniteVolume","page":"Trixi.jl","title":"Trixi.VolumeIntegralPureLGLFiniteVolume","text":"VolumeIntegralPureLGLFiniteVolume(volume_flux_fv)\n\nA volume integral that only uses the subcell finite volume schemes of the VolumeIntegralShockCapturingHG.\n\nThis gives a formally O(1)-accurate finite volume scheme on an LGL-type subcell mesh (LGL = Legendre-Gauss-Lobatto).\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nHennemann, Gassner (2020) \"A provably entropy stable subcell shock capturing approach for high order split form DG\" arXiv: 2008.12044\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.VolumeIntegralShockCapturingHG","page":"Trixi.jl","title":"Trixi.VolumeIntegralShockCapturingHG","text":"VolumeIntegralShockCapturingHG(indicator; volume_flux_dg=flux_central,\n                                          volume_flux_fv=flux_lax_friedrichs)\n\nShock-capturing volume integral type for DG methods using a convex blending of the finite volume method with numerical flux volume_flux_fv and the VolumeIntegralFluxDifferencing with volume flux volume_flux_dg. The amount of blending is determined by the indicator, e.g., IndicatorHennemannGassner.\n\nReferences\n\nHennemann, Gassner (2020) \"A provably entropy stable subcell shock capturing approach for high order split form DG\" arXiv: 2008.12044\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.VolumeIntegralStrongForm","page":"Trixi.jl","title":"Trixi.VolumeIntegralStrongForm","text":"VolumeIntegralStrongForm()\n\nThe classical strong form volume integral type for FD/DG methods.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.VolumeIntegralUpwind","page":"Trixi.jl","title":"Trixi.VolumeIntegralUpwind","text":"VolumeIntegralUpwind(splitting)\n\nSpecialized volume integral for finite difference summation-by-parts (FDSBP) solvers. Can be used together with the upwind SBP operators of Mattsson (2017) implemented in SummationByPartsOperators.jl. The splitting controls the discretization.\n\nSee also splitting_steger_warming, splitting_lax_friedrichs, splitting_vanleer_haenel.\n\nReferences\n\nMattsson (2017) Diagonal-norm upwind SBP operators doi: 10.1016/j.jcp.2017.01.042\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Trixi.VolumeIntegralWeakForm","page":"Trixi.jl","title":"Trixi.VolumeIntegralWeakForm","text":"VolumeIntegralWeakForm()\n\nThe classical weak form volume integral type for DG methods as explained in standard textbooks.\n\nReferences\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\nHesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications doi: 10.1007/978-0-387-72067-8\n\n\n\n\n\n","category":"type"},{"location":"reference-trixi.html#Base.getindex-Tuple{Trixi.AbstractPlotData, Any}","page":"Trixi.jl","title":"Base.getindex","text":"Base.getindex(pd::AbstractPlotData, variable_name)\n\nExtract a single variable variable_name from pd for plotting with Plots.plot.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Base.resize!-Tuple{Trixi.AbstractContainer, Any}","page":"Trixi.jl","title":"Base.resize!","text":"resize!(c::AbstractContainer, new_length) -> AbstractContainer\n\nResize c to contain new_length elements. If new_length is smaller than the current container length, the first new_length elements will be retained. If new_length is larger, the new elements are invalidated.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#PolynomialBases.compute_coefficients!-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"PolynomialBases.compute_coefficients!","text":"compute_coefficients!(u_ode, func, t, semi::AbstractSemidiscretization)\n\nSame as compute_coefficients but stores the result in u_ode.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#PolynomialBases.compute_coefficients-Tuple{Any, Any, Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"PolynomialBases.compute_coefficients","text":"compute_coefficients(func, t, semi::AbstractSemidiscretization)\n\nCompute the discrete coefficients of the continuous function func at time t associated with the semidiscretization semi. For example, the discrete coefficients of func for a discontinuous Galerkin spectral element method (DGSEM) are the values of func at the Lobatto-Legendre nodes. Similarly, a classical finite difference method will use the values of func at the nodes of the grid assoociated with the semidiscretization semi.\n\nFor semidiscretizations semi associated with an initial condition, func can be omitted to use the given initial condition at time t.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#PolynomialBases.integrate-Tuple{Any, Any, LobattoLegendreBasis}","page":"Trixi.jl","title":"PolynomialBases.integrate","text":"integrate(f, u, basis::LobattoLegendreBasis)\n\nMap the function f to the coefficients u and integrate with respect to the quadrature rule given by basis.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#PolynomialBases.integrate-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization}} where Func","page":"Trixi.jl","title":"PolynomialBases.integrate","text":"integrate([func=(u_node,equations)->u_node,] u_ode, semi::AbstractSemidiscretization; normalize=true)\n\nCall func(u_node, equations) for each vector of nodal variables u_node in u_ode and integrate the result using a quadrature associated with the semidiscretization semi.\n\nIf normalize is true, the result is divided by the total volume of the computational domain.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#SummationByPartsOperators.semidiscretize-Tuple{SemidiscretizationHyperbolicParabolic, Any}","page":"Trixi.jl","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(semi::SemidiscretizationHyperbolicParabolic, tspan)\n\nWrap the semidiscretization semi as a split ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem. The parabolic right-hand side is the first function of the split ODE problem and will be used by default by the implicit part of IMEX methods from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#SummationByPartsOperators.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any, AbstractString}","page":"Trixi.jl","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(semi::AbstractSemidiscretization, tspan, restart_file::AbstractString)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem. The initial condition etc. is taken from the restart_file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#SummationByPartsOperators.semidiscretize-Tuple{Trixi.AbstractSemidiscretization, Any}","page":"Trixi.jl","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(semi::AbstractSemidiscretization, tspan)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.LBMCollisionCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.LBMCollisionCallback","text":"LBMCollisionCallback()\n\nApply the Lattice-Boltzmann method (LBM) collision operator before each time step. See LatticeBoltzmannEquations2D for further details.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.P4estMeshCubedSphere-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.P4estMeshCubedSphere","text":"P4estMeshCubedSphere(trees_per_face_dimension, layers, inner_radius, thickness;\n                     polydeg, RealT=Float64,\n                     initial_refinement_level=0, unsaved_changes=true,\n                     p4est_partition_allow_for_coarsening=true)\n\nBuild a \"Cubed Sphere\" mesh as P4estMesh with 6 * trees_per_face_dimension^2 * layers trees.\n\nThe mesh will have two boundaries, :inside and :outside.\n\nArguments\n\ntrees_per_face_dimension::Integer: the number of trees in the first two local dimensions of                                      each face.\nlayers::Integer: the number of trees in the third local dimension of each face, i.e., the number                    of layers of the sphere.\ninner_radius::Integer: the inner radius of the sphere.\nthickness::Integer: the thickness of the sphere. The outer radius will be inner_radius + thickness.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity                                               independent of domain partitioning. Should be false for static meshes                                               to permit more fine-grained partitioning.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.PlotData2D","text":"PlotData2D(u, semi [or mesh, equations, solver, cache];\n           solution_variables=nothing,\n           grid_lines=true, max_supported_level=11, nvisnodes=nothing,\n           slice=:xy, point=(0.0, 0.0, 0.0))\n\nCreate a new PlotData2D object that can be used for visualizing 2D/3D DGSEM solution data array u with Plots.jl. All relevant geometrical information is extracted from the semidiscretization semi. By default, the primitive variables (if existent) or the conservative variables (otherwise) from the solution are used for plotting. This can be changed by passing an appropriate conversion function to solution_variables.\n\nIf grid_lines is true, also extract grid vertices for visualizing the mesh. The output resolution is indirectly set via max_supported_level: all data is interpolated to 2^max_supported_level uniformly distributed points in each spatial direction, also setting the maximum allowed refinement level in the solution. nvisnodes specifies the number of visualization nodes to be used. If it is nothing, twice the number of solution DG nodes are used for visualization, and if set to 0, exactly the number of nodes in the DG elements are used.\n\nWhen visualizing data from a three-dimensional simulation, a 2D slice is extracted for plotting. slice specifies the plane that is being sliced and may be :xy, :xz, or :yz. The slice position is specified by a point that lies on it, which defaults to (0.0, 0.0, 0.0). Both of these values are ignored when visualizing 2D data.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nExamples\n\njulia> using Trixi, Plots\n\njulia> trixi_include(default_example())\n[...]\n\njulia> pd = PlotData2D(sol)\nPlotData2D(...)\n\njulia> plot(pd) # To plot all available variables\n\njulia> plot(pd[\"scalar\"]) # To plot only a single variable\n\njulia> plot!(getmesh(pd)) # To add grid lines to the plot\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.PlotData2D-Tuple{Union{ODESolution{T, N, uType, uType2, DType, tType, rateType, P} where {T, N, uType, uType2, DType, tType, rateType, P<:(ODEProblem{uType_, tType_, isinplace, P_} where {uType_, tType_, isinplace, P_<:Trixi.AbstractSemidiscretization})}, Trixi.TimeIntegratorSolution}}","page":"Trixi.jl","title":"Trixi.PlotData2D","text":"PlotData2D(sol; kwargs...)\n\nCreate a PlotData2D object from a solution object created by either OrdinaryDiffEq.solve! (which returns a SciMLBase.ODESolution) or Trixi's own solve! (which returns a TimeIntegratorSolution).\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ScalarPlotData2D-Tuple{Any, Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.ScalarPlotData2D","text":"ScalarPlotData2D(u, semi::AbstractSemidiscretization; kwargs...)\n\nReturns an PlotData2DTriangulated object which is used to visualize a single scalar field. u should be an array whose entries correspond to values of the scalar field at nodal points.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.SummaryCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.SummaryCallback","text":"SummaryCallback()\n\nCreate and return a callback that prints a human-readable summary of the simulation setup at the beginning of a simulation and then resets the timer. When the returned callback is executed directly, the current timer values are shown.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.TrivialCallback-Tuple{}","page":"Trixi.jl","title":"Trixi.TrivialCallback","text":"TrivialCallback()\n\nA callback that does nothing. This can be useful to disable some callbacks easily via trixi_include.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.adapt_to_mesh_level!-Tuple{Any, Any, Any}","page":"Trixi.jl","title":"Trixi.adapt_to_mesh_level!","text":"adapt_to_mesh_level!(u_ode, semi, level)\nadapt_to_mesh_level!(sol::Trixi.TrixiODESolution, level)\n\nLike adapt_to_mesh_level, but modifies the solution and parts of the semidiscretization (mesh and caches) in place.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}","page":"Trixi.jl","title":"Trixi.adapt_to_mesh_level","text":"adapt_to_mesh_level(u_ode, semi, level)\nadapt_to_mesh_level(sol::Trixi.TrixiODESolution, level)\n\nUse the regular adaptive mesh refinement routines to adaptively refine/coarsen the solution u_ode with semidiscretization semi towards a uniformly refined grid with refinement level level. The solution and semidiscretization are copied such that the original objects remain unaltered.\n\nA convenience method accepts an ODE solution object, from which solution and semidiscretization are extracted as needed.\n\nSee also: adapt_to_mesh_level!\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_x","text":"boundary_condition_linear_x(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation1D)\n\nBoundary conditions for initial_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_linear_x-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_x","text":"boundary_condition_linear_x(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation2D)\n\nBoundary conditions for initial_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_linear_x_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_x_y","text":"boundary_condition_linear_x_y(u_inner, orientation, direction, x, t,\n                              surface_flux_function,\n                              equation::LinearScalarAdvectionEquation2D)\n\nBoundary conditions for initial_condition_linear_x_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_linear_y-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_y","text":"boundary_condition_linear_y(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation2D)\n\nBoundary conditions for initial_condition_linear_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_linear_z-Tuple{Any, Any, Any, Any, Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_linear_z","text":"boundary_condition_linear_z(u_inner, orientation, direction, x, t,\n                            surface_flux_function,\n                            equation::LinearScalarAdvectionEquation1D)\n\nBoundary conditions for boundary_condition_linear_z.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_noslip_wall-Tuple{Any, Any, Any, Any, Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_noslip_wall","text":"boundary_condition_noslip_wall(u_inner, orientation, direction, x, t,\n                               surface_flux_function,\n                               equations::LatticeBoltzmannEquations2D)\n\nNo-slip wall boundary condition using the bounce-back approach.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_poisson_nonperiodic-Tuple{Any, Any, Any, Any, Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.boundary_condition_poisson_nonperiodic","text":"boundary_condition_poisson_nonperiodic(u_inner, orientation, direction, x, t,\n                                       surface_flux_function,\n                                       equations::HyperbolicDiffusionEquations1D)\n\nBoundary conditions used for convergence tests in combination with initial_condition_poisson_nonperiodic and source_terms_poisson_nonperiodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,\n                             equations::AcousticPerturbationEquations2D)\n\nUse an orthogonal projection of the perturbed velocities to zero out the normal velocity while retaining the possibility of a tangential velocity in the boundary state. Further details are available in the paper:\n\nMarcus Bauer, Jürgen Dierke and Roland Ewert (2011) Application of a discontinuous Galerkin method to discretize acoustic perturbation equations DOI: 10.2514/1.J050333\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, normal_direction, direction, x, t,\n                             surface_flux_function, equations::CompressibleEulerEquations2D)\n\nShould be used together with StructuredMesh.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, normal_direction, direction, x, t,\n                             surface_flux_function, equations::CompressibleEulerEquations3D)\n\nShould be used together with StructuredMesh.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,\n                             equations::CompressibleEulerEquations2D)\n\nDetermine the boundary numerical surface flux for a slip wall condition. Imposes a zero normal velocity at the wall. Density is taken from the internal solution state and pressure is computed as an exact solution of a 1D Riemann problem. Further details about this boundary state are available in the paper:\n\nJ. J. W. van der Vegt and H. van der Ven (2002) Slip flow boundary conditions in discontinuous Galerkin discretizations of the Euler equations of gas dynamics PDF\n\nDetails about the 1D pressure Riemann solution can be found in Section 6.3.3 of the book\n\nEleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Pratical Introduction 3rd edition DOI: 10.1007/b79761\n\nShould be used together with UnstructuredMesh2D.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,\n                             equations::CompressibleEulerEquations3D)\n\nDetermine the boundary numerical surface flux for a slip wall condition. Imposes a zero normal velocity at the wall. Density is taken from the internal solution state and pressure is computed as an exact solution of a 1D Riemann problem. Further details about this boundary state are available in the paper:\n\nJ. J. W. van der Vegt and H. van der Ven (2002) Slip flow boundary conditions in discontinuous Galerkin discretizations of the Euler equations of gas dynamics PDF\n\nDetails about the 1D pressure Riemann solution can be found in Section 6.3.3 of the book\n\nEleuterio F. Toro (2009) Riemann Solvers and Numerical Methods for Fluid Dynamics: A Pratical Introduction 3rd edition DOI: 10.1007/b79761\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, AbstractVector, Any, Any, Any, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, normal_direction, x, t, surface_flux_function,\n                             equations::ShallowWaterEquations2D)\n\nCreate a boundary state by reflecting the normal velocity component and keep the tangential velocity component unchanged. The boundary water height is taken from the internal value. For details see Section 9.2.5 of the book:\n\nEleuterio F. Toro (2001) Shock-Capturing Methods for Free-Surface Shallow Flows 1st edition ISBN 0471987662\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, orientation, direction, x, t,\n                             surface_flux_function, equations::CompressibleEulerEquations2D)\n\nShould be used together with TreeMesh.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, orientation, direction, x, t,\n                             surface_flux_function, equations::CompressibleEulerEquations3D)\n\nShould be used together with TreeMesh.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, orientation_or_normal, x, t, surface_flux_function,\n                              equations::ShallowWaterEquations1D)\n\nCreate a boundary state by reflecting the normal velocity component and keep the tangential velocity component unchanged. The boundary water height is taken from the internal value.\n\nFor details see Section 9.2.5 of the book:\n\nEleuterio F. Toro (2001) Shock-Capturing Methods for Free-Surface Shallow Flows 1st edition ISBN 0471987662\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_slip_wall-Tuple{Any, Any, Any, Any, Any, Any, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_slip_wall","text":"boundary_condition_slip_wall(u_inner, orientation, direction, x, t,\n                             surface_flux_function, equations::ShallowWaterEquations2D)\n\nShould be used together with TreeMesh.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_wall","text":"boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,\n                        equations::AcousticPerturbationEquations2D)\n\nBoundary conditions for a solid wall.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.boundary_condition_wall-Tuple{Any, Any, Any, Any, Any, Any, LinearizedEulerEquations2D}","page":"Trixi.jl","title":"Trixi.boundary_condition_wall","text":"boundary_condition_wall(u_inner, orientation, direction, x, t, surface_flux_function,\n                            equations::LinearizedEulerEquations2D)\n\nBoundary conditions for a solid wall.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.calc_error_norms-Tuple{Any, Any, Any, Trixi.AbstractSemidiscretization, Any}","page":"Trixi.jl","title":"Trixi.calc_error_norms","text":"calc_error_norms([func=(u_node,equations)->u_node,] u_ode, t, analyzer, semi::AbstractSemidiscretization, cache_analysis)\n\nCalculate discrete L2 and L∞ error norms of func applied to each nodal variable u_node in u_ode. If no exact solution is available, \"errors\" are calculated using some reference state and can be useful for regression tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.calc_fast_wavespeed_roe","text":"calc_fast_wavespeed_roe(u_ll, u_rr, direction, equations::IdealGlmMhdEquations1D)\n\nCompute the fast magnetoacoustic wave speed using Roe averages as given by\n\nCargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws DOI: 10.1006/jcph.1997.5773\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.calc_fast_wavespeed_roe","text":"calc_fast_wavespeed_roe(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations2D)\n\nCompute the fast magnetoacoustic wave speed using Roe averages as given by\n\nCargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws DOI: 10.1006/jcph.1997.5773\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.calc_fast_wavespeed_roe-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.calc_fast_wavespeed_roe","text":"calc_fast_wavespeed_roe(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations3D)\n\nCompute the fast magnetoacoustic wave speed using Roe averages as given by\n\nCargo and Gallice (1997) Roe Matrices for Ideal MHD and Systematic Construction of Roe Matrices for Systems of Conservation Laws DOI: 10.1006/jcph.1997.5773\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.collision_bgk","text":"collision_bgk(u, dt, equations::LatticeBoltzmannEquations2D)\n\nCollision operator for the Bhatnagar, Gross, and Krook (BGK) model.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.collision_bgk-Tuple{Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.collision_bgk","text":"collision_bgk(u, dt, equations::LatticeBoltzmannEquations3D)\n\nCollision operator for the Bhatnagar, Gross, and Krook (BGK) model.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.cons2cons-Tuple{Any, AbstractEquations}","page":"Trixi.jl","title":"Trixi.cons2cons","text":"cons2cons(u, equations)\n\nReturn the conserved variables u. While this function is as trivial as identity, it is also as useful.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.cons2entropy","page":"Trixi.jl","title":"Trixi.cons2entropy","text":"cons2entropy(u, equations)\n\nConvert the conserved variables u to the entropy variables for a given set of equations with chosen standard entropy. u is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by entropy2cons.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.cons2prim","page":"Trixi.jl","title":"Trixi.cons2prim","text":"cons2prim(u, equations)\n\nConvert the conserved variables u to the primitive variables for a given set of equations. u is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by prim2cons.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.convergence_test-Tuple{Module, AbstractString, Any}","page":"Trixi.jl","title":"Trixi.convergence_test","text":"convergence_test([mod::Module=Main,] elixir::AbstractString, iterations; kwargs...)\n\nRun iterations Trixi simulations using the setup given in elixir and compute the experimental order of convergence (EOC) in the L^2 and L^infty norm. In each iteration, the resolution of the respective mesh will be doubled. Additional keyword arguments kwargs... and the optional module mod are passed directly to trixi_include.\n\nThis function assumes that the spatial resolution is set via the keywords initial_refinement_level (an integer) or cells_per_dimension (a tuple of integers, one per spatial dimension).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.default_analysis_integrals-Tuple{AbstractEquations}","page":"Trixi.jl","title":"Trixi.default_analysis_integrals","text":"default_analysis_integrals(equations)\n\nDefault analysis integrals used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.default_example-Tuple{}","page":"Trixi.jl","title":"Trixi.default_example","text":"default_example()\n\nReturn the path to an example elixir that can be used to quickly see Trixi in action on a [TreeMesh]@(ref). See also examples_dir and get_examples.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.default_example_unstructured-Tuple{}","page":"Trixi.jl","title":"Trixi.default_example_unstructured","text":"default_example_unstructured()\n\nReturn the path to an example elixir that can be used to quickly see Trixi in action on an [UnstructuredMesh2D]@(ref). This simulation is run on the example curved, unstructured mesh given in the Trixi documentation regarding unstructured meshes.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.density-Tuple{Real, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.density","text":"density(p::Real, equations::LatticeBoltzmannEquations2D)\ndensity(u, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic density from the pressure p or the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.density-Tuple{Real, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.density","text":"density(p::Real, equations::LatticeBoltzmannEquations3D)\ndensity(u, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic density from the pressure p or the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.each_dof_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}","page":"Trixi.jl","title":"Trixi.each_dof_global","text":"each_dof_global(mesh::DGMultiMesh, dg::DGMulti, other_args...)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the degrees of freedom (DOF) in dg.  In particular, not the DOFs themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.each_face_node-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}","page":"Trixi.jl","title":"Trixi.each_face_node","text":"each_face_node(mesh::DGMultiMesh, dg::DGMulti, other_args...)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the face nodes in dg.  In particular, not the face_nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.each_face_node_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}","page":"Trixi.jl","title":"Trixi.each_face_node_global","text":"each_face_node_global(mesh::DGMultiMesh, dg::DGMulti, other_args...)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the face nodes in mesh.  In particular, not the face nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.each_quad_node-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}","page":"Trixi.jl","title":"Trixi.each_quad_node","text":"each_quad_node(mesh::DGMultiMesh, dg::DGMulti, other_args...)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the quadrature nodes in dg.  In particular, not the quadrature nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.each_quad_node_global-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}","page":"Trixi.jl","title":"Trixi.each_quad_node_global","text":"each_quad_node_global(mesh::DGMultiMesh, dg::DGMulti, other_args...)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the global quadrature nodes in mesh.  In particular, not the quadrature nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachboundary-Tuple{DG, Any}","page":"Trixi.jl","title":"Trixi.eachboundary","text":"eachboundary(dg::DG, cache)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the boundaries in cache.  In particular, not the boundaries themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachcomponent-Tuple{Trixi.AbstractCompressibleEulerMulticomponentEquations}","page":"Trixi.jl","title":"Trixi.eachcomponent","text":"eachcomponent(equations::AbstractCompressibleEulerMulticomponentEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the components in AbstractCompressibleEulerMulticomponentEquations.  In particular, not the components themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachcomponent-Tuple{Trixi.AbstractIdealGlmMhdMulticomponentEquations}","page":"Trixi.jl","title":"Trixi.eachcomponent","text":"eachcomponent(equations::AbstractIdealGlmMhdMulticomponentEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the components in AbstractIdealGlmMhdMulticomponentEquations.  In particular, not the components themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachdim-Tuple{Any}","page":"Trixi.jl","title":"Trixi.eachdim","text":"eachdim(mesh)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the dimensions in AbstractTree. In particular, not the dimensions themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachdirection-Tuple{Trixi.AbstractTree}","page":"Trixi.jl","title":"Trixi.eachdirection","text":"eachdirection(tree::AbstractTree)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the directions in AbstractTree.  In particular, not the directions themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachelement-Tuple{DG, Any}","page":"Trixi.jl","title":"Trixi.eachelement","text":"eachelement(dg::DG, cache)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the elements in cache.  In particular, not the elements themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachelement-Tuple{DGMultiMesh, DGMulti{NDIMS, ElemType, ApproxType} where {NDIMS, ElemType, ApproxType}, Vararg{Any}}","page":"Trixi.jl","title":"Trixi.eachelement","text":"eachelement(mesh::DGMultiMesh, dg::DGMulti, other_args...)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the elements in mesh.  In particular, not the elements themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachelement-Tuple{Trixi.ElementContainer1D}","page":"Trixi.jl","title":"Trixi.eachelement","text":"eachelement(elements::ElementContainer1D)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the elements in elements.  In particular, not the elements themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachelement-Tuple{Trixi.ElementContainer2D}","page":"Trixi.jl","title":"Trixi.eachelement","text":"eachelement(elements::ElementContainer2D)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the elements in elements.  In particular, not the elements themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachelement-Tuple{Trixi.ElementContainer3D}","page":"Trixi.jl","title":"Trixi.eachelement","text":"eachelement(elements::ElementContainer3D)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the elements in elements.  In particular, not the elements themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachelement-Tuple{Trixi.UnstructuredElementContainer2D}","page":"Trixi.jl","title":"Trixi.eachelement","text":"eachelement(elements::UnstructuredElementContainer2D)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the elements in elements.  In particular, not the elements themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachinterface-Tuple{DG, Any}","page":"Trixi.jl","title":"Trixi.eachinterface","text":"eachinterface(dg::DG, cache)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the interfaces in cache.  In particular, not the interfaces themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachmortar-Tuple{DG, Any}","page":"Trixi.jl","title":"Trixi.eachmortar","text":"eachmortar(dg::DG, cache)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the mortars in cache.  In particular, not the mortars themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachmpiinterface-Tuple{DG, Any}","page":"Trixi.jl","title":"Trixi.eachmpiinterface","text":"eachmpiinterface(dg::DG, cache)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the MPI interfaces in cache.  In particular, not the interfaces themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachmpimortar-Tuple{DG, Any}","page":"Trixi.jl","title":"Trixi.eachmpimortar","text":"eachmpimortar(dg::DG, cache)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the MPI mortars in cache.  In particular, not the mortars themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachnode-Tuple{DG}","page":"Trixi.jl","title":"Trixi.eachnode","text":"eachnode(dg::DG)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the nodes in dg.  In particular, not the nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachnode-Tuple{LobattoLegendreBasis}","page":"Trixi.jl","title":"Trixi.eachnode","text":"eachnode(basis::LobattoLegendreBasis)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the nodes in basis.  In particular, not the nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachnode-Tuple{Trixi.LobattoLegendreAnalyzer}","page":"Trixi.jl","title":"Trixi.eachnode","text":"eachnode(analyzer::LobattoLegendreAnalyzer)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the nodes in analyzer.  In particular, not the nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.eachvariable-Tuple{AbstractEquations}","page":"Trixi.jl","title":"Trixi.eachvariable","text":"eachvariable(equations::AbstractEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the variables in equations. In particular, not the variables themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.entropy","page":"Trixi.jl","title":"Trixi.entropy","text":"entropy(u, equations)\n\nReturn the chosen entropy of the conserved variables u for a given set of equations.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.entropy2cons","page":"Trixi.jl","title":"Trixi.entropy2cons","text":"entropy2cons(w, equations)\n\nConvert the entropy variables w based on a standard entropy to the conserved variables for a given set of equations. u is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by cons2entropy.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.equilibrium_distribution","text":"equilibrium_distribution(alpha, rho, v1, v2, v3, equations::LatticeBoltzmannEquations3D)\n\nCalculate the local equilibrium distribution for the distribution function with index alpha and given the macroscopic state defined by rho, v1, v2, v3.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.equilibrium_distribution-Tuple{Any, Any, Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.equilibrium_distribution","text":"equilibrium_distribution(alpha, rho, v1, v2, equations::LatticeBoltzmannEquations2D)\n\nCalculate the local equilibrium distribution for the distribution function with index alpha and given the macroscopic state defined by rho, v1, v2.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.examples_dir-Tuple{}","page":"Trixi.jl","title":"Trixi.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with Trixi.jl are located. If Trixi is installed as a regular package (with ]add Trixi), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir:\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux","page":"Trixi.jl","title":"Trixi.flux","text":"flux(u, orientation_or_normal, equations)\n\nGiven the conservative variables u, calculate the (physical) flux in Cartesian direction orientation::Integer or in arbitrary direction normal::AbstractVector for the corresponding set of governing equations. orientation is 1, 2, and 3 for the x-, y-, and z-directions, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.flux-Tuple{Any, AbstractVector, AbstractEquations{1}}","page":"Trixi.jl","title":"Trixi.flux","text":"flux(u, normal_direction::AbstractVector, equations::AbstractEquations{1})\n\nEnables calling flux with a non-integer argument normal_direction for one-dimensional equations. Returns the value of flux(u, 1, equations) scaled by normal_direction[1].\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_central-Tuple{Any, Any, Any, AbstractEquations}","page":"Trixi.jl","title":"Trixi.flux_central","text":"flux_central(u_ll, u_rr, orientation_or_normal_direction, equations::AbstractEquations)\n\nThe classical central numerical flux f((u_ll) + f(u_rr)) / 2. When this flux is used as volume flux, the discretization is equivalent to the classical weak form DG method (except floating point errors).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nEntropy conserving two-point flux by\n\nChandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations DOI: 10.4208/cicp.170712.010313a\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)\n\nEntropy conserving two-point flux by\n\nChandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations DOI: 10.4208/cicp.170712.010313a\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)\n\nEntropy conserving two-point flux by\n\nChandrashekar (2013) Kinetic Energy Preserving and Entropy Stable Finite Volume Schemes for Compressible Euler and Navier-Stokes Equations DOI: 10.4208/cicp.170712.010313a\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations1D)\n\nEntropy conserving two-point flux by\n\nAyoub Gouasmi, Karthik Duraisamy (2020) \"Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations\"\" arXiv:1904.00972v3 [math.NA] 4 Feb 2020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_chandrashekar","text":"flux_chandrashekar(u_ll, u_rr, orientation, equations::CompressibleEulerMulticomponentEquations2D)\n\nAdaption of the entropy conserving two-point flux by\n\nAyoub Gouasmi, Karthik Duraisamy (2020) \"Formulation of Entropy-Stable schemes for the multicomponent compressible Euler equations\"\" arXiv:1904.00972v3 [math.NA] 4 Feb 2020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)\n\nEntropy conserving two-point flux by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)\n\nEntropy conserving two-point flux by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations3D)\n\nEntropy conserving two-point flux by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)\n\nEntropy conserving two-point flux adapted by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_derigs_etal-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_derigs_etal","text":"flux_derigs_etal(u_ll, u_rr, orientation, equations::IdealGlmMhdMulticomponentEquations2D)\n\nEntropy conserving two-point flux adapted by\n\nDerigs et al. (2018) Ideal GLM-MHD: About the entropy consistent nine-wave magnetic field divergence diminishing ideal magnetohydrodynamics equations for multicomponent DOI: 10.1016/j.jcp.2018.03.002\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.flux_fjordholm_etal","text":"flux_fjordholm_etal(u_ll, u_rr, orientation,\n                    equations::ShallowWaterEquations1D)\n\nTotal energy conservative (mathematical entropy for shallow water equations). When the bottom topography is nonzero this should only be used as a surface flux otherwise the scheme will not be well-balanced. For well-balancedness in the volume flux use flux_wintermeyer_etal.\n\nDetails are available in Eq. (4.1) in the paper:\n\nUlrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography DOI: 10.1016/j.jcp.2011.03.042\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.flux_fjordholm_etal","text":"flux_fjordholm_etal(u_ll, u_rr, orientation_or_normal_direction,\n                    equations::ShallowWaterEquations2D)\n\nTotal energy conservative (mathematical entropy for shallow water equations). When the bottom topography is nonzero this should only be used as a surface flux otherwise the scheme will not be well-balanced. For well-balancedness in the volume flux use flux_wintermeyer_etal.\n\nDetails are available in Eq. (4.1) in the paper:\n\nUlrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography DOI: 10.1016/j.jcp.2011.03.042\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang_gassner","text":"flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,\n                        equations::IdealGlmMhdEquations1D)\n\nEntropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang_gassner","text":"flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,\n                        equations::IdealGlmMhdEquations2D)\n\nEntropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang_gassner","text":"flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,\n                        equations::IdealGlmMhdEquations3D)\n\nEntropy conserving and kinetic energy preserving two-point flux of Hindenlang and Gassner (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang_gassner","text":"flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,\n                        equations::IdealGlmMhdMulticomponentEquations1D)\n\nAdaption of the entropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hindenlang_gassner-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_hindenlang_gassner","text":"flux_hindenlang_gassner(u_ll, u_rr, orientation_or_normal_direction,\n                        equations::IdealGlmMhdMulticomponentEquations2D)\n\nAdaption of the entropy conserving and kinetic energy preserving two-point flux of Hindenlang (2019), extending flux_ranocha to the MHD equations.\n\nReferences\n\nFlorian Hindenlang, Gregor Gassner (2019) A new entropy conservative two-point flux for ideal MHD equations derived from first principles. Presented at HONOM 2019: European workshop on high order numerical methods for evolutionary PDEs, theory and applications\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_hllc","text":"flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nComputes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro Lecture slides Signal speeds: DOI: 10.1137/S1064827593260140\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_hllc","text":"flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)\n\nComputes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro Lecture slides Signal speeds: DOI: 10.1137/S1064827593260140\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hllc-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_hllc","text":"flux_hllc(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)\n\nComputes the HLLC flux (HLL with Contact) for compressible Euler equations developed by E.F. Toro Lecture slides Signal speeds: DOI: 10.1137/S1064827593260140\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hlle-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_hlle","text":"flux_hlle(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nComputes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.\n\nOriginal publication:\n\nBernd Einfeldt (1988) On Godunov-type methods for gas dynamics. DOI: 10.1137/0725021\n\nCompactly summarized:\n\nSiddhartha Mishra, Ulrik Skre Fjordholm and Rémi Abgrall Numerical methods for conservation laws and related equations. Link\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hlle-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_hlle","text":"flux_hlle(u_ll, u_rr, orientation, equations::CompressibleEulerEquations2D)\n\nComputes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.\n\nBernd Einfeldt (1988) On Godunov-type methods for gas dynamics. DOI: 10.1137/0725021\nBernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. DOI: 10.1016/0021-9991(91)90211-3\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_hlle-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_hlle","text":"flux_hlle(u_ll, u_rr, orientation, equations::CompressibleEulerEquations3D)\n\nComputes the HLLE (Harten-Lax-van Leer-Einfeldt) flux for the compressible Euler equations. Special estimates of the signal velocites and linearization of the Riemann problem developed by Einfeldt to ensure that the internal energy and density remain positive during the computation of the numerical flux.\n\nBernd Einfeldt (1988) On Godunov-type methods for gas dynamics. DOI: 10.1137/0725021\nBernd Einfeldt, Claus-Dieter Munz, Philip L. Roe and Björn Sjögreen (1991) On Godunov-type methods near low densities. DOI: 10.1016/0021-9991(91)90211-3\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,\n                    equations::CompressibleEulerEquations2D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_kennedy_gruber","text":"flux_kennedy_gruber(u_ll, u_rr, orientation_or_normal_direction,\n                    equations::CompressibleEulerEquations3D)\n\nKinetic energy preserving two-point flux by\n\nKennedy and Gruber (2008) Reduced aliasing formulations of the convective terms within the Navier-Stokes equations for a compressible fluid DOI: 10.1016/j.jcp.2007.09.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_audusse_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_audusse_etal","text":"flux_nonconservative_audusse_etal(u_ll, u_rr, orientation::Integer,\n                                  equations::ShallowWaterEquations1D)\n\nNon-symmetric two-point surface flux that discretizes the nonconservative (source) term. The discretization uses the hydrostatic_reconstruction_audusse_etal on the conservative variables.\n\nThis hydrostatic reconstruction ensures that the finite volume numerical fluxes remain well-balanced for discontinuous bottom topographies ShallowWaterEquations1D. Should be used together with FluxHydrostaticReconstruction and hydrostatic_reconstruction_audusse_etal in the surface flux to ensure consistency.\n\nFurther details on the hydrostatic reconstruction and its motivation can be found in\n\nEmmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows DOI: 10.1137/S1064827503431090\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_audusse_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_audusse_etal","text":"flux_nonconservative_audusse_etal(u_ll, u_rr, orientation::Integer,\n                                  equations::ShallowWaterEquations2D)\nflux_nonconservative_audusse_etal(u_ll, u_rr,\n                                  normal_direction_ll     ::AbstractVector,\n                                  normal_direction_average::AbstractVector,\n                                  equations::ShallowWaterEquations2D)\n\nNon-symmetric two-point surface flux that discretizes the nonconservative (source) term. The discretization uses the hydrostatic_reconstruction_audusse_etal on the conservative variables.\n\nThis hydrostatic reconstruction ensures that the finite volume numerical fluxes remain well-balanced for discontinuous bottom topographies ShallowWaterEquations2D. Should be used together with FluxHydrostaticReconstruction and hydrostatic_reconstruction_audusse_etal in the surface flux to ensure consistency.\n\nFurther details for the hydrostatic reconstruction and its motivation can be found in\n\nEmmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows DOI: 10.1137/S1064827503431090\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_fjordholm_etal","text":"flux_nonconservative_fjordholm_etal(u_ll, u_rr, orientation::Integer,\n                                    equations::ShallowWaterEquations1D)\n\nNon-symmetric two-point surface flux discretizing the nonconservative (source) term of that contains the gradient of the bottom topography ShallowWaterEquations1D.\n\nThis contains additional terms compared to flux_nonconservative_wintermeyer_etal that account for possible discontinuities in the bottom topography function. Thus, this flux should be used in general at interfaces. For flux differencing volume terms, flux_nonconservative_wintermeyer_etal is analytically equivalent but slightly cheaper.\n\nFurther details for the original finite volume formulation are available in\n\nUlrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography DOI: 10.1016/j.jcp.2011.03.042\n\nand for curvilinear 2D case in the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_fjordholm_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_fjordholm_etal","text":"flux_nonconservative_fjordholm_etal(u_ll, u_rr, orientation::Integer,\n                                    equations::ShallowWaterEquations2D)\nflux_nonconservative_fjordholm_etal(u_ll, u_rr,\n                                    normal_direction_ll     ::AbstractVector,\n                                    normal_direction_average::AbstractVector,\n                                    equations::ShallowWaterEquations2D)\n\nNon-symmetric two-point surface flux discretizing the nonconservative (source) term of that contains the gradient of the bottom topography ShallowWaterEquations2D.\n\nOn curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.\n\nThis contains additional terms compared to flux_nonconservative_wintermeyer_etal that account for possible discontinuities in the bottom topography function. Thus, this flux should be used in general at interfaces. For flux differencing volume terms, flux_nonconservative_wintermeyer_etal is analytically equivalent but slightly cheaper.\n\nFurther details for the original finite volume formulation are available in\n\nUlrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography DOI: 10.1016/j.jcp.2011.03.042\n\nand for curvilinear 2D case in the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_powell","text":"flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,\n                            equations::IdealGlmMhdEquations2D)\nflux_nonconservative_powell(u_ll, u_rr,\n                            normal_direction_ll     ::AbstractVector,\n                            normal_direction_average::AbstractVector,\n                            equations::IdealGlmMhdEquations2D)\n\nNon-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the IdealGlmMhdEquations2D.\n\nOn curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.\n\nReferences\n\nMarvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification DOI: 10.1016/j.jcp.2018.06.027\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_powell","text":"flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,\n                            equations::IdealGlmMhdEquations3D)\nflux_nonconservative_powell(u_ll, u_rr,\n                            normal_direction_ll     ::AbstractVector,\n                            normal_direction_average::AbstractVector,\n                            equations::IdealGlmMhdEquations3D)\n\nNon-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the IdealGlmMhdEquations3D.\n\nOn curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.\n\nReferences\n\nMarvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification DOI: 10.1016/j.jcp.2018.06.027\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_powell-Tuple{Any, Any, Integer, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_powell","text":"flux_nonconservative_powell(u_ll, u_rr, orientation::Integer,\n                            equations::IdealGlmMhdMulticomponentEquations2D)\n\nNon-symmetric two-point flux discretizing the nonconservative (source) term of Powell and the Galilean nonconservative term associated with the GLM multiplier of the IdealGlmMhdMulticomponentEquations2D.\n\nReferences\n\nMarvin Bohm, Andrew R.Winters, Gregor J. Gassner, Dominik Derigs, Florian Hindenlang, Joachim Saur An entropy stable nodal discontinuous Galerkin method for the resistive MHD equations. Part I: Theory and numerical verification DOI: 10.1016/j.jcp.2018.06.027\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_wintermeyer_etal","text":"flux_nonconservative_wintermeyer_etal(u_ll, u_rr, orientation::Integer,\n                                      equations::ShallowWaterEquations1D)\n\nNon-symmetric two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography ShallowWaterEquations1D.\n\nFurther details are available in the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_nonconservative_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.flux_nonconservative_wintermeyer_etal","text":"flux_nonconservative_wintermeyer_etal(u_ll, u_rr, orientation::Integer,\n                                      equations::ShallowWaterEquations2D)\nflux_nonconservative_wintermeyer_etal(u_ll, u_rr,\n                                      normal_direction_ll     ::AbstractVector,\n                                      normal_direction_average::AbstractVector,\n                                      equations::ShallowWaterEquations2D)\n\nNon-symmetric two-point volume flux discretizing the nonconservative (source) term that contains the gradient of the bottom topography ShallowWaterEquations2D.\n\nOn curvilinear meshes, this nonconservative flux depends on both the contravariant vector (normal direction) at the current node and the averaged one. This is different from numerical fluxes used to discretize conservative terms.\n\nFurther details are available in the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction, equations::CompressibleEulerEquations1D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerEquations2D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerEquations3D)\n\nEntropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerMulticomponentEquations1D)\n\nAdaption of the entropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.flux_ranocha","text":"flux_ranocha(u_ll, u_rr, orientation_or_normal_direction,\n             equations::CompressibleEulerMulticomponentEquations2D)\n\nAdaption of the entropy conserving and kinetic energy preserving two-point flux by\n\nHendrik Ranocha (2018) Generalised Summation-by-Parts Operators and Entropy Stability of Numerical Methods for Hyperbolic Balance Laws PhD thesis, TU Braunschweig\n\nSee also\n\nHendrik Ranocha (2020) Entropy Conserving and Kinetic Energy Preserving Numerical Methods for the Euler Equations Using Summation-by-Parts Operators Proceedings of ICOSAHOM 2018\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_ranocha_turbo-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.flux_ranocha_turbo","text":"flux_ranocha_turbo(u_ll, u_rr, orientation_or_normal_direction, equations)\n\nEquivalent to flux_ranocha except that it may use specialized methods, e.g., when used with VolumeIntegralFluxDifferencing. These specialized methods may enable better use of SIMD instructions to increase runtime efficiency on modern hardware.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.flux_shima_etal","text":"flux_shima_etal(u_ll, u_rr, orientation, equations::CompressibleEulerEquations1D)\n\nThis flux is is a modification of the original kinetic energy preserving two-point flux by\n\nYuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms DOI: 10.1016/j.jcp.2018.08.058\n\nThe modification is in the energy flux to guarantee pressure equilibrium and was developed by\n\nNao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows DOI: 10.1016/j.jcp.2020.110060\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.flux_shima_etal","text":"flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,\n                equations::CompressibleEulerEquations2D)\n\nThis flux is is a modification of the original kinetic energy preserving two-point flux by\n\nYuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms DOI: 10.1016/j.jcp.2018.08.058\n\nThe modification is in the energy flux to guarantee pressure equilibrium and was developed by\n\nNao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows DOI: 10.1016/j.jcp.2020.110060\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.flux_shima_etal","text":"flux_shima_etal(u_ll, u_rr, orientation_or_normal_direction,\n                equations::CompressibleEulerEquations3D)\n\nThis flux is is a modification of the original kinetic energy preserving two-point flux by\n\nYuichi Kuya, Kosuke Totani and Soshi Kawai (2018) Kinetic energy and entropy preserving schemes for compressible flows by split convective forms DOI: 10.1016/j.jcp.2018.08.058\n\nThe modification is in the energy flux to guarantee pressure equilibrium and was developed by\n\nNao Shima, Yuichi Kuya, Yoshiharu Tamaki, Soshi Kawai (JCP 2020) Preventing spurious pressure oscillations in split convective form discretizations for compressible flows DOI: 10.1016/j.jcp.2020.110060\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_shima_etal_turbo-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.flux_shima_etal_turbo","text":"flux_shima_etal_turbo(u_ll, u_rr, orientation_or_normal_direction, equations)\n\nEquivalent to flux_shima_etal except that it may use specialized methods, e.g., when used with VolumeIntegralFluxDifferencing. These specialized methods may enable better use of SIMD instructions to increase runtime efficiency on modern hardware.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.flux_wintermeyer_etal","text":"flux_wintermeyer_etal(u_ll, u_rr, orientation,\n                      equations::ShallowWaterEquations1D)\n\nTotal energy conservative (mathematical entropy for shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a volume_flux. The surface_flux should still use, e.g., flux_fjordholm_etal.\n\nFurther details are available in Theorem 1 of the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, Integer, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.flux_wintermeyer_etal","text":"flux_wintermeyer_etal(u_ll, u_rr, orientation_or_normal_direction,\n                      equations::ShallowWaterEquations2D)\n\nTotal energy conservative (mathematical entropy for shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a volume_flux. The surface_flux should still use, e.g., flux_fjordholm_etal.\n\nFurther details are available in Theorem 1 of the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.get_examples-Tuple{}","page":"Trixi.jl","title":"Trixi.get_examples","text":"get_examples()\n\nReturn a list of all example elixirs that are provided by Trixi. See also examples_dir and default_example.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.get_name-Tuple{AbstractEquations}","page":"Trixi.jl","title":"Trixi.get_name","text":"get_name(equations::AbstractEquations)\n\nReturns the canonical, human-readable name for the given system of equations.\n\nExamples\n\njulia> Trixi.get_name(CompressibleEulerEquations1D(1.4))\n\"CompressibleEulerEquations1D\"\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.get_name-Tuple{Any}","page":"Trixi.jl","title":"Trixi.get_name","text":"get_name(x)\n\nReturns a name of x ready for pretty printing. By default, return string(y) if x isa Val{y} and return string(x) otherwise.\n\nExamples\n\njulia> Trixi.get_name(\"test\")\n\"test\"\n\njulia> Trixi.get_name(Val(:test))\n\"test\"\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.getmesh-Tuple{Trixi.AbstractPlotData}","page":"Trixi.jl","title":"Trixi.getmesh","text":"getmesh(pd::AbstractPlotData)\n\nExtract grid lines from pd for plotting with Plots.plot.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.global_mean_vars-Tuple{AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.global_mean_vars","text":"global_mean_vars(equations::AcousticPerturbationEquations2D)\n\nReturns the global mean variables stored in equations. This makes it easier to define flexible initial conditions for problems with constant mean flow.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.have_nonconservative_terms-Tuple{AbstractEquations}","page":"Trixi.jl","title":"Trixi.have_nonconservative_terms","text":"have_nonconservative_terms(equations)\n\nTrait function determining whether equations represent a conservation law with or without nonconservative terms. Classical conservation laws such as the CompressibleEulerEquations2D do not have nonconservative terms. The ShallowWaterEquations2D with non-constant bottom topography are an example of equations with nonconservative terms. The return value will be True() or False() to allow dispatching on the return type.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.hydrostatic_reconstruction_audusse_etal","text":"hydrostatic_reconstruction_audusse_etal(u_ll, u_rr, orientation::Integer,\n                                        equations::ShallowWaterEquations1D)\n\nA particular type of hydrostatic reconstruction on the water height to guarantee well-balancedness for a general bottom topography ShallowWaterEquations1D. The reconstructed solution states u_ll_star and u_rr_star variables are used to evaluate the surface numerical flux at the interface. Use in combination with the generic numerical flux routine FluxHydrostaticReconstruction.\n\nFurther details on this hydrostatic reconstruction and its motivation can be found in\n\nEmmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows DOI: 10.1137/S1064827503431090\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.hydrostatic_reconstruction_audusse_etal-Tuple{Any, Any, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.hydrostatic_reconstruction_audusse_etal","text":"hydrostatic_reconstruction_audusse_etal(u_ll, u_rr, orientation_or_normal_direction,\n                                        equations::ShallowWaterEquations2D)\n\nA particular type of hydrostatic reconstruction on the water height to guarantee well-balancedness for a general bottom topography ShallowWaterEquations2D. The reconstructed solution states u_ll_star and u_rr_star variables are used to evaluate the surface numerical flux at the interface. Use in combination with the generic numerical flux routine FluxHydrostaticReconstruction.\n\nFurther details for the hydrostatic reconstruction and its motivation can be found in\n\nEmmanuel Audusse, François Bouchut, Marie-Odile Bristeau, Rupert Klein, and Benoit Perthame (2004) A fast and stable well-balanced scheme with hydrostatic reconstruction for shallow water flows DOI: 10.1137/S1064827503431090\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.init_mpi-Tuple{}","page":"Trixi.jl","title":"Trixi.init_mpi","text":"init_mpi()\n\nInitialize MPI by calling MPI.Initialized(). The function will check if MPI is already initialized and if yes, do nothing, thus it is safe to call it multiple times.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.init_p4est-Tuple{}","page":"Trixi.jl","title":"Trixi.init_p4est","text":"init_p4est()\n\nInitialize p4est by calling p4est_init and setting the log level to SC_LP_ERROR. This function will check if p4est is already initialized and if yes, do nothing, thus it is safe to call it multiple times.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::AcousticPerturbationEquations2D)\n\nA constant initial condition where the state variables are zero and the mean flow is constant. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::CompressibleEulerEquations1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::CompressibleEulerEquations2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::CompressibleEulerEquations3D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::IdealGlmMhdEquations1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::IdealGlmMhdEquations2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initialconditionconstant(x, t, equations::IdealGlmMhdEquations3D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::InviscidBurgersEquation1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LatticeBoltzmannEquations2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LatticeBoltzmannEquations3D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_constant-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_constant","text":"initial_condition_constant(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA constant initial condition to test free-stream preservation.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::AcousticPerturbationEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations1D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerEquations3D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::CompressibleEulerMulticomponentEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations1D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations2D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdEquations3D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations1D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::IdealGlmMhdMulticomponentEquations2D)\n\nAn Alfvén wave as smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::InviscidBurgersEquation1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA smooth initial condition used for convergence tests (in combination with BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, LinearizedEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::LinearizedEulerEquations2D)\n\nA smooth initial condition used for convergence tests.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_convergence_test-Tuple{Any, Any, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::ShallowWaterEquations2D)\n\nA smooth initial condition used for convergence tests in combination with source_terms_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_wave","text":"initial_condition_density_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper\n\nGregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes arXiv: 2007.09026\n\nwith the following parameters\n\ndomain [-1, 1]\nmesh = 4x4\npolydeg = 5\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_density_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_density_wave","text":"initial_condition_density_wave(x, t, equations::CompressibleEulerEquations2D)\n\nA sine wave in the density with constant velocity and pressure; reduces the compressible Euler equations to the linear advection equations. This setup is the test case for stability of EC fluxes from paper\n\nGregor J. Gassner, Magnus Svärd, Florian J. Hindenlang (2020) Stability issues of entropy-stable and/or split-form high-order schemes arXiv: 2007.09026\n\nwith the following parameters\n\ndomain [-1, 1]\nmesh = 4x4\npolydeg = 5\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations1D)\n\nOne dimensional variant of the setup used for convergence tests of the Euler equations with self-gravity from\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nnote: Note\nThere is no additional source term necessary for the manufactured solution in one spatial dimension. Thus, source_terms_eoc_test_coupled_euler_gravity is not present there.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_eoc_test_coupled_euler_gravity or source_terms_eoc_test_euler.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::CompressibleEulerEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_eoc_test_coupled_euler_gravity or source_terms_eoc_test_euler.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations1D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_harmonic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_harmonic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_eoc_test_coupled_euler_gravity-Tuple{Any, Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_eoc_test_coupled_euler_gravity","text":"initial_condition_eoc_test_coupled_euler_gravity(x, t, equations::HyperbolicDiffusionEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with source_terms_harmonic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_gauss-Tuple{Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equations::AcousticPerturbationEquations2D)\n\nA Gaussian pulse in a constant mean flow. Uses the global mean values from equations.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA Gaussian pulse used together with BoundaryConditionDirichlet(initial_condition_gauss).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equation::LinearScalarAdvectionEquation2D)\n\nA Gaussian pulse used together with BoundaryConditionDirichlet(initial_condition_gauss).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_gauss-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_gauss","text":"initial_condition_gauss(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA Gaussian pulse.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_x","text":"initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA linear function of x[1] used together with boundary_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_linear_x-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_x","text":"initial_condition_linear_x(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA linear function of x[1] used together with boundary_condition_linear_x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_linear_x_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_x_y","text":"initial_condition_linear_x_y(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA linear function of x[1] + x[2] used together with boundary_condition_linear_x_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_linear_y-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_y","text":"initial_condition_linear_y(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA linear function of x[1] used together with boundary_condition_linear_y.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_linear_z-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_linear_z","text":"initial_condition_linear_z(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA linear function of x[3] used together with boundary_condition_linear_z.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_poisson_nonperiodic-Tuple{Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_poisson_nonperiodic","text":"initial_condition_poisson_nonperiodic(x, t, equations::HyperbolicDiffusionEquations1D)\n\nA non-priodic smooth initial condition. Can be used for convergence tests in combination with source_terms_poisson_nonperiodic and boundary_condition_poisson_nonperiodic.\n\nnote: Note\nThe solution is periodic but the initial guess is not.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation1D}","page":"Trixi.jl","title":"Trixi.initial_condition_sin","text":"initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA sine wave in the conserved variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_sin-Tuple{Any, Any, LinearScalarAdvectionEquation3D}","page":"Trixi.jl","title":"Trixi.initial_condition_sin","text":"initial_condition_sin(x, t, equations::LinearScalarAdvectionEquation1D)\n\nA sine wave in the conserved variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_sin_sin-Tuple{Any, Any, LinearScalarAdvectionEquation2D}","page":"Trixi.jl","title":"Trixi.initial_condition_sin_sin","text":"initial_condition_sin_sin(x, t, equations::LinearScalarAdvectionEquation2D)\n\nA sine wave in the conserved variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations1D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations2D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerEquations3D)\n\nA weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nA for multicomponent adapted weak blast wave adapted to multicomponent and taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::CompressibleEulerMulticomponentEquations2D)\n\nA for multicomponent adapted weak blast wave taken from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations1D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations2D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdEquations3D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations1D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, IdealGlmMhdMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::IdealGlmMhdMulticomponentEquations2D)\n\nA weak blast wave adapted from\n\nSebastian Hennemann, Gregor J. Gassner (2020) A provably entropy stable subcell shock capturing approach for high order split form DG arXiv: 2008.12044\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, ShallowWaterEquations1D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::ShallowWaterEquations1D)\n\nA weak blast wave discontinuity useful for testing, e.g., total energy conservation. Note for the shallow water equations to the total energy acts as a mathematical entropy function.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.initial_condition_weak_blast_wave-Tuple{Any, Any, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.initial_condition_weak_blast_wave","text":"initial_condition_weak_blast_wave(x, t, equations::ShallowWaterEquations2D)\n\nA weak blast wave discontinuity useful for testing, e.g., total energy conservation. Note for the shallow water equations to the total energy acts as a mathematical entropy function.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.integrate_via_indices-Union{Tuple{Func}, Tuple{Func, Any, Trixi.AbstractSemidiscretization, Vararg{Any}}} where Func","page":"Trixi.jl","title":"Trixi.integrate_via_indices","text":"integrate_via_indices(func, u_ode, semi::AbstractSemidiscretization, args...; normalize=true)\n\nCall func(u, i..., element, equations, solver, args...) for all nodal indices i..., element and integrate the result using a quadrature associated with the semidiscretization semi.\n\nIf normalize is true, the result is divided by the total volume of the computational domain.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.inv_ln_mean-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.inv_ln_mean","text":"inv_ln_mean(x, y)\n\nCompute the inverse 1 / ln_mean(x, y) of the logarithmic mean ln_mean.\n\nThis function may be used to increase performance where the inverse of the logarithmic mean is needed, by replacing a (slow) division by a (fast) multiplication.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.jacobian_ad_forward-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.jacobian_ad_forward","text":"jacobian_ad_forward(semi::AbstractSemidiscretization;\n                    t0=zero(real(semi)),\n                    u0_ode=compute_coefficients(t0, semi))\n\nUses the right-hand side operator of the semidiscretization semi and forward mode automatic differentiation to compute the Jacobian J of the semidiscretization semi at state u0_ode.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.jacobian_fd-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.jacobian_fd","text":"jacobian_fd(semi::AbstractSemidiscretization;\n            t0=zero(real(semi)),\n            u0_ode=compute_coefficients(t0, semi))\n\nUses the right-hand side operator of the semidiscretization semi and simple second order finite difference to compute the Jacobian J of the semidiscretization semi at state u0_ode.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.linear_structure-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.linear_structure","text":"linear_structure(semi::AbstractSemidiscretization;\n                 t0=zero(real(semi)))\n\nWraps the right-hand side operator of the semidiscretization semi at time t0 as an affine-linear operator given by a linear operator A and a vector b.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ln_mean-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.ln_mean","text":"ln_mean(x, y)\n\nCompute the logarithmic mean\n\nln_mean(x, y) = (y - x) / (log(y) - log(x)) = (y - x) / log(y / x)\n\nProblem: The formula above has a removable singularity at x == y. Thus, some care must be taken to implement it correctly without problems or loss of accuracy when x ≈ y. Here, we use the approach proposed by Ismail and Roe (2009). Set ξ = y / x. Then, we have\n\n(y - x) / log(y / x) = (x + y) / log(ξ) * (ξ - 1) / (ξ + 1)\n\nSet f = (ξ - 1) / (ξ + 1) = (y - x) / (x + y). Then, we use the expansion\n\nlog(ξ) = 2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7) + O(ξ^9)\n\nInserting the first few terms of this expansion yields\n\n(y - x) / log(ξ) ≈ (x + y) * f / (2 * f * (1 + f^2 / 3 + f^4 / 5 + f^6 / 7))\n                 = (x + y) / (2 + 2/3 * f^2 + 2/5 * f^4 + 2/7 * f^6)\n\nSince divisions are usually more expensive on modern hardware than multiplications (Agner Fog), we try to avoid computing two divisions. Thus, we use\n\nf^2 = (y - x)^2 / (x + y)^2\n    = (x * (x - 2 * y) + y * y) / (x * (x + 2 * y) + y * y)\n\nGiven ε = 1.0e-4, we use the following algorithm.\n\nif f^2 < ε\n  # use the expansion above\nelse\n  # use the direct formula (y - x) / log(y / x)\nend\n\nReferences\n\nIsmail, Roe (2009). Affordable, entropy-consistent Euler flux functions II: Entropy production at shocks. DOI: 10.1016/j.jcp.2009.04.021\nAgner Fog. Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD, and VIA CPUs. https://www.agner.org/optimize/instruction_tables.pdf\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.load_mesh-Tuple{AbstractString}","page":"Trixi.jl","title":"Trixi.load_mesh","text":"load_mesh(restart_file::AbstractString; n_cells_max)\n\nLoad the mesh from the restart_file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.load_time-Tuple{AbstractString}","page":"Trixi.jl","title":"Trixi.load_time","text":"load_time(restart_file::AbstractString)\n\nLoad the time saved in a restart_file.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.max-Tuple","page":"Trixi.jl","title":"Trixi.max","text":"max(x, y, ...)\n\nReturn the maximum of the arguments. See also the maximum function to take the maximum element from a collection.\n\nThis version in Trixi.jl is semantically equivalent to Base.max but may be implemented differently. In particular, it may avoid potentially expensive checks necessary in the presence of NaNs (or signed zeros).\n\nExamples\n\njulia> max(2, 5, 1) 5\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.max_abs_speed_naive","page":"Trixi.jl","title":"Trixi.max_abs_speed_naive","text":"max_abs_speed_naive(u_ll, u_rr, orientation::Integer,   equations)\nmax_abs_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)\n\nSimple and fast estimate of the maximal wave speed of the Riemann problem with left and right states u_ll, u_rr, based only on the local wave speeds associated to u_ll and u_rr.\n\nFor non-integer arguments normal_direction in one dimension, max_abs_speed_naive returns abs(normal_direction[1]) * max_abs_speed_naive(u_ll, u_rr, 1, equations).\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.min-Tuple","page":"Trixi.jl","title":"Trixi.min","text":"min(x, y, ...)\n\nReturn the minimum of the arguments. See also the minimum function to take the minimum element from a collection.\n\nThis version in Trixi.jl is semantically equivalent to Base.min but may be implemented differently. In particular, it may avoid potentially expensive checks necessary in the presence of NaNs (or signed zeros).\n\nExamples\n\njulia> min(2, 5, 1) 1\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.min_max_speed_naive","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation::Integer,   equations)\nmin_max_speed_naive(u_ll, u_rr, normal_direction::AbstractVector, equations)\n\nSimple and fast estimate of the minimal and maximal wave speed of the Riemann problem with left and right states u_ll, u_rr, usually based only on the local wave speeds associated to u_ll and u_rr.\n\nAmiram Harten, Peter D. Lax, Bram van Leer (1983) On Upstream Differencing and Godunov-Type Schemes for Hyperbolic Conservation Laws DOI: 10.1137/1025002\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations1D}","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations1D)\n\nCalculate minimum and maximum wave speeds for HLL-type fluxes as in\n\nLi (2005) An HLLC Riemann solver for magneto-hydrodynamics DOI: 10.1016/j.jcp.2004.08.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations2D}","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation, equations::IdealGlmMhdEquations2D)\n\nCalculate minimum and maximum wave speeds for HLL-type fluxes as in\n\nLi (2005) An HLLC Riemann solver for magneto-hydrodynamics DOI: 10.1016/j.jcp.2004.08.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.min_max_speed_naive-Tuple{Any, Any, Integer, IdealGlmMhdEquations3D}","page":"Trixi.jl","title":"Trixi.min_max_speed_naive","text":"min_max_speed_naive(u_ll, u_rr, orientation_or_normal_direction, equations::IdealGlmMhdEquations3D)\n\nCalculate minimum and maximum wave speeds for HLL-type fluxes as in\n\nLi (2005) An HLLC Riemann solver for magneto-hydrodynamics DOI: 10.1016/j.jcp.2004.08.020\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.multiply_dimensionwise-Tuple{AbstractMatrix, AbstractMatrix}","page":"Trixi.jl","title":"Trixi.multiply_dimensionwise","text":"multiply_dimensionwise(matrix::AbstractMatrix, data_in::AbstractArray{<:Any, NDIMS+1})\n\nMultiply the array data_in by matrix in each coordinate direction, where data_in is assumed to have the first coordinate for the number of variables and the remaining coordinates are multiplied by matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ndofs-Tuple{Trixi.AbstractSemidiscretization}","page":"Trixi.jl","title":"Trixi.ndofs","text":"ndofs(semi::AbstractSemidiscretization)\n\nReturn the number of degrees of freedom associated with each scalar variable.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.negative_part-Tuple{Any}","page":"Trixi.jl","title":"Trixi.negative_part","text":"negative_part(x)\n\nReturn x if x is negative, else zero. In other words, return (x - abs(x)) / 2 for real numbers x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ode_norm-Tuple{Number, Any}","page":"Trixi.jl","title":"Trixi.ode_norm","text":"ode_norm(u, t)\n\nImplementation of the weighted L2 norm of Hairer and Wanner used for error-based step size control in OrdinaryDiffEq.jl. This function is aware of MPI and uses global MPI communication when running in parallel.\n\nYou must pass this function as a keyword argument internalnorm=ode_norm to OrdinaryDiffEq.jl's solve when using error-based step size control with MPI parallel execution of Trixi.jl.\n\nSee https://diffeq.sciml.ai/stable/basics/common_solver_opts/#advanced_adaptive_stepsize_control\n\nwarning: Experimental code\nThis code is experimental and may be changed or removed in any future release.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.ode_unstable_check-NTuple{4, Any}","page":"Trixi.jl","title":"Trixi.ode_unstable_check","text":"ode_unstable_check(dt, u, semi, t)\n\nImplementation of the basic check for instability used in OrdinaryDiffEq.jl. Instead of checking something like any(isnan, u), this function just checks isnan(dt). This helps when using MPI parallelization, since no additional global communication is required and all ranks will return the same result.\n\nYou should pass this function as a keyword argument unstable_check=ode_unstable_check to OrdinaryDiffEq.jl's  solve when using error-based step size control with MPI parallel execution of Trixi.jl.\n\nSee https://diffeq.sciml.ai/stable/basics/common_solver_opts/#Miscellaneous\n\nwarning: Experimental code\nThis code is experimental and may be changed or removed in any future release.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.partition!-Tuple{TreeMesh{NDIMS, <:Trixi.ParallelTree{NDIMS}} where NDIMS}","page":"Trixi.jl","title":"Trixi.partition!","text":"partition!(mesh::ParallelTreeMesh, allow_coarsening=true)\n\nPartition mesh using a static domain decomposition algorithm based on leaf cell count and tree structure. If allow_coarsening is true, the algorithm will keep leaf cells together on one rank when needed for local coarsening (i.e. when all children of a cell are leaves).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.positive_part-Tuple{Any}","page":"Trixi.jl","title":"Trixi.positive_part","text":"positive_part(x)\n\nReturn x if x is positive, else zero. In other words, return (x + abs(x)) / 2 for real numbers x.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.pressure","text":"pressure(rho::Real, equations::LatticeBoltzmannEquations2D)\npressure(u, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic pressure from the density rho or the  particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.pressure-Tuple{Real, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.pressure","text":"pressure(rho::Real, equations::LatticeBoltzmannEquations3D)\npressure(u, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic pressure from the density rho or the  particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.prim2cons","page":"Trixi.jl","title":"Trixi.prim2cons","text":"prim2cons(u, equations)\n\nConvert the primitive variables u to the conserved variables for a given set of equations. u is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by cons2prim.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.residual_steady_state-Tuple{Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.residual_steady_state","text":"residual_steady_state(du, ::AbstractHyperbolicDiffusionEquations)\n\nUsed to determine the termination criterion of a SteadyStateCallback. For hyperbolic diffusion, this checks convergence of the potential phi.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.rotate_from_x","page":"Trixi.jl","title":"Trixi.rotate_from_x","text":"rotate_from_x(u, normal, equations)\n\nApply the rotation that maps the x-axis onto normal to the convservative variables u. This is used by FluxRotated to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.\n\nSee also: rotate_to_x\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.rotate_to_x","page":"Trixi.jl","title":"Trixi.rotate_to_x","text":"rotate_to_x(u, normal, equations)\n\nApply the rotation that maps normal onto the x-axis to the convservative variables u. This is used by FluxRotated to calculate the numerical flux of rotationally invariant equations in arbitrary normal directions.\n\nSee also: rotate_from_x\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.save_plot-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.save_plot","text":"save_plot(plot_data, variable_names;\n          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),\n          time=nothing, timestep=nothing)\n\nVisualize the plot data object provided in plot_data and save result as a PNG file in the out directory, plotting only the variables in variable_names and, optionally, the mesh (if show_mesh is true).  Additionally, plot_arguments will be unpacked and passed as keyword arguments to the Plots.plot command.\n\nThe timestep is used in the filename. time is currently unused by this function.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: VisualizationCallback, show_plot\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.show_plot-Tuple{Any, Any}","page":"Trixi.jl","title":"Trixi.show_plot","text":"show_plot(plot_data, variable_names;\n          show_mesh=true, plot_arguments=Dict{Symbol,Any}(),\n          time=nothing, timestep=nothing)\n\nVisualize the plot data object provided in plot_data and display result, plotting only the variables in variable_names and, optionally, the mesh (if show_mesh is true).  Additionally, plot_arguments will be unpacked and passed as keyword arguments to the Plots.plot command.\n\nThis function is the default plot_creator argument for the VisualizationCallback. time and timestep are currently unused by this function.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nSee also: VisualizationCallback, save_plot\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, AcousticPerturbationEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"sourcetermsconvergence_test(u, x, t, equations::AcousticPerturbationEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerEquations3D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::CompressibleEulerMulticomponentEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::InviscidBurgersEquation1D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_convergence_test-Tuple{Any, Any, Any, ShallowWaterEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_convergence_test","text":"source_terms_convergence_test(u, x, t, equations::ShallowWaterEquations2D)\n\nSource terms used for convergence tests in combination with initial_condition_convergence_test (and BoundaryConditionDirichlet(initial_condition_convergence_test) in non-periodic domains).\n\nThis manufactured solution source term is specifically designed for the bottom topography function b(x,y) = 2 + 0.5 * sin(sqrt(2)*pi*x) + 0.5 * sin(sqrt(2)*pi*y) as defined in initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_coupled_euler_gravity","text":"source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_eoc_test_coupled_euler_gravity-Tuple{Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_coupled_euler_gravity","text":"source_terms_eoc_test_coupled_euler_gravity(u, x, t, equations::CompressibleEulerEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_euler","text":"source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations2D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_eoc_test_euler-Tuple{Any, Any, Any, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_eoc_test_euler","text":"source_terms_eoc_test_euler(u, x, t, equations::CompressibleEulerEquations3D)\n\nSetup used for convergence tests of the Euler equations with self-gravity used in\n\nMichael Schlottke-Lakemper, Andrew R. Winters, Hendrik Ranocha, Gregor J. Gassner (2020) A purely hyperbolic discontinuous Galerkin approach for self-gravitating gas dynamics arXiv: 2008.10593\n\nin combination with initial_condition_eoc_test_coupled_euler_gravity.\n\nnote: Note\nThis method is to be used for testing pure Euler simulations with analytic self-gravity. If you intend to do coupled Euler-gravity simulations, you need to use source_terms_eoc_test_coupled_euler_gravity instead.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_harmonic","text":"source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations1D)\n\nSource term that only includes the forcing from the hyperbolic diffusion system.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations2D}","page":"Trixi.jl","title":"Trixi.source_terms_harmonic","text":"source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations2D)\n\nSource term that only includes the forcing from the hyperbolic diffusion system.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_harmonic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations3D}","page":"Trixi.jl","title":"Trixi.source_terms_harmonic","text":"source_terms_harmonic(u, x, t, equations::HyperbolicDiffusionEquations3D)\n\nSource term that only includes the forcing from the hyperbolic diffusion system.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.source_terms_poisson_nonperiodic-Tuple{Any, Any, Any, HyperbolicDiffusionEquations1D}","page":"Trixi.jl","title":"Trixi.source_terms_poisson_nonperiodic","text":"source_terms_poisson_nonperiodic(u, x, t,\n                                 equations::HyperbolicDiffusionEquations1D)\n\nSource terms that include the forcing function f(x) and right hand side for the hyperbolic diffusion system that is used with initial_condition_poisson_nonperiodic and boundary_condition_poisson_nonperiodic.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_coirier_vanleer-Tuple{Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.splitting_coirier_vanleer","text":"splitting_coirier_vanleer(u, orientation::Integer,\n                          equations::CompressibleEulerEquations1D)\nsplitting_coirier_vanleer(u, which::Union{Val{:minus}, Val{:plus}}\n                          orientation::Integer,\n                          equations::CompressibleEulerEquations1D)\n\nSplitting of the compressible Euler flux from Coirier and van Leer. The splitting has correction terms in the pressure splitting as well as the mass and energy flux components. The motivation for these corrections are to handle flows at the low Mach number limit.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nWilliam Coirier and Bram van Leer (1991) Numerical flux formulas for the Euler and Navier-Stokes equations. II - Progress in flux-vector splitting DOI: 10.2514/6.1991-1566\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_lax_friedrichs-Tuple{Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.splitting_lax_friedrichs","text":"splitting_lax_friedrichs(u, orientation::Integer,\n                         equations::CompressibleEulerEquations2D)\nsplitting_lax_friedrichs(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::CompressibleEulerEquations2D)\n\nNaive local Lax-Friedrichs style flux splitting of the form f⁺ = 0.5 (f + λ u) and f⁻ = 0.5 (f - λ u) similar to a flux splitting one would apply, e.g., to Burgers' equation.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_lax_friedrichs-Tuple{Any, Integer, InviscidBurgersEquation1D}","page":"Trixi.jl","title":"Trixi.splitting_lax_friedrichs","text":"splitting_lax_friedrichs(u, orientation::Integer,\n                         equations::InviscidBurgersEquation1D)\nsplitting_lax_friedrichs(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::InviscidBurgersEquation1D)\n\nNaive local Lax-Friedrichs style flux splitting of the form f⁺ = 0.5 (f + λ u) and f⁻ = 0.5 (f - λ u) where λ = abs(u).\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.splitting_steger_warming","text":"splitting_steger_warming(u, orientation::Integer,\n                         equations::CompressibleEulerEquations1D)\nsplitting_steger_warming(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::CompressibleEulerEquations1D)\n\nSplitting of the compressible Euler flux of Steger and Warming.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nJoseph L. Steger and R. F. Warming (1979) Flux Vector Splitting of the Inviscid Gasdynamic Equations With Application to Finite Difference Methods NASA Technical Memorandum\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.splitting_steger_warming","text":"splitting_steger_warming(u, orientation::Integer,\n                         equations::CompressibleEulerEquations2D)\nsplitting_steger_warming(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::CompressibleEulerEquations2D)\n\nSplitting of the compressible Euler flux of Steger and Warming.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nJoseph L. Steger and R. F. Warming (1979) Flux Vector Splitting of the Inviscid Gasdynamic Equations With Application to Finite Difference Methods NASA Technical Memorandum\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_steger_warming-Tuple{Any, Integer, CompressibleEulerEquations3D}","page":"Trixi.jl","title":"Trixi.splitting_steger_warming","text":"splitting_steger_warming(u, orientation::Integer,\n                         equations::CompressibleEulerEquations3D)\nsplitting_steger_warming(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::CompressibleEulerEquations3D)\n\nSplitting of the compressible Euler flux of Steger and Warming.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nJoseph L. Steger and R. F. Warming (1979) Flux Vector Splitting of the Inviscid Gasdynamic Equations With Application to Finite Difference Methods NASA Technical Memorandum\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_vanleer_haenel-Tuple{Any, Integer, CompressibleEulerEquations1D}","page":"Trixi.jl","title":"Trixi.splitting_vanleer_haenel","text":"splitting_vanleer_haenel(u, orientation::Integer,\n                         equations::CompressibleEulerEquations1D)\nsplitting_vanleer_haenel(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::CompressibleEulerEquations1D)\n\nSplitting of the compressible Euler flux from van Leer. This splitting further contains a reformulation due to Hänel et al. where the energy flux uses the enthalpy. The pressure splitting is independent from the splitting of the convective terms. As such there are many pressure splittings suggested across the literature. We implement the 'p4' variant suggested by Liou and Steffen as it proved the most robust in practice.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nBram van Leer (1982) Flux-Vector Splitting for the Euler Equation DOI: 10.1007/978-3-642-60543-7_5\nD. Hänel, R. Schwane and G. Seider (1987) On the accuracy of upwind schemes for the solution of the Navier-Stokes equations DOI: 10.2514/6.1987-1105\nMeng-Sing Liou and Chris J. Steffen, Jr. (1991) High-Order Polynomial Expansions (HOPE) for Flux-Vector Splitting NASA Technical Memorandum\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.splitting_vanleer_haenel-Tuple{Any, Integer, CompressibleEulerEquations2D}","page":"Trixi.jl","title":"Trixi.splitting_vanleer_haenel","text":"splitting_vanleer_haenel(u, orientation::Integer,\n                         equations::CompressibleEulerEquations2D)\nsplitting_vanleer_haenel(u, which::Union{Val{:minus}, Val{:plus}}\n                         orientation::Integer,\n                         equations::CompressibleEulerEquations2D)\n\nSplitting of the compressible Euler flux from van Leer. This splitting further contains a reformulation due to Hänel et al. where the energy flux uses the enthalpy. The pressure splitting is independent from the splitting of the convective terms. As such there are many pressure splittings suggested across the literature. We implement the 'p4' variant suggested by Liou and Steffen as it proved the most robust in practice.\n\nReturns a tuple of the fluxes \"minus\" (associated with waves going into the negative axis direction) and \"plus\" (associated with waves going into the positive axis direction). If only one of the fluxes is required, use the function signature with argument which set to Val{:minus}() or Val{:plus}.\n\nwarning: Experimental implementation (upwind SBP)\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nBram van Leer (1982) Flux-Vector Splitting for the Euler Equation DOI: 10.1007/978-3-642-60543-7_5\nD. Hänel, R. Schwane and G. Seider (1987) On the accuracy of upwind schemes for the solution of the Navier-Stokes equations DOI: 10.2514/6.1987-1105\nMeng-Sing Liou and Chris J. Steffen, Jr. (1991) High-Order Polynomial Expansions (HOPE) for Flux-Vector Splitting NASA Technical Memorandum\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations1D}","page":"Trixi.jl","title":"Trixi.totalgamma","text":"totalgamma(u, equations::CompressibleEulerMulticomponentEquations1D)\n\nFunction that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.totalgamma-Tuple{Any, CompressibleEulerMulticomponentEquations2D}","page":"Trixi.jl","title":"Trixi.totalgamma","text":"totalgamma(u, equations::CompressibleEulerMulticomponentEquations2D)\n\nFunction that calculates the total gamma out of all partial gammas using the partial density fractions as well as the partial specific heats at constant volume.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.trixi_include-Tuple{Module, AbstractString}","page":"Trixi.jl","title":"Trixi.trixi_include","text":"trixi_include([mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. It's basic purpose is to make it easier to modify some parameters while running Trixi from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve and Trixi.solve with it's default value used in the SciML ecosystem for ODEs, see https://diffeq.sciml.ai/stable/basics/commonsolveropts/#Miscellaneous.\n\nExamples\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.uses_amr-Tuple{Any}","page":"Trixi.jl","title":"Trixi.uses_amr","text":"uses_amr(callback)\n\nChecks whether the provided callback or CallbackSet is an AMRCallback or contains one.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.varnames","page":"Trixi.jl","title":"Trixi.varnames","text":"varnames(conversion_function, equations)\n\nReturn the list of variable names when applying conversion_function to the conserved variables associated to equations. This function is mainly used internally to determine output to screen and for IO, e.g., for the AnalysisCallback and the SaveSolutionCallback. Common choices of the conversion_function are cons2cons and cons2prim.\n\n\n\n\n\n","category":"function"},{"location":"reference-trixi.html#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, orientation, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic velocity for the given orientation (1 -> x, 2 -> y) from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.velocity-Tuple{Any, Integer, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, orientation, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic velocity for the given orientation (1 -> x, 2 -> y, 3 -> z) from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations2D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, equations::LatticeBoltzmannEquations2D)\n\nCalculate the macroscopic velocity vector from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.velocity-Tuple{Any, LatticeBoltzmannEquations3D}","page":"Trixi.jl","title":"Trixi.velocity","text":"velocity(u, equations::LatticeBoltzmannEquations3D)\n\nCalculate the macroscopic velocity vector from the particle distribution functions u.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixi.html#Trixi.@threaded-Tuple{Any}","page":"Trixi.jl","title":"Trixi.@threaded","text":"@threaded for ... end\n\nSemantically the same as Threads.@threads when iterating over a AbstractUnitRange but without guarantee that the underlying implementation uses Threads.@threads or works for more general for loops. In particular, there may be an additional check whether only one thread is used to reduce the overhead of serial execution or the underlying threading capabilities might be provided by other packages such as Polyester.jl.\n\nwarn: Warn\nThis macro does not necessarily work for general for loops. For example, it does not necessarily support general iterables such as eachline(filename).\n\nSome discussion can be found at https://discourse.julialang.org/t/overhead-of-threads-threads/53964 and https://discourse.julialang.org/t/threads-threads-with-one-thread-how-to-remove-the-overhead/58435.\n\n\n\n\n\n","category":"macro"},{"location":"styleguide.html#Style-guide","page":"Style guide","title":"Style guide","text":"","category":"section"},{"location":"styleguide.html","page":"Style guide","title":"Style guide","text":"The following lists a few coding conventions for Trixi:","category":"page"},{"location":"styleguide.html","page":"Style guide","title":"Style guide","text":"Modules, types, structs with CamelCase.\nFunctions, variables with lowercase snake_case.\nIndentation with 2 spaces (never tabs!), line continuations indented with 4 spaces.\nMaximum line length (strictly): 100.\nFunctions that mutate their input are named with a trailing !.\nFunctions order their parameters similar to Julia Base.\nThe main modified argument comes first. For example, if the right-hand side du is modified,  it should come first. If only the cache is modified, e.g., in prolong2interfaces!  and its siblings, put the cache first.\nOtherwise, use the order mesh, equations, solver, cache.\nIf something needs to be specified in more detail for dispatch, put the additional argument before the general one  that is specified in more detail. For example, we use have_nonconservative_terms(equations), equations and dg.mortar, dg.\nPrefer for i in ... to for i = ... for better semantic clarity and greater flexibility.\nExecutable code should only use ASCII characters.\nDocstrings and comments can and should use Unicode characters where it helps understanding.\nMultiline expressions should be explicitly grouped by parentheses and not rely on Julia's implicit line continuation syntax.\nWhen naming multiple functions of a single or similar category, prefer to put the general classification first and the specialization second. Example: Use flux_central instead of central_flux. This helps when searching for available functions on the REPL (e.g., when trying to find all flux functions).","category":"page"},{"location":"styleguide.html","page":"Style guide","title":"Style guide","text":"Based on that, and personal experience, a formatting tool with a few helpful options is included in utils/julia-format.jl. Note, however, that this tool is not yet optimal, as it re-indents too greedily.","category":"page"},{"location":"styleguide.html","page":"Style guide","title":"Style guide","text":"This is a list of handy style guides that are mostly consistent with each other and this guide, and which have been used as a basis:","category":"page"},{"location":"styleguide.html","page":"Style guide","title":"Style guide","text":"https://www.juliaopt.org/JuMP.jl/stable/style/\nhttps://github.com/jrevels/YASGuide","category":"page"},{"location":"overview.html#Overview-of-the-structure-of-Trixi","page":"Overview","title":"Overview of the structure of Trixi","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Trixi is designed as a library of components for discretizations of hyperbolic conservation laws. Thus, it is not a monolithic PDE solver that is configured at runtime via parameter files, as it is often found in classical numerical simulation codes. Instead, each simulation is configured by pure Julia code. Many examples of such simulation setups, called elixirs in Trixi, are provided in the examples folder.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Trixi uses the method of lines, i.e., the full space-time discretization is separated into two steps; the spatial semidiscretization is performed at first and the resulting ODE system is solved numerically using a suitable time integration method. Thus, the main ingredients of an elixir designed to solve a PDE numerically are the spatial semidiscretization and the time integration scheme.","category":"page"},{"location":"overview.html#Semidiscretizations","page":"Overview","title":"Semidiscretizations","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Semidiscretizations are high-level descriptions of spatial discretizations specialized for certain PDEs. Trixi's main focus is on hyperbolic conservation laws represented in a SemidiscretizationHyperbolic. Such semidiscretizations are usually named semi in Trixi.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: semidiscretization_overview)","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"The basic building blocks of a semidiscretization are","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"a mesh describing the geometry of the domain\na set of equations describing the physical model\na solver describing the numerical approach","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"In addition, a semidiscretization bundles initial and boundary conditions, and possible source terms. These different ingredients of a semidiscretization can be configured individually and combined together. When a semidiscretization is constructed, it will create an internal cache, i.e., a collection of setup-specific data structures, that is usually passed to all lower level functions.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Due to Trixi's modular nature using Julia's multiple dispatch features, new ingredients can be created specifically for a certain combination of other ingredients. For example, a new mesh type can be created and implemented at first only for a specific solver. Thus, there is no need to consider all possible combinations of meshes, equations, and solvers when implementing new features. This allows rapid prototyping of new ideas and is one of the main design goals behind Trixi. Below is a brief overview of the availability of different features on different mesh types.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Feature TreeMesh StructuredMesh UnstructuredMesh2D P4estMesh DGMultiMesh Further reading\nSpatial dimension 1D, 2D, 3D 1D, 2D, 3D 2D 2D, 3D 1D, 2D, 3D \nCoordinates Cartesian curvilinear curvilinear curvilinear affine \nConnectivity h-nonconforming conforming conforming h-nonconforming conforming \nElement type line, square, cube line, quadᵃ, hexᵃ quadᵃ quadᵃ, hexᵃ simplex, quadᵃ, hexᵃ \nAdaptive mesh refinement ✅ ❌ ❌ ✅ ❌ AMRCallback\nSolver type DGSEM DGSEM DGSEM DGSEM DGMulti \nDomain hypercube mapped hypercube arbitrary arbitrary arbitraryᵇ \nWeak form ✅ ✅ ✅ ✅ ✅ VolumeIntegralWeakForm\nFlux differencing ✅ ✅ ✅ ✅ ✅ VolumeIntegralFluxDifferencing\nShock capturing ✅ ✅ ✅ ✅ ❌ VolumeIntegralShockCapturingHG\nNonconservative equations ✅ ✅ ✅ ✅ ✅ e.g., GLM MHD or shallow water equations","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"ᵃ: quad = quadrilateral, hex = hexahedron ᵇ: curved meshes supported for SBP and GaussSBP approximation types for VolumeIntegralFluxDifferencing solvers on quadrilateral and hexahedral DGMultiMeshes (non-conservative terms not yet supported)","category":"page"},{"location":"overview.html#Time-integration-methods","page":"Overview","title":"Time integration methods","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Trixi is compatible with the SciML ecosystem for ordinary differential equations. In particular, a spatial semidiscretization can be wrapped in an ODE problem using semidiscretize, which returns an ODEProblem. This ODEProblem is a wrapper of Trixi.rhs!(du_ode, u_ode, semi, t), which gets called in ODE solvers. Further information can be found in the section on time integration methods.","category":"page"},{"location":"overview.html#Next-steps","page":"Overview","title":"Next steps","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"We explicitly encourage people interested in Trixi to have a look at the examples bundled with Trixi to get an impression of what is possible and the general look and feel of Trixi. Before doing that, it is usually good to get an idea of how to visualize numerical results.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"If you like learning by doing, looking at the tutorials and trying to mix your own elixirs based thereon is probably a good next step. Otherwise, you can further dig into the documentation by looking at Trixi's basic building blocks.","category":"page"},{"location":"callbacks.html#callbacks-id","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Many of the advanced features of Trixi, such as adaptive mesh refinement, are implemented as callbacks. A callback is an algorithmic entity that gets passed to the ODE solver and is called at specific points during execution to perform certain tasks. Callbacks in Trixi are either called after each time step (step callbacks) or after each stage of the ODE solver (stage callbacks).","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"(Image: callbacks_illustration)","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"The advantage of callbacks over hard-coding all features is that it allows to extend Trixi without modifying the internal source code. Trixi provides callbacks for time step control, adaptive mesh refinement, I/O, and more.","category":"page"},{"location":"callbacks.html#Step-callbacks","page":"Callbacks","title":"Step callbacks","text":"","category":"section"},{"location":"callbacks.html#CFL-based-time-step-control","page":"Callbacks","title":"CFL-based time step control","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Time step control can be performed with a StepsizeCallback. An example making use of this can be found at examples/tree2ddgsem/elixir_advection_basic.jl","category":"page"},{"location":"callbacks.html#Adaptive-mesh-refinement","page":"Callbacks","title":"Adaptive mesh refinement","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Trixi uses a hierarchical Cartesian mesh which can be locally refined in a solution-adaptive way. This can be used to speed up simulations with minimal loss in overall accuracy. Adaptive mesh refinement (AMR) can be used by passing an AMRCallback to the ODE solver. The AMRCallback requires a controller such as ControllerThreeLevel or ControllerThreeLevelCombined to tell the AMR algorithm which cells to refine/coarsen.","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"An example elixir using AMR can be found at examples/tree2ddgsem/elixir_advection_amr.jl.","category":"page"},{"location":"callbacks.html#Analyzing-the-numerical-solution","page":"Callbacks","title":"Analyzing the numerical solution","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"The AnalysisCallback can be used to analyze the numerical solution, e.g. calculate errors or user-specified integrals, and print the results to the screen. The results can also be saved in a file. An example can be found at examples/tree2ddgsem/elixir_euler_vortex.jl. In  you can find a detailed description of the different performance metrics the AnalysisCallback computes.","category":"page"},{"location":"callbacks.html#I/O","page":"Callbacks","title":"I/O","text":"","category":"section"},{"location":"callbacks.html#Solution-and-restart-files","page":"Callbacks","title":"Solution and restart files","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"To save the solution in regular intervals you can use a SaveSolutionCallback. It is also possible to create restart files using the SaveRestartCallback. An example making use of these can be found at examples/tree2ddgsem/elixir_advection_extended.jl. An example showing how to restart a simulation from a restart file can be found at examples/tree2ddgsem/elixir_advection_restart.jl.","category":"page"},{"location":"callbacks.html#Time-series","page":"Callbacks","title":"Time series","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Sometimes it is useful to record the evoluation of state variables over time at a given set of points. This can be achieved by the TimeSeriesCallback, which is used, e.g., in examples/tree2ddgsem/elixir_acoustics_gaussian_source.jl. The TimeSeriesCallback constructor expects a semidiscretization and a list of points at which the solution should be recorded in regular time step intervals. After the last time step, the entire record is stored in an HDF5 file.","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"For the points, two different input formats are supported: You can either provide them as a list of tuples, which is handy if you specify them by hand on the REPL. Alternatively, you can provide them as a two-dimensional array, where the first dimension is the point number and the second dimension is the coordinate dimension. This is especially useful when reading them from a file.","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"For example, to record the primitive variables at the points (0.0, 0.0) and (-1.0, 0.5) every five timesteps and storing the collected data in the file tseries.h5, you can create the TimeSeriesCallback as","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"time_series = TimeSeriesCallback(semi, [(0.0, 0.0), (-1.0, 0.5)];\r\n                                 interval=5,\r\n                                 solution_variables=cons2prim,\r\n                                 filename=\"tseries.h5\")","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"For a full list of possible arguments, please check the documentation for the TimeSeriesCallback. As an alternative to specifying the point coordinates directly in the elixir or on the REPL, you can read them from a file. For instance, with a text file points.dat with content","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":" 0.0 0.0\r\n-1.0 0.5","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"you can create a time series callback with","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"using DelimitedFiles: readdlm\r\ntime_series = TimeSeriesCallback(semi, readdlm(\"points.dat\"))","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"To plot the individual point data series over time, you can create a PlotData1D from the TimeSeriesCallback and a given point ID. For example, executing","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"julia> using Trixi, Plots\r\n\r\njulia> trixi_include(joinpath(examples_dir(), \"tree_2d_dgsem\", \"elixir_acoustics_gaussian_source.jl\"))\r\n\r\njulia> pd1 = PlotData1D(time_series, 1)\r\n\r\njulia> pd2 = PlotData1D(time_series, 2)\r\n\r\njulia> plot(pd1[\"p_prime\"]); plot!(pd2[\"p_prime\"], xguide=\"t\")","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"will yield the following plot:","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"(Image: image)","category":"page"},{"location":"callbacks.html#Miscellaneous","page":"Callbacks","title":"Miscellaneous","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"The AliveCallback prints some information to the screen to show that a simulation is still running.\nThe SummaryCallback prints a human-readable summary of the simulation setup and controls the automated performance measurements, including an output of the recorded timers after a simulation.\nThe VisualizationCallback can be used for in-situ visualization. See Visualizing results during a simulation.\nThe TrivialCallback does nothing and can be used to to easily disable some callbacks via trixi_include.","category":"page"},{"location":"callbacks.html#Equation-specific-callbacks","page":"Callbacks","title":"Equation-specific callbacks","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Some callbacks provided by Trixi implement specific features for certain equations:","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"The LBMCollisionCallback implements the Lattice-Boltzmann method (LBM) collision operator and should only be used when solving the Lattice-Boltzmann equations. See e.g. examples/tree2ddgsem/elixir_lbm_constant.jl\nThe SteadyStateCallback terminates the time integration when the residual steady state falls below a certain threshold. This checks the convergence of the potential phi for hyperbolic diffusion. See e.g. examples/tree2ddgsem/elixir_hypdiff_nonperiodic.jl.\nThe GlmSpeedCallback updates the divergence cleaning wave speed c_h for the ideal GLM-MHD equations. See e.g. examples/tree2ddgsem/elixir_mhd_alfven_wave.jl.","category":"page"},{"location":"callbacks.html#Usage-of-step-callbacks","page":"Callbacks","title":"Usage of step callbacks","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Step callbacks are passed to the solve method from the ODE solver via the keyword argument callback. If you want to use a single callback cb, pass it as callback=cb. When using two or more callbacks, you need to turn them into a CallbackSet first by calling callbacks = CallbackSet(cb1, cb2) and passing it as callback=callbacks.","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"note: Note\nThere are some restrictions regarding the order of callbacks in a CallbackSet.The callbacks are called after each time step but some callbacks actually belong to the next time step. Therefore, the callbacks should be ordered in the following way:Callbacks that belong to the current time step:\nSummaryCallback controls, among other things, timers and should thus be first\nSteadyStateCallback may mark a time step as the last one\nAnalysisCallback may do some checks that mark a time step as the last one\nAliveCallback should be nearby AnalysisCallback\nSaveSolutionCallback/SaveRestartCallback should save the current solution before it is degraded by AMR\nVisualizationCallback should be called before the mesh is adapted\nCallbacks that belong to the next time step:\nAMRCallback\nStepsizeCallback must be called after AMRCallback to accomodate potential changes to the mesh\nGlmSpeedCallback must be called after StepsizeCallback because the step size affects the value of c_h\nLBMCollisionCallback is already part of the calculations of the next time step and should therefore be called after StepsizeCallback","category":"page"},{"location":"callbacks.html#Stage-callbacks","page":"Callbacks","title":"Stage callbacks","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"PositivityPreservingLimiterZhangShu is a positivity-preserving limiter, used to enforce physical constraints. An example elixir using this feature can be found at examples/tree2ddgsem/elixir_euler_positivity.jl.","category":"page"},{"location":"callbacks.html#Implementing-new-callbacks","page":"Callbacks","title":"Implementing new callbacks","text":"","category":"section"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"Since Trixi is compatible with OrdinaryDiffEq.jl, both packages share the same callback interface. A detailed description of it can be found in the OrdinaryDiffEq.jl documentation. Step callbacks are just called callbacks. Stage callbacks are called stage_limiter!.","category":"page"},{"location":"callbacks.html","page":"Callbacks","title":"Callbacks","text":"An example elixir showing how to implement a new simple stage callback and a new simple step callback can be found at examples/tree2ddgsem/elixir_advection_callbacks.jl.","category":"page"},{"location":"meshes/p4est_mesh.html#P4est-based-mesh","page":"P4est-based mesh","title":"P4est-based mesh","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The P4estMesh is an unstructured, curvilinear, nonconforming mesh type for quadrilateral (2D) and hexahedral (3D) cells. It supports quadtree/octree-based adaptive mesh refinement (AMR) via the C library p4est. See AMRCallback for further information.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the normal::AbstractVector. Rotationally invariant equations such as the compressible Euler equations can use FluxRotated to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the TreeMesh but is usually less efficient, cf. PR #550.","category":"page"},{"location":"meshes/p4est_mesh.html#Construction-of-a-P4estMesh-from-an-Abaqus-file","page":"P4est-based mesh","title":"Construction of a P4estMesh from an Abaqus file","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"One available option to construct a P4estMesh is to read in an Abaqus (.inp) mesh file. We briefly describe the structure of this file, the conventions it uses, and how the mesh file is parsed to create an initial unstructured, curvilinear, and conforming mesh.","category":"page"},{"location":"meshes/p4est_mesh.html#Mesh-in-two-spatial-dimensions","page":"P4est-based mesh","title":"Mesh in two spatial dimensions","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"For this discussion we use the following two-dimensional unstructured curved mesh with three elements:","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"(Image: abaqus-2dmesh-docs)","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"We note that the corner and element connectivity information parsed from the Abaqus file creates a straight sided (linear) mesh. From this linear mesh there are two strategies available to make the mesh curvilinear:","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Apply a mapping function to describe a transformation of the linear mesh to another physical domain. The mapping is approximated using interpolation polynomial of a user specified polynomial degree. The default value of this polynomial degree is 1 that corresponds to an uncurved geometry.\nHigh-order boundary information is available in the .inp mesh file because it was created with the HOHQMesh mesh generator, which is available via the Julia package HOHQMesh.jl. This information is used to create appropriate transfinite mappings during the mesh construction.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"We divide our discussion into two parts. The first part discusses the standard corner and element information contained in the .inp mesh file. The second part specifically deals with the mesh file parsing of an Abaqus file created by HOHQMesh.jl.","category":"page"},{"location":"meshes/p4est_mesh.html#Mesh-file-header","page":"P4est-based mesh","title":"Mesh file header","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"An Abaqus .inp mesh file typically begins with a *Heading. Though optional, the *Heading is helpful to give users some information about the mesh described by the mesh file. In particular, a .inp mesh file created with HOHQMesh will contain the header","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"*Heading\r\n File created by HOHQMesh","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"This heading is used to indicate to the mesh constructor which of the above mapping strategies to apply in order to create a curvilinear mesh. If the Abaqus file header is not present then the P4estMesh is created with the first strategy above.","category":"page"},{"location":"meshes/p4est_mesh.html#List-of-corner-nodes","page":"P4est-based mesh","title":"List of corner nodes","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Next, prefaced with *NODE, comes a list of the physical (x,y,z) coordinates of all the corners. The first integer in the list of the corners provides its id number. Thus, for the two-dimensional example mesh this block of corner information is","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"*NODE\r\n1, 1.0, -1.0, 0.0\r\n2, 3.0,  0.0, 0.0\r\n3, 1.0,  1.0, 0.0\r\n4, 2.0,  0.0, 0.0\r\n5, 0.0,  0.0, 0.0\r\n6, 3.0,  1.0, 0.0\r\n7, 3.0, -1.0, 0.0","category":"page"},{"location":"meshes/p4est_mesh.html#List-of-elements","page":"P4est-based mesh","title":"List of elements","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The element connectivity is given after the list of corners. The header for this information block is","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"*ELEMENT, type=CPS4, ELSET=Surface1","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The Abaqus element type CPS4 corresponds to a quadrilateral element. Each quadrilateral element in the unstructured mesh is dictated by four corner points with indexing taken from the numbering given by the corner list above. The elements connect a set of four corner points (starting from the bottom left) in an anti-clockwise fashion; making the element right-handed. This element handedness is indicated using the circular arrow in the figure above. Just as with the corner list, the first integer in the element connectivity list indicates the element id number. Thus, the element connectivity list for the three element example mesh is","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"*ELEMENT, type=CPS4, ELSET=Surface1\r\n1, 5, 1, 4, 3\r\n2, 4, 2, 6, 3\r\n3, 7, 2, 4, 1","category":"page"},{"location":"meshes/p4est_mesh.html#Element-neighbor-connectivity","page":"P4est-based mesh","title":"Element neighbor connectivity","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The construction of the element neighbor ids and identifying physical boundary surfaces is done using functionality directly from the p4est library. For example, the neighbor connectivity is created in the mesh constructor using the wrapper read_inp_p4est function.","category":"page"},{"location":"meshes/p4est_mesh.html#HOHQMesh-boundary-information","page":"P4est-based mesh","title":"HOHQMesh boundary information","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"If present, any additional information in the mesh file that was created by HOHQMesh is prefaced with ** to make it an Abaqus comment. This ensures that the read in of the file by a standard Abaqus file parser, as done in the read_inp_p4est function, is done correctly.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The high-order, curved boundary information and labels of the physical boundary created by HOHQMesh is found below the comment line","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"** ***** HOHQMesh boundary information ***** **","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Next comes the polynomial degree that the mesh will use to represent any curved sides","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"** mesh polynomial degree = 8","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The mesh file then, again, provides the element connectivity as well as information for curved surfaces either interior to the domain or along the physical boundaries. A set of check digits are included directly below the four corner indexes to indicate whether the local surface index (-y, +x, +y, or -x) within the element is straight sided, 0, or is curved, 1. If the local surface is straight sided no additional information is necessary during the mesh file read in. But for any curved surfaces the mesh file provides (x,y,z) coordinate values in order to construct an interpolant of this surface with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes. This list of (x,y,z) data will be given in the direction of the local coordinate system. Given below is the element curvature information for the example mesh:","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"**  5 1 4 3\r\n**  0 0 1 1\r\n**   1.000000000000000   1.000000000000000   0.0\r\n**   1.024948365654583   0.934461926834452   0.0\r\n**   1.116583018200151   0.777350964621867   0.0\r\n**   1.295753434047077   0.606254343587194   0.0\r\n**   1.537500000000000   0.462500000000000   0.0\r\n**   1.768263070247418   0.329729152118310   0.0\r\n**   1.920916981799849   0.185149035378133   0.0\r\n**   1.986035130050921   0.054554577460044   0.0\r\n**   2.000000000000000                 0.0   0.0\r\n**                 0.0                 0.0   0.0\r\n**   0.035513826946206   0.105291711848750   0.0\r\n**   0.148591270347399   0.317731556850611   0.0\r\n**   0.340010713990041   0.452219430075470   0.0\r\n**   0.575000000000000   0.462500000000000   0.0\r\n**   0.788022294598950   0.483764065630034   0.0\r\n**   0.926408729652601   0.644768443149389   0.0\r\n**   0.986453164464803   0.883724792445746   0.0\r\n**   1.000000000000000   1.000000000000000   0.0\r\n**  4 2 6 3\r\n**  0 0 0 1\r\n**   2.000000000000000                 0.0   0.0\r\n**   1.986035130050921   0.054554577460044   0.0\r\n**   1.920916981799849   0.185149035378133   0.0\r\n**   1.768263070247418   0.329729152118310   0.0\r\n**   1.537500000000000   0.462500000000000   0.0\r\n**   1.295753434047077   0.606254343587194   0.0\r\n**   1.116583018200151   0.777350964621867   0.0\r\n**   1.024948365654583   0.934461926834452   0.0\r\n**   1.000000000000000   1.000000000000000   0.0\r\n**  7 2 4 1\r\n**  0 0 0 0","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The last piece of information provided by HOHQMesh are labels for the different surfaces of an element. These labels are useful to set boundary conditions along physical surfaces. The labels can be short descriptive words up to 32 characters in length. The label --- indicates an internal surface where no boundary condition is required.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"It is important to note that these labels are given in the following order according to the local surface index -x +x -y +y as required by the p4est library.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"**  Bezier --- Slant ---\r\n**  --- Right --- Top\r\n**  Bottom --- Right ---","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"For completeness, we provide the entire Abaqus mesh file for the example mesh in the figure above:","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"*Heading\r\n File created by HOHQMesh\r\n*NODE\r\n1, 1.0, -1.0, 0.0\r\n2, 3.0,  0.0, 0.0\r\n3, 1.0,  1.0, 0.0\r\n4, 2.0,  0.0, 0.0\r\n5, 0.0,  0.0, 0.0\r\n6, 3.0,  1.0, 0.0\r\n7, 3.0, -1.0, 0.0\r\n*ELEMENT, type=CPS4, ELSET=Surface1\r\n1, 5, 1, 4, 3\r\n2, 4, 2, 6, 3\r\n3, 7, 2, 4, 1\r\n** ***** HOHQMesh boundary information ***** **\r\n** mesh polynomial degree = 8\r\n**  5 1 4 3\r\n**  0 0 1 1\r\n**   1.000000000000000   1.000000000000000   0.0\r\n**   1.024948365654583   0.934461926834452   0.0\r\n**   1.116583018200151   0.777350964621867   0.0\r\n**   1.295753434047077   0.606254343587194   0.0\r\n**   1.537500000000000   0.462500000000000   0.0\r\n**   1.768263070247418   0.329729152118310   0.0\r\n**   1.920916981799849   0.185149035378133   0.0\r\n**   1.986035130050921   0.054554577460044   0.0\r\n**   2.000000000000000                 0.0   0.0\r\n**                 0.0                 0.0   0.0\r\n**   0.035513826946206   0.105291711848750   0.0\r\n**   0.148591270347399   0.317731556850611   0.0\r\n**   0.340010713990041   0.452219430075470   0.0\r\n**   0.575000000000000   0.462500000000000   0.0\r\n**   0.788022294598950   0.483764065630034   0.0\r\n**   0.926408729652601   0.644768443149389   0.0\r\n**   0.986453164464803   0.883724792445746   0.0\r\n**   1.000000000000000   1.000000000000000   0.0\r\n**  4 2 6 3\r\n**  0 0 0 1\r\n**   2.000000000000000                 0.0   0.0\r\n**   1.986035130050921   0.054554577460044   0.0\r\n**   1.920916981799849   0.185149035378133   0.0\r\n**   1.768263070247418   0.329729152118310   0.0\r\n**   1.537500000000000   0.462500000000000   0.0\r\n**   1.295753434047077   0.606254343587194   0.0\r\n**   1.116583018200151   0.777350964621867   0.0\r\n**   1.024948365654583   0.934461926834452   0.0\r\n**   1.000000000000000   1.000000000000000   0.0\r\n**  7 2 4 1\r\n**  0 0 0 0\r\n**  Bezier --- Slant ---\r\n**  --- Right --- Top\r\n**  Bottom --- Right ---","category":"page"},{"location":"meshes/p4est_mesh.html#Mesh-in-three-spatial-dimensions","page":"P4est-based mesh","title":"Mesh in three spatial dimensions","text":"","category":"section"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The 3D Abaqus file format with high-order boundary information from HOHQMesh is very similar to the 2D version discussed above. There are only three changes:","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"The element connectivity would be given in terms of the eight corners that define a hexahedron. The corners are numbered as shown in the figure below. The header of the element list changes to be\n*ELEMENT, type=C3D8, ELSET=Volume1\nwhere C3D8 corresponds to a Abaqus hexahedral element.\nThere are six check digits included directly below the eight corner indexes to indicate whether the local face within the element is straight sided, 0, or is curved, 1. For curved faces (x,y,z) coordinate values are available in order to construct an face interpolant with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes.\nThe boundary labels are given in the following order according to the local surface index -x +x -y +y -z +z as required by the p4est library.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"For completeness, we also give a short description and derivation of the three-dimensional transfinite mapping formulas used to compute the physical coordinates mathbfx=(xyz) of a (possibly curved) hexahedral element give the reference coordinates boldsymbolxi = (xi eta zeta) which lie in -11^3. That is, we will create an expression mathbfx= mathbfX(boldsymbolxi).","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Below we provide a sketch of a single hexahedral element with curved faces. This is done to introduce the numbering conventions for corners, edges, and faces of the element.","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"(Image: abaqus-3dmesh-docs)","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"When the hexahedron is a straight sided (linear) element we compute the transfinite mapping directly from the element corner points according to","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"beginaligned\r\nmathbfX_linear(boldsymbolxi) =  frac18quad mathbfx_1(1-xi)(1-eta)(1-zeta)\r\n                                                         + mathbfx_2(1+xi)(1-eta)(1-zeta)-015cm\r\n                                     qquad             + mathbfx_3(1+xi)(1+eta)(1-zeta)\r\n                                                         + mathbfx_4(1-xi)(1+eta)(1-zeta) \r\n                                     qquad             + mathbfx_5(1-xi)(1-eta)(1+zeta)\r\n                                                         + mathbfx_6(1+xi)(1-eta)(1+zeta) \r\n                                     qquad             + mathbfx_7(1+xi)(1+eta)(1+zeta)\r\n                                                         + mathbfx_8(1-xi)(1+eta)(1+zeta)quad\r\nendaligned","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Next, we create a transfinite mapping function, mathbfX(boldsymbolxi), for a hexahedron that has one or more curved faces. For this we assume that have a set of six interpolating polynomials Gamma_i_i=1^6 that approximate the faces. The interpolating polynomial for any curved faces is provided by the information in a HOHQMesh Abaqus mesh file or is constructed on the fly via a bi-linear interpolation routine for any linear faces. Explicitly, these six face interpolation polynomials depend on the computational coordinates boldsymbolxi as follows","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"  beginaligned\r\n    Gamma_1(xi zeta) quad  quad Gamma_3(xi eta) quad  quad Gamma_4(eta zeta)01cm\r\n    Gamma_2(xi zeta) quad  quad Gamma_5(xi eta) quad  quad Gamma_6(eta zeta)\r\n  endaligned","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"To determine the form of the mapping we first create linear interpolations between two opposing faces, e.g., Gamma_3 and Gamma_5 and sum them together to have","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"beginaligned\r\n  boldsymbolSigma(boldsymbolxi) = frac12quad(1-xi)Gamma_6(etazeta) + (1+xi)Gamma_4(etazeta) -015cm\r\n  qquad+ (1-eta)Gamma_1(xizeta) + (1+eta)Gamma_2(xizeta) -015cm\r\n                                  qquad +(1-zeta)Gamma_3(xieta) + (1+zeta)Gamma_5(xieta)quad\r\nendaligned","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"Unfortunately, the linear interpolations boldsymbolSigma(boldsymbolxi) no longer match at the faces, e.g., evaluating at eta = -1 we have","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"boldsymbolSigma(xi-1zeta) = Gamma_1(xizeta) + frac12(1-xi)Gamma_6(-1zeta) + (1+xi)Gamma_4(-1zeta)\r\n                                 +(1-zeta)Gamma_3(xi-1) + (1+zeta)Gamma_5(xi-1)","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"which is the desired face Gamma_1(xizeta) plus four edge error terms. Analogous edge error terms occur at the other faces evaluating boldsymbolSigma(boldsymbolxi) at eta=1, xi=pm 1, and zeta=pm 1. In order to match the faces, we subtract a linear interpolant in the xi, eta, and zeta directions of the edge error terms, e.g., the terms in braces in the above equation. So, continuing the example above, the correction term to be subtracted for face Gamma_1 to match would be","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"left(frac1-eta2right) bigg frac12   (1-xi)Gamma_6(-1zeta) + (1+xi)Gamma_4(-1zeta)+(1-zeta)Gamma_3(xi-1)\r\n + (1+zeta)Gamma_5(xi-1) bigg","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"For clarity, and to allow an easier comparison to the implementation, we introduce auxiliary notation for the 12 edge values present in the complete correction term. That is, for given values of xi, eta, and zeta we have","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"  beginaligned\r\n    textttedge_1 = Gamma_1(xi -1) quad  quad textttedge_5 = Gamma_2(xi -1) quad  quad  textttedge_9 = Gamma_6(eta -1)01cm\r\n    textttedge_2 = Gamma_1(1 zeta) quad  quadtextttedge_6 = Gamma_2(1 zeta) quad  quad  textttedge_10 = Gamma_4(eta -1)01cm\r\n    textttedge_3 = Gamma_1(xi 1) quad  quad textttedge_7 = Gamma_2(xi  1) quad  quad  textttedge_11 = Gamma_4(eta 1)01cm\r\n    textttedge_4 = Gamma_1(-1 zeta) quad  quad textttedge_8 = Gamma_2(-1 zeta) quad  quad  textttedge_12 = Gamma_6(eta 1)\r\n  endaligned","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"With this notation for the edge terms (and after some algebraic manipulation) we write the complete edge correction term, mathcalC_textttedge(boldsymbolxi), as","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"beginaligned\r\nmathcalC_textttedge(boldsymbolxi) =  frac14quad (1-eta)(1-zeta)textttedge_1-015cm\r\n                                     qquad              + (1+xi)(1-eta)textttedge_2 \r\n                                     qquad              + (1-eta)(1+zeta)textttedge_3 \r\n                                     qquad              + (1-xi)(1-eta)textttedge_4 \r\n                                     qquad              + (1+eta)(1-zeta)textttedge_5 \r\n                                     qquad              + (1+xi)(1+eta)textttedge_6 \r\n                                     qquad              + (1+eta)(1+zeta)textttedge_7 \r\n                                     qquad              + (1-xi)(1+eta)textttedge_8 \r\n                                     qquad              + (1-xi)(1-zeta)textttedge_9 \r\n                                     qquad              + (1+xi)(1-zeta)textttedge_10 \r\n                                     qquad              + (1+xi)(1+zeta)textttedge_11 \r\n                                     qquad              + (1-xi)(1+zeta)textttedge_12quad\r\nendaligned","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"However, subtracting the edge correction terms mathcalC_textttedge(boldsymbolxi) from boldsymbolSigma(boldsymbolxi) removes the interior element contributions twice. Thus, to complete the construction of the transfinite mapping mathbfX(boldsymbolxi) we add the transfinite map of the straight sided hexahedral element to find","category":"page"},{"location":"meshes/p4est_mesh.html","page":"P4est-based mesh","title":"P4est-based mesh","text":"mathbfX(boldsymbolxi) = boldsymbolSigma(boldsymbolxi)\r\n                             - mathcalC_textttedge(boldsymbolxi)\r\n                             + mathbfX_linear(boldsymbolxi)","category":"page"},{"location":"index.html#Trixi.jl","page":"Home","title":"Trixi.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: Slack) (Image: Youtube) (Image: Build Status) (Image: Codecov) (Image: Coveralls) (Image: License: MIT) (Image: DOI)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Trixi.jl is a numerical simulation framework for hyperbolic conservation laws written in Julia. A key objective for the framework is to be useful to both scientists and students. Therefore, next to having an extensible design with a fast implementation, Trixi is focused on being easy to use for new or inexperienced users, including the installation and postprocessing procedures. Its features include:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"1D, 2D, and 3D simulations on line/quad/hex/simplex meshes\nCartesian and curvilinear meshes\nConforming and non-conforming meshes\nStructured and unstructured meshes\nHierarchical quadtree/octree grid with adaptive mesh refinement\nForests of quadtrees/octrees with p4est via P4est.jl\nHigh-order accuracy in space and time\nDiscontinuous Galerkin methods\nKinetic energy-preserving and entropy-stable methods based on flux differencing\nEntropy-stable shock capturing\nPositivity-preserving limiting\nFinite difference summation by parts (SBP) methods\nCompatible with the SciML ecosystem for ordinary differential equations\nExplicit low-storage Runge-Kutta time integration\nStrong stability preserving methods\nCFL-based and error-based time step control\nNative support for differentiable programming\nForward mode automatic differentiation via ForwardDiff.jl\nPeriodic and weakly-enforced boundary conditions\nMultiple governing equations:\nCompressible Euler equations\nMagnetohydrodynamics (MHD) equations\nMulti-component compressible Euler and MHD equations\nLinearized Euler and acoustic perturbation equations\nHyperbolic diffusion equations for elliptic problems\nLattice-Boltzmann equations (D2Q9 and D3Q27 schemes)\nShallow water equations\nScalar advection\nMulti-physics simulations\nSelf-gravitating gas dynamics\nShared-memory parallelization via multithreading\nVisualization and postprocessing of the results\nIn-situ and a posteriori visualization with Plots.jl\nInteractive visualization with Makie.jl\nPostprocessing with ParaView/VisIt via Trixi2Vtk","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have not yet installed Julia, please follow the instructions for your operating system. Trixi works with Julia v1.8.","category":"page"},{"location":"index.html#For-users","page":"Home","title":"For users","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Trixi and its related tools are registered Julia packages. Hence, you can install Trixi, the visualization tool Trixi2Vtk, OrdinaryDiffEq.jl, and Plots.jl by executing the following commands in the Julia REPL:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Pkg\r\n\r\njulia> Pkg.add([\"Trixi\", \"Trixi2Vtk\", \"OrdinaryDiffEq\", \"Plots\"])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can copy and paste all commands to the REPL including the leading julia> prompts - they will automatically be stripped away by Julia. The package OrdinaryDiffEq.jl provides time integration schemes used by Trixi, while Plots.jl can be used to directly visualize Trixi's results from the REPL.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note on package versions: If some of the examples for how to use Trixi do not work, verify that you are using a recent Trixi release by comparing the installed Trixi version from","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"Trixi\"); Pkg.status(\"Trixi\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"to the latest release. If the installed version does not match the current release, please check the Troubleshooting section.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The commands above can also be used to update Trixi. A brief list of notable changes to Trixi is available in NEWS.md.","category":"page"},{"location":"index.html#for-developers","page":"Home","title":"For developers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you plan on editing Trixi itself, you can download Trixi to a local folder and use the code from the cloned directory:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"git clone git@github.com:trixi-framework/Trixi.jl.git\r\ncd Trixi.jl\r\nmkdir run\r\ncd run\r\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))'","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you installed Trixi this way, you always have to start Julia with the --project flag set to your run directory, e.g.,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia --project=.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"if already inside the run directory.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The advantage of using a separate run directory is that you can also add other related packages (see below, e.g., for time integration or visualization) to the project in the run folder and always have a reproducible environment at hand to share with others.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Since the postprocessing tool Trixi2Vtk.jl typically does not need to be modified, it is recommended to install it as a normal package.  Likewise, you can install OrdinaryDiffEq.jl and Plots.jl as ordinary packages. To achieve this, use the following REPL commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Pkg\r\n\r\njulia> Pkg.add([\"OrdinaryDiffEq\", \"Trixi2Vtk\", \"Plots\"])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the postprocessing tools Trixi2Vtk.jl and Plots.jl are optional and can be omitted.","category":"page"},{"location":"index.html#Example:-Installing-Trixi-as-a-package","page":"Home","title":"Example: Installing Trixi as a package","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"  <script id=\"asciicast-373869\"\r\n          src=\"https://asciinema.org/a/373869.js\"\r\n          async\r\n          data-cols=100\r\n          data-rows=20\r\n          data-speed=3></script>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Please note that the playback speed is set to 3x, thus the entire installation procedure lasts around 45 seconds in real time (depending on the performance of your computer and on how many dependencies had already been installed before).","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In the Julia REPL, first load the package Trixi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Trixi","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then start a simulation by executing","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> trixi_include(default_example())","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Please be patient since Julia will compile the code just before running it. To visualize the results, load the package Plots","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Plots","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and generate a heatmap plot of the results with","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> plot(sol) # No trailing semicolon, otherwise no plot is shown","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will open a new window with a 2D visualization of the final solution:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The method trixi_include(...) expects a single string argument with the path to a Trixi elixir, i.e., a text file containing Julia code necessary to set up and run a simulation. To quickly see Trixi in action, default_example() returns the path to an example elixir with a short, two-dimensional problem setup. A list of all example elixirs packaged with Trixi can be obtained by running get_examples(). Alternatively, you can also browse the examples/ subdirectory. If you want to modify one of the elixirs to set up your own simulation, download it to your machine, edit the configuration, and pass the file path to trixi_include(...).","category":"page"},{"location":"index.html#Example:-Running-a-simulation-with-Trixi","page":"Home","title":"Example: Running a simulation with Trixi","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"  <script id=\"asciicast-372987\"\r\n          src=\"https://asciinema.org/a/372987.js\"\r\n          async\r\n          data-cols=100\r\n          data-rows=48></script>","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If this produces weird symbols or question marks in the terminal on your system, you are probably using Mac OS with problematic fonts. In that case, please check the Troubleshooting section.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note on performance: Julia uses just-in-time compilation to transform its source code to native, optimized machine code at the time of execution and caches the compiled methods for further use. That means that the first execution of a Julia method is typically slow, with subsequent runs being much faster. For instance, in the example above the first execution of trixi_include takes about 20 seconds, while subsequent runs require less than 60 milliseconds.","category":"page"},{"location":"index.html#Performing-a-convergence-analysis","page":"Home","title":"Performing a convergence analysis","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To automatically determine the experimental order of convergence (EOC) for a given setup, execute","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> convergence_test(default_example(), 4)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will run a convergence test with the elixir default_example(), using four iterations with different initial refinement levels. The initial iteration will use the elixir unchanged, while for each subsequent iteration the initial_refinement_level parameter is incremented by one. Finally, the measured l^2 and l^infty errors and the determined EOCs will be displayed like this:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[...]\r\nl2\r\nscalar\r\nerror     EOC\r\n9.14e-06  -\r\n5.69e-07  4.01\r\n3.55e-08  4.00\r\n2.22e-09  4.00\r\n\r\nmean      4.00\r\n--------------------------------------------------------------------------------\r\nlinf\r\nscalar\r\nerror     EOC\r\n6.44e-05  -\r\n4.11e-06  3.97\r\n2.58e-07  3.99\r\n1.62e-08  4.00\r\n\r\nmean      3.99\r\n--------------------------------------------------------------------------------","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"An example with multiple variables looks like this:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> convergence_test(joinpath(examples_dir(), \"tree_2d_dgsem\", \"elixir_euler_source_terms.jl\"), 3)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[...]\r\nl2\r\nrho                 rho_v1              rho_v2              rho_e\r\nerror     EOC       error     EOC       error     EOC       error     EOC\r\n9.32e-07  -         1.42e-06  -         1.42e-06  -         4.82e-06  -\r\n7.03e-08  3.73      9.53e-08  3.90      9.53e-08  3.90      3.30e-07  3.87\r\n4.65e-09  3.92      6.09e-09  3.97      6.09e-09  3.97      2.12e-08  3.96\r\n\r\nmean      3.82      mean      3.93      mean      3.93      mean      3.91\r\n--------------------------------------------------------------------------------\r\nlinf\r\nrho                 rho_v1              rho_v2              rho_e\r\nerror     EOC       error     EOC       error     EOC       error     EOC\r\n9.58e-06  -         1.17e-05  -         1.17e-05  -         4.89e-05  -\r\n6.23e-07  3.94      7.48e-07  3.97      7.48e-07  3.97      3.22e-06  3.92\r\n4.05e-08  3.94      4.97e-08  3.91      4.97e-08  3.91      2.10e-07  3.94\r\n\r\nmean      3.94      mean      3.94      mean      3.94      mean      3.93\r\n--------------------------------------------------------------------------------","category":"page"},{"location":"index.html#Showcase-of-advanced-features","page":"Home","title":"Showcase of advanced features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The presentation From Mesh Generation to Adaptive Simulation: A Journey in Julia, originally given as part of JuliaCon 2022, outlines how to use Trixi for an adaptive simulation of the compressible Euler equations in two spatial dimensions on a complex domain. More details as well as code to run the simulation presented can be found at the reproducibility repository for the presentation.","category":"page"},{"location":"index.html#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use Trixi in your own research or write a paper using results obtained with the help of Trixi, please cite the following articles:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{ranocha2022adaptive,\r\n  title={Adaptive numerical simulations with {T}rixi.jl:\r\n         {A} case study of {J}ulia for scientific computing},\r\n  author={Ranocha, Hendrik and Schlottke-Lakemper, Michael and Winters, Andrew Ross\r\n          and Faulhaber, Erik and Chan, Jesse and Gassner, Gregor},\r\n  journal={Proceedings of the JuliaCon Conferences},\r\n  volume={1},\r\n  number={1},\r\n  pages={77},\r\n  year={2022},\r\n  doi={10.21105/jcon.00077},\r\n  eprint={2108.06476},\r\n  eprinttype={arXiv},\r\n  eprintclass={cs.MS}\r\n}\r\n\r\n@article{schlottkelakemper2021purely,\r\n  title={A purely hyperbolic discontinuous {G}alerkin approach for\r\n         self-gravitating gas dynamics},\r\n  author={Schlottke-Lakemper, Michael and Winters, Andrew R and\r\n          Ranocha, Hendrik and Gassner, Gregor J},\r\n  journal={Journal of Computational Physics},\r\n  pages={110467},\r\n  year={2021},\r\n  month={06},\r\n  volume={442},\r\n  publisher={Elsevier},\r\n  doi={10.1016/j.jcp.2021.110467},\r\n  eprint={2008.10593},\r\n  eprinttype={arXiv},\r\n  eprintclass={math.NA}\r\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In addition, you can also refer to Trixi directly as","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@misc{schlottkelakemper2020trixi,\r\n  title={{T}rixi.jl: {A}daptive high-order numerical simulations\r\n         of hyperbolic {PDE}s in {J}ulia},\r\n  author={Schlottke-Lakemper, Michael and Gassner, Gregor J and\r\n          Ranocha, Hendrik and Winters, Andrew R and Chan, Jesse},\r\n  year={2021},\r\n  month={09},\r\n  howpublished={\\url{https://github.com/trixi-framework/Trixi.jl}},\r\n  doi={10.5281/zenodo.3996439}\r\n}","category":"page"},{"location":"index.html#authors-index-md","page":"Home","title":"Authors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Trixi was initiated by Michael Schlottke-Lakemper (RWTH Aachen University, Germany) and Gregor Gassner (University of Cologne, Germany). Together with Hendrik Ranocha (University of Hamburg, Germany) and Andrew Winters (Linköping University, Sweden), and Jesse Chan (Rice University, US), they are the principal developers of Trixi. The full list of contributors can be found under Authors.","category":"page"},{"location":"index.html#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Trixi is licensed under the MIT license (see License). Since Trixi is an open-source project, we are very happy to accept contributions from the community. Please refer to Contributing for more details. Note that we strive to be a friendly, inclusive open-source community and ask all members of our community to adhere to our Code of Conduct. To get in touch with the developers, join us on Slack or create an issue.","category":"page"},{"location":"index.html#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This project has benefited from funding by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy EXC 2044-390685587, Mathematics Münster: Dynamics-Geometry-Structure.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This project has benefited from funding from the European Research Council through the ERC Starting Grant \"An Exascale aware and Un-crashable Space-Time-Adaptive Discontinuous Spectral Element Solver for Non-Linear Conservation Laws\" (Extreme), ERC grant agreement no. 714487.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This project has benefited from funding from Vetenskapsrådet (VR, Swedish Research Council), Sweden grant agreement 2020-03642 VR.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This project has benefited from funding from the United States National Science Foundation under awards DMS-1719818 and DMS-1943186.","category":"page"},{"location":"reference-trixi2vtk.html#Trixi2Vtk.jl-API","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.jl API","text":"","category":"section"},{"location":"reference-trixi2vtk.html","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.jl","text":"CurrentModule = Trixi2Vtk","category":"page"},{"location":"reference-trixi2vtk.html","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.jl","text":"Modules = [Trixi2Vtk]","category":"page"},{"location":"reference-trixi2vtk.html#Trixi2Vtk.trixi2vtk-Tuple{Vararg{AbstractString}}","page":"Trixi2Vtk.jl","title":"Trixi2Vtk.trixi2vtk","text":"trixi2vtk(filename::AbstractString...;\n          format=:vtu, verbose=false, hide_progress=false, pvd=nothing,\n          output_directory=\".\", nvisnodes=nothing, save_celldata=true,\n          reinterpolate=true, data_is_uniform=false)\n\nConvert Trixi-generated output files to VTK files (VTU or VTI).\n\nArguments\n\nfilename: One or more Trixi solution/restart/mesh files to convert to a VTK file.             Filenames support file globbing, e.g., \"solution*\" to match all files starting             with solution.\nformat: Output format for solution/restart files. Can be 'vtu' or 'vti'.\nverbose: Set to true to enable verbose output.\nhide_progress: Hide progress bar (will be hidden automatically if verbose is true).\npvd: Use this filename to store PVD file (instead of auto-detecting name). Note that        only the name will be used (directory and file extension are ignored).\noutput_directory: Output directory where generated files are stored.\nnvisnodes: Number of visualization nodes per element.              (default: number of DG nodes for StructuredMesh or UnstructuredMesh2D,                        twice the number of DG nodes for TreeMesh).              A value of 0 (zero) uses the number of nodes in the DG elements.\nsave_celldata: Boolean value to determine if cell-based data should be saved.                  (default: true)\nreinterpolate: Boolean value to determine if data should be reinterpolated                  onto uniform points. When false the raw data at the compute nodes                  is copied into the appropriate format.                  (default: true)\ndata_is_uniform: Boolean to indicate if the data to be converted is from a finite difference                    method on a uniform grid of points.                    (default: false)\n\nExamples\n\njulia> trixi2vtk(\"out/solution_000*.h5\")\n[...]\n\n\n\n\n\n","category":"method"},{"location":"time_integration.html#time-integration","page":"Time integration","title":"Time integration methods","text":"","category":"section"},{"location":"time_integration.html","page":"Time integration","title":"Time integration","text":"Trixi is compatible with the SciML ecosystem for ordinary differential equations. In particular, explicit Runge-Kutta methods from OrdinaryDiffEq.jl are tested extensively. Interesting classes of time integration schemes are","category":"page"},{"location":"time_integration.html","page":"Time integration","title":"Time integration","text":"Explicit low-storage Runge-Kutta methods\nStrong stability preserving methods","category":"page"},{"location":"time_integration.html","page":"Time integration","title":"Time integration","text":"Some common options for solve from OrdinaryDiffEq.jl are the following. Further documentation can be found in the SciML docs.","category":"page"},{"location":"time_integration.html","page":"Time integration","title":"Time integration","text":"If you use a fixed time step method like CarpenterKennedy2N54, you need to pass a time step as dt=.... If you use a StepsizeCallback, the value passed  as dt=... is irrelevant since it will be overwritten by the StepsizeCallback. If you want to use an adaptive time step method such as SSPRK43 or RDPK3SpFSAL49 and still want to use CFL-based step size control via the StepsizeCallback, you need to pass the keyword argument adaptive=false to solve.\nYou should usually set save_everystep=false. Otherwise, OrdinaryDiffEq.jl will (try to) save the numerical solution after every time step in RAM (until you run out of memory or start to swap).\nYou can set the maximal number of time steps via maxiters=....\nSSP methods and many low-storage methods from OrdinaryDiffEq.jl support stage_limiter!s and step_limiter!s, e.g., PositivityPreservingLimiterZhangShu from Trixi.\nIf you start Julia with multiple threads and want to use them also in the time  integration method from OrdinaryDiffEq.jl, you need to pass the keyword argument thread=OrdinaryDiffEq.True() to the algorithm, e.g.,  RDPK3SpFSAL49(thread=OrdinaryDiffEq.True()) or  CarpenterKennedy2N54(thread=OrdinaryDiffEq.True(), williamson_condition=false). For more information on using thread-based parallelism in Trixi, please refer to  Shared-memory parallelization with threads.","category":"page"},{"location":"time_integration.html","page":"Time integration","title":"Time integration","text":"note: Number of `rhs!` calls\nIf you use explicit Runge-Kutta methods from OrdinaryDiffEq.jl, the total number of rhs! calls can be (slightly) bigger than the number of steps times the number of stages, e.g. to allow for interpolation (dense output), root-finding for continuous callbacks, and error-based time step control. In general, you often should not need to worry about this if you use Trixi.","category":"page"}]
}
