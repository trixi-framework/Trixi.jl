<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Visualization · Trixi.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/visualization.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Trixi.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="overview.html">Overview</a></li><li class="is-active"><a class="tocitem" href="visualization.html">Visualization</a><ul class="internal"><li><a class="tocitem" href="#Plots.jl"><span>Plots.jl [experimental]</span></a></li><li><a class="tocitem" href="#Plotting-a-user-defined-scalar-field"><span>Plotting a user-defined scalar field</span></a></li><li><a class="tocitem" href="#Trixi2Vtk"><span>Trixi2Vtk</span></a></li><li><a class="tocitem" href="#Makie.jl"><span>Makie.jl [experimental]</span></a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/introduction.html">Introduction</a></li><li><a class="tocitem" href="tutorials/getting_started_with_Trixi.html">1 Getting started with Trixi</a></li><li><a class="tocitem" href="tutorials/scalar_linear_advection_1d.html">2 Introduction to DG methods</a></li><li><a class="tocitem" href="tutorials/DGSEM_FluxDiff.html">3 DGSEM with flux differencing</a></li><li><a class="tocitem" href="tutorials/shock_capturing.html">4 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="tutorials/non_periodic_boundaries.html">5 Non-periodic boundaries</a></li><li><a class="tocitem" href="tutorials/DGMulti_1.html">6 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="tutorials/DGMulti_2.html">7 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="tutorials/upwind_fdsbp.html">8 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="tutorials/adding_new_scalar_equations.html">9 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="tutorials/adding_nonconservative_equation.html">10 Adding a non-conservative equation</a></li><li><a class="tocitem" href="tutorials/parabolic_terms.html">11 Parabolic terms</a></li><li><a class="tocitem" href="tutorials/adding_new_parabolic_terms.html">12 Adding new parabolic terms</a></li><li><a class="tocitem" href="tutorials/adaptive_mesh_refinement.html">13 Adaptive mesh refinement</a></li><li><a class="tocitem" href="tutorials/structured_mesh_mapping.html">14 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="tutorials/hohqmesh_tutorial.html">15 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="tutorials/time_stepping.html">16 Explicit time stepping</a></li><li><a class="tocitem" href="tutorials/differentiable_programming.html">17 Differentiable programming</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="meshes/tree_mesh.html">Tree mesh</a></li><li><a class="tocitem" href="meshes/structured_mesh.html">Structured mesh</a></li><li><a class="tocitem" href="meshes/unstructured_quad_mesh.html">Unstructured mesh</a></li><li><a class="tocitem" href="meshes/p4est_mesh.html">P4est-based mesh</a></li><li><a class="tocitem" href="meshes/dgmulti_mesh.html">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="time_integration.html">Time integration</a></li><li><a class="tocitem" href="callbacks.html">Callbacks</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="conventions.html">Conventions</a></li><li><a class="tocitem" href="development.html">Development</a></li><li><a class="tocitem" href="github-git.html">GitHub &amp; Git</a></li><li><a class="tocitem" href="styleguide.html">Style guide</a></li><li><a class="tocitem" href="testing.html">Testing</a></li><li><a class="tocitem" href="performance.html">Performance</a></li><li><a class="tocitem" href="parallelization.html">Parallelization</a></li></ul></li><li><a class="tocitem" href="troubleshooting.html">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="reference-trixi.html">Trixi.jl</a></li><li><a class="tocitem" href="reference-trixi2vtk.html">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="authors.html">Authors</a></li><li><a class="tocitem" href="contributing.html">Contributing</a></li><li><a class="tocitem" href="code_of_conduct.html">Code of Conduct</a></li><li><a class="tocitem" href="license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href="visualization.html">Visualization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="visualization.html">Visualization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/visualization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="visualization"><a class="docs-heading-anchor" href="#visualization">Visualization</a><a id="visualization-1"></a><a class="docs-heading-anchor-permalink" href="#visualization" title="Permalink"></a></h1><p>There are two possible approaches to visualize results from Trixi: either directly from the REPL using <a href="visualization.html#Plots.jl">Plots.jl</a> or with ParaView/VisIt by postprocessing Trixi&#39;s output files with <a href="visualization.html#Trixi2Vtk">Trixi2Vtk</a>.</p><h2 id="Plots.jl"><a class="docs-heading-anchor" href="#Plots.jl">Plots.jl [experimental]</a><a id="Plots.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Plots.jl" title="Permalink"></a></h2><p>By far the easiest and most convenient plotting approach is to use the powerful <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> package to directly visualize Trixi&#39;s results from the REPL. In the following, you will find more information on a number of topics for how to use Plots.jl together with Trixi:</p><ol><li><a href="visualization.html#getting-started-plots-jl">Getting started</a></li><li><a href="visualization.html#Customizing-plot-results-via-a-PlotData2D-object">Customizing plot results via a PlotData2D object</a></li><li><a href="visualization.html#Plotting-a-3D-solution-as-a-2D-plot">Plotting a 3D solution as a 2D plot</a></li><li><a href="visualization.html#Creating-a-1D-plot">Creating a 1D plot</a></li><li><a href="visualization.html#Plotting-a-2D-or-3D-solutions-as-a-1D-plot">Plotting a 2D or 3D solutions as a 1D plot</a></li><li><a href="visualization.html#Visualizing-results-during-a-simulation">Visualizing results during a simulation</a></li></ol><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Plotting via Plots.jl is still considered an experimental feature and might change in any future releases.</p></div></div><h3 id="getting-started-plots-jl"><a class="docs-heading-anchor" href="#getting-started-plots-jl">Getting started</a><a id="getting-started-plots-jl-1"></a><a class="docs-heading-anchor-permalink" href="#getting-started-plots-jl" title="Permalink"></a></h3><p>After running a simulation with Trixi in the REPL, load the Plots package with</p><pre><code class="language-julia hljs">julia&gt; using Plots</code></pre><p>To visualize the solution, execute</p><pre><code class="language-julia hljs">julia&gt; plot(sol)</code></pre><p>Here we assume that <code>sol</code> holds the return value of the <code>solve(...)</code> method (with type <code>SciMLBase.ODESolution</code>), which is the default variable name when you use one of the example elixirs. This will generate a grid layout with one subplot for each solution variable, convenient for getting an overview of the current solution:</p><p><img src="https://user-images.githubusercontent.com/72009492/130951021-677824f1-ba86-4291-8ff3-6fe2b910a2c9.PNG" alt="plot-sol"/></p><p>You can save the resulting file as a PNG image file by calling <code>savefig(...)</code> with an output file name that ends in <code>.png</code>, e.g.,</p><pre><code class="language-julia hljs">julia&gt; savefig(&quot;solution-overview.png&quot;)</code></pre><p>In Trixi, two plot types are available: 2D heatmap plots and 1D line plots. If you use <code>plot(sol)</code>, Trixi will automatically choose the plot type that fits the dimensions of the <code>sol</code> input: 2D/3D data will be visualized as a heatmap, 1D data as a line plot. For more fine-grained control over what to plot, you can create such an object yourself, which can either be a <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a> or a <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> object. For further details on both of these see below:</p><h3 id="Customizing-plot-results-via-a-PlotData2D-object"><a class="docs-heading-anchor" href="#Customizing-plot-results-via-a-PlotData2D-object">Customizing plot results via a PlotData2D object</a><a id="Customizing-plot-results-via-a-PlotData2D-object-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-plot-results-via-a-PlotData2D-object" title="Permalink"></a></h3><p>For more fine-grained control over what to plot, first create a <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a> object by executing</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData2D(sol)
julia&gt; pd = PlotData2D(u, semi)</code></pre><p>where <code>u</code> is an array containing the solution and <code>semi</code> is the semidiscretization. For example, if <code>PlotData2D(sol.u[2], semi)</code> is specified, this will create a <code>PlotData2D</code> instance from the 2nd saved time-step. If <code>PlotData2D(sol(0.5), semi)</code> is specified, it will construct a <code>PlotData2D</code> instance using OrdinaryDiffEq.jl&#39;s interpolation to evaluate the solution at time <code>t=0.5</code>.</p><p>This takes the results generated by Trixi and stores them in a data format that can be understood by the Plots package, and <code>pd</code> holds all data relevant for plotting <code>sol</code>. You can pass variable names as strings to <code>pd</code> using a dictionary-like syntax, e.g.,</p><pre><code class="language-julia hljs">julia&gt; plot(pd[&quot;rho&quot;])</code></pre><p>This will create a single 2D heatmap plot of the variable <code>rho</code>:</p><p><img src="https://user-images.githubusercontent.com/72009492/130951033-e3852c55-918c-4e74-98df-ef2353115b00.PNG" alt="plot-rho"/></p><p>The default plot type and style can be overridden by passing any additional arguments that are understood by the Plots package. For example, to change the color scheme and add names to the axes, modify the previous command to</p><pre><code class="language-julia hljs">julia&gt; plot(pd[&quot;rho&quot;], seriescolor = :heat, xguide=&quot;x&quot;, yguide=&quot;y&quot;)</code></pre><p>to yield</p><p><img src="https://user-images.githubusercontent.com/3637659/102724842-d8c20b80-4312-11eb-87db-b3ab22e74568.png" alt="plot-rho-modified"/></p><p>For more details on the various format options for <code>plot</code>, please consult the <a href="https://docs.juliaplots.org/latest/">Plots documentation</a>.</p><p>In addition, you can plot the mesh lines on top of the solution variables by calling the <code>getmesh(...)</code> function on the <code>PlotData2D</code> object</p><pre><code class="language-julia hljs">julia&gt; plot!(getmesh(pd)) # here we use `plot!` with an `!` to add to the previous plot</code></pre><p>which modifies the previous plot to</p><p><img src="https://user-images.githubusercontent.com/3637659/102724856-e1b2dd00-4312-11eb-83ae-e470c32f9008.png" alt="plot-rho-modified-mesh"/></p><p>By default, <code>PlotData2D</code> will convert the conserved variables to primitive variables, but this can be changed by passing an appropriate conversion function in the <code>solution_variables</code> keyword argument, similar to the behavior of the <a href="reference-trixi.html#Trixi.SaveSolutionCallback"><code>SaveSolutionCallback</code></a>:</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData2D(sol; solution_variables=cons2cons) # Plot conservative variables</code></pre><p>There are several other keyword arguments that influence how the solution data is processed for visualization with the Plots package. A detailed explanation can be found in the docstring of the <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a> constructor.</p><p>Another way to change the appearance of a plot is to convert the solution to a uniformly refined mesh before plotting. This can be helpful, e.g., when trying different settings for a simulation with adaptive mesh refinement, where one would like to ignore the mesh changes when comparing solutions. This is achieved with <a href="reference-trixi.html#Trixi.adapt_to_mesh_level-Tuple{Any, Any, Any}"><code>adapt_to_mesh_level</code></a>, which uses the mesh adaptation routines to adapt the solution to a uniform grid. For example, the AMR solution from above could be preprocessed with</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData2D(adapt_to_mesh_level(sol, 4)...)</code></pre><p>When plotted together with the mesh, this will yield the following visualization:</p><p><img src="https://user-images.githubusercontent.com/72009492/130951039-f2f91760-539a-4e96-ac39-4053e934040b.PNG" alt="plot-rho-uniform-mesh"/></p><h2 id="Plotting-a-user-defined-scalar-field"><a class="docs-heading-anchor" href="#Plotting-a-user-defined-scalar-field">Plotting a user-defined scalar field</a><a id="Plotting-a-user-defined-scalar-field-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-a-user-defined-scalar-field" title="Permalink"></a></h2><p>To plot a scalar quantity, one can call <code>plot(ScalarPlotData2D(u, semi))</code>, where <code>u</code> is an array of nodal values of the scalar field to plot. The layout of <code>u</code> should match the layout of the <code>x</code> and <code>y</code> nodal coordinates of the respective solver. For example, after running <code>trixi_include(joinpath(&quot;examples&quot;, &quot;unstructured_2d_dgsem&quot;, &quot;elixir_euler_wall_bc.jl&quot;))</code>, the following can be used to plot the function <code>f(x, y) = x * y</code>:</p><pre><code class="language-julia hljs">x = view(semi.cache.elements.node_coordinates, 1, :, :, :)
y = view(semi.cache.elements.node_coordinates, 2, :, :, :)
plot(ScalarPlotData2D(x .* y, semi))</code></pre><p>This produces the following plot:</p><p><img src="https://user-images.githubusercontent.com/1156048/132762371-da141802-34e8-4035-a88d-4d60e66c9f19.png" alt="scalar-plotting-example"/></p><p>This routine can be used to visualize scalar quantities which depend on the solution, such as the norm of a velocity vector or two-dimensional vorticity. For example, we can visualize vorticity for a compressible version of the <a href="https://doi.org/10.1006/jcph.1995.1205">Brown-Minion vortex problem</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Trixi, Plots

julia&gt; redirect_stdout(devnull) do
         # runs the elixir without any output from callbacks etc.
         trixi_include(@__MODULE__,
           joinpath(examples_dir(), &quot;dgmulti_2d&quot;, &quot;elixir_euler_brown_minion_vortex.jl&quot;))
       end
[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.

julia&gt; function compute_vorticity(velocity, mesh, equations::CompressibleEulerEquations2D,
                                  dg::DGMulti, cache)
         rd = dg.basis
         md = mesh.md
         @unpack Dr, Ds = rd
         @unpack rxJ, sxJ, ryJ, syJ, J = md
         v1, v2 = velocity
         dv1dy = ryJ .* (Dr * v1) + syJ .* (Ds * v1)
         dv2dx = rxJ .* (Dr * v2) + sxJ .* (Ds * v2)
         return dv2dx - dv1dy
       end;

julia&gt; compute_vorticity(velocity, semi) =
         compute_vorticity(velocity, Trixi.mesh_equations_solver_cache(semi)...);

julia&gt; function get_velocity(sol)
         rho, rhou, rhov, E = StructArrays.components(sol.u[end])
         v1 = rhou ./ rho
         v2 = rhov ./ rho
         return v1, v2
       end;

julia&gt; vorticity = compute_vorticity(get_velocity(sol), semi);

julia&gt; plot(ScalarPlotData2D(vorticity, semi;
            variable_name = &quot;Vorticity at t = $(sol.prob.tspan[end])&quot;))
Plot{Plots.GRBackend() n=1}</code></pre><p>This produces the following plot of vorticity.</p><p><img src="https://user-images.githubusercontent.com/1156048/132884563-f371dd63-29c5-4856-a9c5-b1867fb1b1f6.png" alt="vorticity-example"/></p><p>Since the mesh is fairly coarse, we observe numerical artifacts due to the low resolution. These errors vanish under mesh refinement; for example, doubling the mesh resolution by running</p><pre><code class="language-julia hljs">julia&gt; trixi_include(joinpath(examples_dir(), &quot;dgmulti_2d&quot;, &quot;elixir_euler_BM_vortex.jl&quot;), cells_per_dimension = 32)</code></pre><p>yields the following plot of vorticity:</p><p><img src="https://user-images.githubusercontent.com/1156048/132885068-c2e37c97-c71a-489d-9a64-4f08db86552a.png" alt="vorticity-example-refined"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When visualizing a scalar field, the plotted solution is reinterpolated using a high order polynomial approximation. Thus, small discrepancies may be observed when the underlying data is highly non-smooth or under-resolved.</p></div></div><p><code>ScalarPlotData2D</code> objects can also be used with Makie through <code>iplot</code>. For example, the following code plots two surfaces:</p><pre><code class="language-julia-repl hljs">julia&gt; using Trixi, CairoMakie

julia&gt; redirect_stdout(devnull) do
         # runs the elixir without any output from callbacks etc.
         trixi_include(@__MODULE__,
           joinpath(examples_dir(), &quot;unstructured_2d_dgsem&quot;, &quot;elixir_euler_wall_bc.jl&quot;))
       end
[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.

julia&gt; x = view(semi.cache.elements.node_coordinates, 1, :, :, :); # extracts the node x coordinates

julia&gt; y = view(semi.cache.elements.node_coordinates, 2, :, :, :); # extracts the node y coordinates

julia&gt; fig_ax_plt = iplot(ScalarPlotData2D((@. 1 - .25*(x^2 + y^2)), semi), plot_mesh=true, colormap=:viridis);

julia&gt; fig_ax_plt2 = iplot!(fig_ax_plt, ScalarPlotData2D((@. .125*(x+y)), semi), plot_mesh=true, colormap=:blues)
FigureAxisPlot()</code></pre><p>This creates the following plot:</p><p><img src="https://user-images.githubusercontent.com/1156048/133856590-a9f0be02-8200-483b-af96-eab4a69bf2c7.png" alt="ScalarPlotData2D_example"/></p><h3 id="Plotting-a-3D-solution-as-a-2D-plot"><a class="docs-heading-anchor" href="#Plotting-a-3D-solution-as-a-2D-plot">Plotting a 3D solution as a 2D plot</a><a id="Plotting-a-3D-solution-as-a-2D-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-a-3D-solution-as-a-2D-plot" title="Permalink"></a></h3><p>It is possible to plot 2D slices from 3D simulation data using the <a href="reference-trixi.html#Trixi.TreeMesh"><code>TreeMesh</code></a> with the same commands as above:</p><pre><code class="language-julia hljs">julia&gt; plot(sol) # `sol` is from a 3D simulation</code></pre><p>By default, plotting <code>sol</code> or creating a <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a> object from a 3D simulation will create a 2D slice of the solution in the <code>xy</code>-plane. You can customize this behavior by explicitly creating a <code>PlotData2D</code> object and passing appropriate keyword arguments:</p><ul><li><code>slice</code> specifies the plane which is being sliced and can be <code>:xy</code>, <code>:xz</code>, or <code>:yz</code> (default: <code>:xy</code>)</li><li><code>point</code> specifies a three-dimensional point. The sliced plane is then created such that it lies on the point (default: <code>(0.0, 0.0, 0.0)</code>).</li></ul><p>All other attributes for <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a> objects apply here as well.</p><p>For example, to plot the velocity field orthogonal to the yz-plane at different x-axis locations, you can execute</p><pre><code class="language-julia hljs">julia&gt; trixi_include(joinpath(examples_dir(), &quot;tree_3d_dgsem&quot;, &quot;elixir_euler_taylor_green_vortex.jl&quot;), tspan=(0.0, 1.0))
[...]

julia&gt; plots = []
Any[]

julia&gt; for x in range(0, stop=pi/2, length=6)
         pd = PlotData2D(sol, slice=:yz, point=(x, 0.0, 0.0))
         push!(plots, plot(pd[&quot;v1&quot;], clims=(-1,1), title=&quot;x = &quot;*string(round(x, digits=2))))
       end

julia&gt; plot(plots..., layout=(2, 3), size=(750,350))</code></pre><p>which results in a 2x3 grid of slices of the <code>yz</code>-plane:</p><p><img src="https://user-images.githubusercontent.com/72009492/130953841-58df57b2-aa96-4130-9b70-30151856f68f.PNG" alt="plot-v1-0.0-to-0.5pi"/></p><h3 id="Creating-a-1D-plot"><a class="docs-heading-anchor" href="#Creating-a-1D-plot">Creating a 1D plot</a><a id="Creating-a-1D-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-1D-plot" title="Permalink"></a></h3><p>When plotting a 1D solution with</p><pre><code class="language-julia hljs">julia&gt; plot(sol) # `sol` is from a 1D simulation</code></pre><p>Trixi automatically creates a <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> object and visualizes it as a line plot: <img src="https://user-images.githubusercontent.com/3637659/119086020-1e3f4d80-ba05-11eb-873e-1b586a81e7fe.png" alt="1d-plot"/></p><p>To customize your 1D plot, you can create a <code>PlotData1D</code> object manually as follows:</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData1D(sol)
julia&gt; pd = PlotData1D(u, semi)</code></pre><p>The behavior is analogous to the <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a> behavior.</p><p>In a very similar fashion to <a href="reference-trixi.html#Trixi.PlotData2D-Tuple{Any, Any}"><code>PlotData2D</code></a>, you can customize your plot:</p><ul><li><code>plot(pd)</code> creates the same plot as in <code>plot(sol)</code>.</li><li><code>plot(pd[&quot;rho&quot;, &quot;p&quot;])</code> only plots specific variables. In this case <code>rho</code> and <code>p</code>.</li><li><code>plot!(getmesh(pd))</code> adds mesh lines after creating a plot.</li><li>Any attributes from <a href="https://docs.juliaplots.org/latest/">Plots</a> can be used, e.g., <code>plot(pd, yguide=:temperature)</code>.</li><li><code>pd = PlotData1D(adapt_to_mesh_level(sol, 4)...)</code> adapts the mesh before plotting (in this example to a mesh with refinement level 4).</li></ul><p>You can also customize the <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> object itself by passing attributes to the <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> constructor:</p><ul><li><code>solution_variables</code> specifies the variables to be plotted.</li><li><code>nvisnodes</code> sets the amount of nodes per element which the solution then is interpolated on.</li></ul><h3 id="Plotting-a-2D-or-3D-solutions-as-a-1D-plot"><a class="docs-heading-anchor" href="#Plotting-a-2D-or-3D-solutions-as-a-1D-plot">Plotting a 2D or 3D solutions as a 1D plot</a><a id="Plotting-a-2D-or-3D-solutions-as-a-1D-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-a-2D-or-3D-solutions-as-a-1D-plot" title="Permalink"></a></h3><p>It is possible to extract a straight, axis-parallel line from a 2D or 3D solution and visualize it as a 1D plot. This is done by creating a <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> object with a 2D/3D solution <code>sol</code> as input:</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData1D(sol)</code></pre><p>The plot is then created with:</p><pre><code class="language-julia hljs">julia&gt; plot(pd)</code></pre><p>By default the <code>x</code>-axis is extracted, which can be changed with following attributes:</p><ul><li><code>slice</code> specifies the axis which is being extracted and can be <code>:x</code>, <code>:y</code> or <code>:z</code> (<code>:z</code> is only for 3D input and default is <code>:x</code>)</li><li><code>point</code> specifies a two or three dimensional point. The sliced axis is then created in such a way, that it lies on the point. (default: <code>(0.0, 0.0)</code> or <code>(0.0, 0.0, 0.0)</code>)</li></ul><p>All other attributes for <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> objects apply here as well.</p><p>In the following, is an example for a 2D simulation of the linear scalar advection equation. First, we have the regular 2D heatmap plot:</p><p><img src="https://user-images.githubusercontent.com/72009492/116614302-0f033d80-a93a-11eb-91a1-e44de41e0795.PNG" alt="2d-plot-for-slice"/></p><p>From this, we can extract a line plot parallel to the <code>y</code>-axis going through the point <code>(1.0, 0.0)</code> with the following commands:</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData1D(sol, slice=:y, point=(1.0, 0.0))
julia&gt; plot(pd)</code></pre><p><img src="https://user-images.githubusercontent.com/72009492/116614340-1b879600-a93a-11eb-9a80-f46311da16b1.PNG" alt="1d-plot-for-slice"/></p><p>This convenient method of slicing is limited to axis-parallel slices, but for 2D/3D solutions it is also possible to create a plot along any curve you want. To do so, you first need to create a list of 2D/3D points that define your curve. Then you can create a <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> with the keyword argument <code>curve</code> set to your list.</p><p>Let&#39;s give an example of this with the basic advection equation from above by creating a plot along the circle marked in green:</p><p><img src="https://user-images.githubusercontent.com/72009492/130951042-e1849447-8e55-4798-9361-c8badb9f3a49.png" alt="2d-plot-along-cirlce"/></p><p>We can write a function like this, that outputs a list of points on a circle:</p><pre><code class="language-julia hljs">function circle(radius, center, n_points)
    coordinates = zeros(2, n_points)
    for i in 1:n_points
        coordinates[:,i] = radius*[cospi(2*i/n_points), sinpi(2*i/n_points)] .+ center
    end
    return coordinates
end</code></pre><p>Then create and plot a <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> object along a circle with radius one, center at <code>(1,1)</code>, and 100 points:</p><pre><code class="language-julia hljs">pd = PlotData1D(sol, curve=circle(1.0, (1.0, 1.0), 100))
plot(pd)</code></pre><p>This gives you the following plot: <img src="https://user-images.githubusercontent.com/72009492/118874948-c3660300-b8eb-11eb-8e5e-8ce50e21336e.PNG" alt="1d-plot-along-circle"/></p><p>Creating a plot like this has its downsides. For one, it is unclear what to put on the abscissa of the plot. By default, the arc length of the given curve is used. Also, with this way of plotting you lose the ability to use a mesh plot from <code>getmesh</code>.</p><h3 id="Visualizing-results-during-a-simulation"><a class="docs-heading-anchor" href="#Visualizing-results-during-a-simulation">Visualizing results during a simulation</a><a id="Visualizing-results-during-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-results-during-a-simulation" title="Permalink"></a></h3><p>To visualize solutions while a simulation is still running (also known as <em>in-situ visualization</em>), you can use the <a href="reference-trixi.html#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a>. It is created as a regular callback and accepts upon creation a number of keyword arguments that allow, e.g., to control the visualization interval, to specify the variables to plot, or to customize the plotting style.</p><p>During the simulation, the visualization callback creates and displays visualizations of the current solution in regular intervals. This can be useful to, e.g., monitor the validity of a long-running simulation or for illustrative purposes. An example for how to create a <code>VisualizationCallback</code> can be found in <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_advection_amr_visualization.jl">examples/tree<em>2d</em>dgsem/elixir_advection_amr_visualization.jl</a>:</p><pre><code class="language-julia hljs">[...]

# Enable in-situ visualization with a new plot generated every 20 time steps
# and additional plotting options passed as keyword arguments
visualization = VisualizationCallback(interval=20; clims=(0,1))

[...]</code></pre><p>The resulting output of the referenced elixir can be seen in the embedded video below:</p>  <!--
  Video creation details
  * Set up terminal size and position appropriately
  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)
  * Upload to YouTube
  * Obtain responsive code by inserting link on https://embedresponsively.com
  -->
  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/UZtrqeDY1Fs' frameborder='0' allowfullscreen></iframe></div><h2 id="Trixi2Vtk"><a class="docs-heading-anchor" href="#Trixi2Vtk">Trixi2Vtk</a><a id="Trixi2Vtk-1"></a><a class="docs-heading-anchor-permalink" href="#Trixi2Vtk" title="Permalink"></a></h2><p>Trixi2Vtk converts Trixi&#39;s <code>.h5</code> output files to VTK files, which can be read by <a href="https://www.paraview.org">ParaView</a>, <a href="https://visit.llnl.gov">VisIt</a>, and other visualization tools. It automatically interpolates solution data from the original quadrature node locations to equidistant <em>visualization nodes</em> at a higher resolution, to make up for the loss of accuracy from going from a high-order polynomial representation to a piecewise constant representation in VTK.</p><p>In the Julia REPL, first load the package Trixi2Vtk</p><pre><code class="language-julia hljs">julia&gt; using Trixi2Vtk</code></pre><p>To process an HDF5 file generated by Trixi.jl, execute</p><pre><code class="language-julia hljs">julia&gt; trixi2vtk(joinpath(&quot;out&quot;, &quot;solution_000000.h5&quot;), output_directory=&quot;out&quot;)</code></pre><p>This will create two unstructured VTK files in the <code>out</code> subdirectory that can be opened with ParaView or VisIt: <code>solution_000000.vtu</code> contains the discontinuous Galerkin solution data while <code>solution_000000_celldata.vtu</code> holds any cell-based values such as the current AMR indicator or the cell refinement level.</p><p><img src="https://github.com/trixi-framework/Trixi2Vtk.jl/raw/main/docs/src/assets/solution_000000_scalar_mesh.png" alt="&quot;solution_000000_scalar_mesh&quot;"/></p><p>This allows you to generate VTK files for solution, restart and mesh files. By default, Trixi2Vtk generates <code>.vtu</code> (unstructured VTK) files for both cell/element data (e.g., cell ids, element ids) and node data (e.g., solution variables). This format visualizes each cell with the same number of nodes, independent of its size.  Alternatively, you can provide <code>format=:vti</code> as a keyword argument to <code>trixi2vtk</code>, which causes Trixi2Vtk to generate <code>.vti</code> (image data VTK) files for the solution files, while still using <code>.vtu</code> files for cell-/element-based data. In <code>.vti</code> files, a uniform resolution is used throughout the entire domain, resulting in different number of visualization nodes for each element.  This can be advantageous to create publication-quality images, but increases the file size.</p><p>If you want to convert multiple solution/restart files at once, you can just supply multiple input files as the positional arguments to <code>trixi2vtk</code>, e.g.,</p><pre><code class="language-julia hljs">julia&gt; trixi2vtk(&quot;out/solution_000000.h5&quot;, &quot;out/solution_000040.h5&quot;)</code></pre><p>You may also use file globbing to select a range of files based on filename patterns, e.g.,</p><pre><code class="language-julia hljs">julia&gt; trixi2vtk(&quot;out/solution_*.h5&quot;)</code></pre><p>to convert all solution files in the <code>out/</code> directory or</p><pre><code class="language-julia hljs">julia&gt; trixi2vtk(&quot;out/restart_00[0-9]000.h5&quot;)</code></pre><p>to convert every one-thousandth restart file (<code>out/restart_000000.h5</code>, <code>out/restart_001000.h5</code> etc.).</p><p>When multiple solution/restart files are provided, Trixi2Vtk will also generate a <code>.pvd</code> file, which allows ParaView to read all <code>.vtu</code>/<code>.vti</code> files at once and which uses the <code>time</code> attribute in solution/restart files to inform ParaView about the solution time. A comprehensive list of all possible arguments for <code>trixi2vtk</code> can be found in the <a href="reference-trixi2vtk.html#Trixi2Vtk.jl-API">Trixi2Vtk.jl API</a>.</p><p>Further information regarding the development of Trixi2Vtk can be found in the</p><h2 id="Makie.jl"><a class="docs-heading-anchor" href="#Makie.jl">Makie.jl [experimental]</a><a id="Makie.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Makie.jl" title="Permalink"></a></h2><p>In addition to <a href="visualization.html#Plots.jl">Plots.jl</a> support, Trixi includes visualization utilities through <a href="https://github.com/JuliaPlots/Makie.jl/">Makie.jl</a>. Trixi provides Makie-based visualization options both for heatmap-type plots (similar to the <a href="visualization.html#Plots.jl">Plots.jl</a> recipes) as well as for interactive surface plots. Support is currently limited to the <a href="reference-trixi.html#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a> type.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Plotting via Makie.jl is still considered an experimental feature and might change in any future releases.</p></div></div><p>A Makie plot can be created as follows: after running a simulation with Trixi in the REPL, load a Makie backend (for example, <a href="https://github.com/JuliaPlots/GLMakie.jl/">GLMakie</a> or <a href="https://github.com/JuliaPlots/CairoMakie.jl">CairoMakie</a>).</p><pre><code class="language-julia hljs">julia&gt; using GLMakie</code></pre><p>To visualize the solution and mesh with a heatmap-type plot, simply run</p><pre><code class="language-julia hljs">julia&gt; plot(sol)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Both Makie.jl and Plots.jl export <code>plot</code>, so if you load both libraries, you will have to specify which <code>plot</code> function to call via <code>Plots.plot</code> or <code>Makie.plot</code>.</p></div></div><p>As with Plots.jl recipes, one can view individual solution components by creating a <code>PlotData2D</code> object and indexing into it with the desired variable name</p><pre><code class="language-julia hljs">julia&gt; pd = PlotData2D(sol)
julia&gt; plot(pd[&quot;rho&quot;])</code></pre><p>Unlike the Plots.jl recipe, mesh plotting is controlled using the keyword argument <code>plot_mesh = false</code>, e.g.,</p><pre><code class="language-julia hljs">julia&gt; plot(sol; plot_mesh=false)</code></pre><p>The plot command also returns figure and axis handles, which can be used to edit plot titles or labels:</p><pre><code class="language-julia hljs">julia&gt; fig, axes = plot(sol)
julia&gt; axes[1,1].title = &quot;New title for subplot (1,1)&quot;</code></pre><p>Trixi also supports interactive surface plots using <code>iplot</code>. After executing</p><pre><code class="language-julia hljs">julia&gt; trixi_include(joinpath(&quot;examples&quot;, &quot;unstructured_2d_dgsem&quot;, &quot;elixir_euler_wall_bc.jl&quot;))</code></pre><p>we can run</p><pre><code class="language-julia hljs">julia&gt; iplot(sol)</code></pre><p>This will open up an interactive visualization window:</p><p><img src="https://user-images.githubusercontent.com/1156048/131613261-dccd1c73-1c06-4770-afe5-d625d3426dfd.png" alt="makie-example"/></p><p>The plot can be rotated (click and hold), zoomed in and out (scroll up and down), and panned (hold right click and drag). Two toggle buttons control whether mesh lines are visible on top of and below the solution.</p><p>Both <code>plot</code> and <code>iplot</code> use <code>colormap = :inferno</code> by default. <a href="https://docs.juliaplots.org/latest/generated/colorschemes/">A different colormap</a> can be selected by providing an appropriate keyword argument. For example, <code>plot(sol, colormap=:blues)</code> and <code>iplot(sol, colormap=:blues)</code> produce the following figures:</p><p><img src="https://user-images.githubusercontent.com/1156048/132954265-e7d395a8-f894-4056-841b-87711b7ba012.png" alt="makie-plot-example"/> <img src="https://user-images.githubusercontent.com/1156048/131613266-8a86a074-62fb-49d6-bf6b-8df94d2a9b65.png" alt="makie-iplot-example"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="overview.html">« Overview</a><a class="docs-footer-nextpage" href="tutorials/introduction.html">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 April 2023 00:22">Sunday 2 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
