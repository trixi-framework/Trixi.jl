<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unstructured mesh · Trixi.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/meshes\\unstructured_quad_mesh.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Trixi.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview.html">Overview</a></li><li><a class="tocitem" href="../visualization.html">Visualization</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/introduction.html">Introduction</a></li><li><a class="tocitem" href="../tutorials/getting_started_with_Trixi.html">1 Getting started with Trixi</a></li><li><a class="tocitem" href="../tutorials/scalar_linear_advection_1d.html">2 Introduction to DG methods</a></li><li><a class="tocitem" href="../tutorials/DGSEM_FluxDiff.html">3 DGSEM with flux differencing</a></li><li><a class="tocitem" href="../tutorials/shock_capturing.html">4 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="../tutorials/non_periodic_boundaries.html">5 Non-periodic boundaries</a></li><li><a class="tocitem" href="../tutorials/DGMulti_1.html">6 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../tutorials/DGMulti_2.html">7 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../tutorials/upwind_fdsbp.html">8 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../tutorials/adding_new_scalar_equations.html">9 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../tutorials/adding_nonconservative_equation.html">10 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../tutorials/parabolic_terms.html">11 Parabolic terms</a></li><li><a class="tocitem" href="../tutorials/adding_new_parabolic_terms.html">12 Adding new parabolic terms</a></li><li><a class="tocitem" href="../tutorials/adaptive_mesh_refinement.html">13 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../tutorials/structured_mesh_mapping.html">14 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../tutorials/hohqmesh_tutorial.html">15 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../tutorials/time_stepping.html">16 Explicit time stepping</a></li><li><a class="tocitem" href="../tutorials/differentiable_programming.html">17 Differentiable programming</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tree_mesh.html">Tree mesh</a></li><li><a class="tocitem" href="structured_mesh.html">Structured mesh</a></li><li class="is-active"><a class="tocitem" href="unstructured_quad_mesh.html">Unstructured mesh</a><ul class="internal"><li><a class="tocitem" href="#Mesh-file-header"><span>Mesh file header</span></a></li><li><a class="tocitem" href="#List-of-corner-nodes"><span>List of corner nodes</span></a></li><li><a class="tocitem" href="#List-of-neighbor-connectivity"><span>List of neighbor connectivity</span></a></li><li><a class="tocitem" href="#List-of-elements"><span>List of elements</span></a></li><li><a class="tocitem" href="#Trixi.jl-on-an-unstructured-quadrilateral-mesh"><span>Trixi.jl on an unstructured quadrilateral mesh</span></a></li></ul></li><li><a class="tocitem" href="p4est_mesh.html">P4est-based mesh</a></li><li><a class="tocitem" href="dgmulti_mesh.html">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../time_integration.html">Time integration</a></li><li><a class="tocitem" href="../callbacks.html">Callbacks</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../conventions.html">Conventions</a></li><li><a class="tocitem" href="../development.html">Development</a></li><li><a class="tocitem" href="../github-git.html">GitHub &amp; Git</a></li><li><a class="tocitem" href="../styleguide.html">Style guide</a></li><li><a class="tocitem" href="../testing.html">Testing</a></li><li><a class="tocitem" href="../performance.html">Performance</a></li><li><a class="tocitem" href="../parallelization.html">Parallelization</a></li></ul></li><li><a class="tocitem" href="../troubleshooting.html">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference-trixi.html">Trixi.jl</a></li><li><a class="tocitem" href="../reference-trixi2vtk.html">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../authors.html">Authors</a></li><li><a class="tocitem" href="../contributing.html">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct.html">Code of Conduct</a></li><li><a class="tocitem" href="../license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic building blocks</a></li><li><a class="is-disabled">Meshes</a></li><li class="is-active"><a href="unstructured_quad_mesh.html">Unstructured mesh</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="unstructured_quad_mesh.html">Unstructured mesh</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/meshes/unstructured_quad_mesh.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Unstructured-quadrilateral-mesh"><a class="docs-heading-anchor" href="#Unstructured-quadrilateral-mesh">Unstructured quadrilateral mesh</a><a id="Unstructured-quadrilateral-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Unstructured-quadrilateral-mesh" title="Permalink"></a></h1><p>The <a href="../reference-trixi.html#Trixi.UnstructuredMesh2D"><code>UnstructuredMesh2D</code></a> is an unstructured, curvilinear, conforming mesh type in two space dimensions.</p><p>Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the <code>normal::AbstractVector</code>. Rotationally invariant equations such as the compressible Euler equations can use <a href="../reference-trixi.html#Trixi.FluxRotated"><code>FluxRotated</code></a> to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the <a href="../reference-trixi.html#Trixi.TreeMesh"><code>TreeMesh</code></a> but is usually less efficient, cf. <a href="https://github.com/trixi-framework/Trixi.jl/pull/550">PR #550</a>.</p><p>Next, we describe the conventions taken in the implementation for two-dimensional unstructured quadrilateral meshes. Principally, this relates to how a file with the extension <code>.mesh</code> encodes information about the numbering and orientation of elements in an unstructured quadrilateral mesh with possibly curved boundaries.</p><p>We use the following unstructured mesh with three elements for this discussion:</p><p><img src="https://user-images.githubusercontent.com/25242486/117508011-2e2c4b80-af88-11eb-8b15-949fc2d43253.png" alt="example-mesh"/></p><p>Further, a simulation using Trixi on this example unstructured mesh is provided in <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/unstructured_2d_dgsem/elixir_euler_basic.jl"><code>examples/unstructured_2d_dgsem/elixir_euler_basic.jl</code></a>.</p><h2 id="Mesh-file-header"><a class="docs-heading-anchor" href="#Mesh-file-header">Mesh file header</a><a id="Mesh-file-header-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-file-header" title="Permalink"></a></h2><p>The first two lines of the mesh file lists the mesh file type as well as the total number of <em>corners</em>, <em>surfaces</em>, <em>elements</em>, and the <em>polynomial degree</em> that the mesh will use to represent any curved sides. For the example mesh these quantities are</p><pre><code class="nohighlight hljs">ISM-V2
    7    9    3    8</code></pre><p>corresponding to seven corners, nine surfaces, and three elements. The mesh polynomial degree of eight is taken only for illustrative purposes. In practice, this mesh polynomial degree depends on the particular application for which the curved, unstructured mesh is required.</p><h2 id="List-of-corner-nodes"><a class="docs-heading-anchor" href="#List-of-corner-nodes">List of corner nodes</a><a id="List-of-corner-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-corner-nodes" title="Permalink"></a></h2><p>After these global counts that prescribe information about the mesh skeleton, the mesh file give a list of the physical <code>(x,y)</code> coordinates of all the corners. The corner nodes are listed in the order prescribed by mesh generator. Thus, for the example mesh this node list would be</p><pre><code class="nohighlight hljs"> 1.0    -1.0
 3.0    0.0
 1.0    1.0
 2.0    0.0
 0.0    0.0
 3.0    1.0
 3.0    -1.0</code></pre><p>The corner nodes are internally referenced by their position in the list above. For example, here the node at <code>(1.0, -1.0)</code> would have node id 1, node id 2 would be at <code>(3.0, 0.0)</code> etc.</p><h2 id="List-of-neighbor-connectivity"><a class="docs-heading-anchor" href="#List-of-neighbor-connectivity">List of neighbor connectivity</a><a id="List-of-neighbor-connectivity-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-neighbor-connectivity" title="Permalink"></a></h2><p>After the corner list comes the neighbor connectivity along each surface in the mesh. This includes local indexing and orientation information necessary to compute the coupling between elements in the mesh. In 2D each surface is defined by connecting two nodes indexed as with the numbering above. We adopt the convention that node id 1 &lt; node id 2.</p><p>Each surface will have two neighbors where the element on the left locally as one &quot;walks&quot; from node id 1 to node id 2 is taken to be the <code>primary</code> element and the element locally on the right is taken to be the <code>secondary</code> element. If, however, there is no secondary element index, then the surface lies along a physical boundary. In this case the only available element index is considered to be <code>primary</code> and the secondary index is set to zero.</p><p>The final two index numbers within the neighbor information list are used to identify the local surface within each element. The first local surface index (on the primary element) will always be positive whereas the second local surface index (on the primary element) can be positive or negative. If the second local surface index is positive, then the local coordinate systems in the primary element and secondary element match, i.e., the indexing on either side runs from <code>1:polydeg+1</code>. However, if the local surface index of the secondary element is negative in the mesh file, then the coordinate system in the secondary element is <strong>flipped</strong> with respect to the primary element. Therefore, care must be taken in the implementation to ensure that the primary element indexing runs from <code>1:polydeg+1</code> whereas the secondary element indexing must run in reverse from <code>polydeg+1:-1:1</code>. Finally, if the secondary element index is zero, then so will be the local surface index because the surface is on a physical boundary. Also, there is no <em>flipping</em> of coordinate indexing required at the physical boundary because only the primary element&#39;s coordinate system exists.</p><h3 id="Three-examples:-One-along-a-physical-boundary-and-two-along-interior-surfaces."><a class="docs-heading-anchor" href="#Three-examples:-One-along-a-physical-boundary-and-two-along-interior-surfaces.">Three examples: One along a physical boundary and two along interior surfaces.</a><a id="Three-examples:-One-along-a-physical-boundary-and-two-along-interior-surfaces.-1"></a><a class="docs-heading-anchor-permalink" href="#Three-examples:-One-along-a-physical-boundary-and-two-along-interior-surfaces." title="Permalink"></a></h3><p>Along edge <code>{8}</code> we connect node <code>(2)</code> to node <code>(7)</code> and are along a physical boundary in element <code>3</code> with the local surface index 1 and the neighbor information:</p><pre><code class="nohighlight hljs">    2    7    3    0    1    0</code></pre><p>Along edge <code>{1}</code> we connect node <code>(2)</code> to node <code>(4)</code> such that the primary element is <code>3</code> with local surface index <code>2</code> and the secondary element is <code>2</code> with local surface index <code>1</code>. Furthermore, we see that coordinate system in the secondary element <code>2</code> is <strong>flipped</strong> with respect to the primary element&#39;s coordinate system such that the sign of the local surface index in the secondary element flips. This gives the following neighbor information:</p><pre><code class="nohighlight hljs">    2    4    3    2    2    -1</code></pre><p>Along edge <code>{4}</code> we connect node <code>(1)</code> to node <code>(4)</code> such that the primary element is <code>1</code> with local surface index <code>2</code> and the secondary element is <code>3</code> with local surface index <code>3</code>. The coordinate systems in both elements match and no sign change is required on the local surface index in the secondary element:</p><pre><code class="nohighlight hljs">    1    4    1    3    2    3</code></pre><p>We collect the complete neighbor information for the example mesh above:</p><pre><code class="nohighlight hljs">    2    4    3    2    2    -1
    3    5    1    0    4    0
    1    5    1    0    1    0
    1    4    1    3    2    3
    2    6    2    0    2    0
    1    7    3    0    4    0
    3    6    2    0    3    0
    2    7    3    0    1    0
    3    4    2    1    4    -3</code></pre><h2 id="List-of-elements"><a class="docs-heading-anchor" href="#List-of-elements">List of elements</a><a id="List-of-elements-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-elements" title="Permalink"></a></h2><p>Each quadrilateral element in the unstructured mesh is dictated by four corner points with indexing taken from the numbering given by the corner list above. We connect a set of four corner points (starting from the bottom left) in an anti-clockwise fashion thus making the element <em>right-handed</em> indicated using the circular arrow in the figure above. In turn, this right-handedness defines the local surface indexing (i.e. the four local sides) and the local <span>$(\xi, \eta)$</span> coordinate system. For example, the four corners for element 1 would be listed as</p><pre><code class="nohighlight hljs">    5    1    4    3</code></pre><p>The mesh file also encodes information for curved surfaces either interior to the domain (as surface <code>{9}</code> above) or along the physical boundaries. A set of check digits are included directly below the four corner indexes to indicate whether the local surface index (<code>1</code>, <code>2</code>, <code>3</code>, or <code>4</code>) within the element is straight sided, <code>0</code>, or is curved, <code>1</code>. If the local surface is straight sided no additional information is necessary during the mesh file read in. But for any curved surfaces the mesh file provides <code>(x,y)</code> coordinate values in order to construct an interpolant of this surface with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes. This list of <code>(x,y)</code> data will be given in the direction of the local coordinate system.</p><p>The last piece of information provided by the mesh file are labels for the different surfaces of an element. These labels are useful to set boundary conditions along physical surfaces. The labels can be short descriptive words. The label <code>---</code> indicates an internal surface where no boundary condition is required.</p><p>As an example, the complete information for element <code>1</code> in the example mesh would be</p><pre><code class="nohighlight hljs">    5    1    4    3
    0    0    1    1
 1.000000000000000   1.000000000000000
 1.024948365654583   0.934461926834452
 1.116583018200151   0.777350964621867
 1.295753434047077   0.606254343587194
 1.537500000000000   0.462500000000000
 1.768263070247418   0.329729152118310
 1.920916981799849   0.185149035378133
 1.986035130050921   0.054554577460044
 2.000000000000000                 0.0
               0.0                 0.0
 0.035513826946206   0.105291711848750
 0.148591270347399   0.317731556850611
 0.340010713990041   0.452219430075470
 0.575000000000000   0.462500000000000
 0.788022294598950   0.483764065630034
 0.926408729652601   0.644768443149389
 0.986453164464803   0.883724792445746
 1.000000000000000   1.000000000000000
 Slant --- --- Bezier</code></pre><p>where the curved boundary information is encoded &quot;back to back&quot;. That is, the first nine <code>(x,y)</code> nodes in the list above correspond to the interior boundary curve along local side <code>3</code> in element <code>1</code> and the next nine <code>(x,y)</code> nodes denote the curved physical boundary named <code>Bezier</code> along local side <code>4</code>.</p><p>We collect the complete set of element information for the example mesh</p><pre><code class="nohighlight hljs">    5    1    4    3
    0    0    1    1
 1.000000000000000   1.000000000000000
 1.024948365654583   0.934461926834452
 1.116583018200151   0.777350964621867
 1.295753434047077   0.606254343587194
 1.537500000000000   0.462500000000000
 1.768263070247418   0.329729152118310
 1.920916981799849   0.185149035378133
 1.986035130050921   0.054554577460044
 2.000000000000000                 0.0
               0.0                 0.0
 0.035513826946206   0.105291711848750
 0.148591270347399   0.317731556850611
 0.340010713990041   0.452219430075470
 0.575000000000000   0.462500000000000
 0.788022294598950   0.483764065630034
 0.926408729652601   0.644768443149389
 0.986453164464803   0.883724792445746
 1.000000000000000   1.000000000000000
 Slant --- --- Bezier
    4    2    6    3
    0    0    0    1
 2.000000000000000                 0.0
 1.986035130050921   0.054554577460044
 1.920916981799849   0.185149035378133
 1.768263070247418   0.329729152118310
 1.537500000000000   0.462500000000000
 1.295753434047077   0.606254343587194
 1.116583018200151   0.777350964621867
 1.024948365654583   0.934461926834452
 1.000000000000000   1.000000000000000
 --- Right Top ---
    7    2    4    1
    0    0    0    0
 Right --- --- Bottom</code></pre><h2 id="Trixi.jl-on-an-unstructured-quadrilateral-mesh"><a class="docs-heading-anchor" href="#Trixi.jl-on-an-unstructured-quadrilateral-mesh">Trixi.jl on an unstructured quadrilateral mesh</a><a id="Trixi.jl-on-an-unstructured-quadrilateral-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Trixi.jl-on-an-unstructured-quadrilateral-mesh" title="Permalink"></a></h2><p>We provide an example simulation on an unstructured quadrilateral mesh by executing</p><pre><code class="language-julia hljs">julia&gt; trixi_include(default_example_unstructured())</code></pre><p>Note this may download a copy of the mesh file described above for the three element unstructured mesh. This elixir provides the solution for the compressible Euler equations in two spatial dimensions for a smooth propagating wave solution. Below we provide the time evolution of the pressure wave for this example created with the <code>Trixi2Vtk</code> tool and visualized using ParaView.</p>  <!--
  Video creation details
  * Set up terminal size and position appropriately
  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)
  * Upload to YouTube
  * Obtain responsive code by inserting link on https://embedresponsively.com
  -->
  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/lS8GjuctXAY' frameborder='0' allowfullscreen></iframe></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="structured_mesh.html">« Structured mesh</a><a class="docs-footer-nextpage" href="p4est_mesh.html">P4est-based mesh »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 April 2023 00:22">Sunday 2 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
