<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>P4est-based mesh · Trixi.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/meshes\\p4est_mesh.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Trixi.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview.html">Overview</a></li><li><a class="tocitem" href="../visualization.html">Visualization</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/introduction.html">Introduction</a></li><li><a class="tocitem" href="../tutorials/getting_started_with_Trixi.html">1 Getting started with Trixi</a></li><li><a class="tocitem" href="../tutorials/scalar_linear_advection_1d.html">2 Introduction to DG methods</a></li><li><a class="tocitem" href="../tutorials/DGSEM_FluxDiff.html">3 DGSEM with flux differencing</a></li><li><a class="tocitem" href="../tutorials/shock_capturing.html">4 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="../tutorials/non_periodic_boundaries.html">5 Non-periodic boundaries</a></li><li><a class="tocitem" href="../tutorials/DGMulti_1.html">6 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../tutorials/DGMulti_2.html">7 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../tutorials/upwind_fdsbp.html">8 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../tutorials/adding_new_scalar_equations.html">9 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../tutorials/adding_nonconservative_equation.html">10 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../tutorials/parabolic_terms.html">11 Parabolic terms</a></li><li><a class="tocitem" href="../tutorials/adding_new_parabolic_terms.html">12 Adding new parabolic terms</a></li><li><a class="tocitem" href="../tutorials/adaptive_mesh_refinement.html">13 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../tutorials/structured_mesh_mapping.html">14 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../tutorials/hohqmesh_tutorial.html">15 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../tutorials/time_stepping.html">16 Explicit time stepping</a></li><li><a class="tocitem" href="../tutorials/differentiable_programming.html">17 Differentiable programming</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tree_mesh.html">Tree mesh</a></li><li><a class="tocitem" href="structured_mesh.html">Structured mesh</a></li><li><a class="tocitem" href="unstructured_quad_mesh.html">Unstructured mesh</a></li><li class="is-active"><a class="tocitem" href="p4est_mesh.html">P4est-based mesh</a><ul class="internal"><li><a class="tocitem" href="#Construction-of-a-P4estMesh-from-an-Abaqus-file"><span>Construction of a P4estMesh from an Abaqus file</span></a></li></ul></li><li><a class="tocitem" href="dgmulti_mesh.html">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../time_integration.html">Time integration</a></li><li><a class="tocitem" href="../callbacks.html">Callbacks</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../conventions.html">Conventions</a></li><li><a class="tocitem" href="../development.html">Development</a></li><li><a class="tocitem" href="../github-git.html">GitHub &amp; Git</a></li><li><a class="tocitem" href="../styleguide.html">Style guide</a></li><li><a class="tocitem" href="../testing.html">Testing</a></li><li><a class="tocitem" href="../performance.html">Performance</a></li><li><a class="tocitem" href="../parallelization.html">Parallelization</a></li></ul></li><li><a class="tocitem" href="../troubleshooting.html">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference-trixi.html">Trixi.jl</a></li><li><a class="tocitem" href="../reference-trixi2vtk.html">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../authors.html">Authors</a></li><li><a class="tocitem" href="../contributing.html">Contributing</a></li><li><a class="tocitem" href="../code_of_conduct.html">Code of Conduct</a></li><li><a class="tocitem" href="../license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic building blocks</a></li><li><a class="is-disabled">Meshes</a></li><li class="is-active"><a href="p4est_mesh.html">P4est-based mesh</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="p4est_mesh.html">P4est-based mesh</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/meshes/p4est_mesh.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="P4est-based-mesh"><a class="docs-heading-anchor" href="#P4est-based-mesh">P4est-based mesh</a><a id="P4est-based-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#P4est-based-mesh" title="Permalink"></a></h1><p>The <a href="../reference-trixi.html#Trixi.P4estMesh"><code>P4estMesh</code></a> is an unstructured, curvilinear, nonconforming mesh type for quadrilateral (2D) and hexahedral (3D) cells. It supports quadtree/octree-based adaptive mesh refinement (AMR) via the C library <a href="https://github.com/cburstedde/p4est"><code>p4est</code></a>. See <a href="../reference-trixi.html#Trixi.AMRCallback"><code>AMRCallback</code></a> for further information.</p><p>Due to its curvilinear nature, (numerical) fluxes need to implement methods dispatching on the <code>normal::AbstractVector</code>. Rotationally invariant equations such as the compressible Euler equations can use <a href="../reference-trixi.html#Trixi.FluxRotated"><code>FluxRotated</code></a> to wrap numerical fluxes implemented only for Cartesian meshes. This simplifies the re-use of existing functionality for the <a href="../reference-trixi.html#Trixi.TreeMesh"><code>TreeMesh</code></a> but is usually less efficient, cf. <a href="https://github.com/trixi-framework/Trixi.jl/pull/550">PR #550</a>.</p><h2 id="Construction-of-a-P4estMesh-from-an-Abaqus-file"><a class="docs-heading-anchor" href="#Construction-of-a-P4estMesh-from-an-Abaqus-file">Construction of a P4estMesh from an Abaqus file</a><a id="Construction-of-a-P4estMesh-from-an-Abaqus-file-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-of-a-P4estMesh-from-an-Abaqus-file" title="Permalink"></a></h2><p>One available option to construct a <a href="../reference-trixi.html#Trixi.P4estMesh"><code>P4estMesh</code></a> is to read in an Abaqus (<code>.inp</code>) mesh file. We briefly describe the structure of this file, the conventions it uses, and how the mesh file is parsed to create an initial unstructured, curvilinear, and conforming mesh.</p><h3 id="Mesh-in-two-spatial-dimensions"><a class="docs-heading-anchor" href="#Mesh-in-two-spatial-dimensions">Mesh in two spatial dimensions</a><a id="Mesh-in-two-spatial-dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-in-two-spatial-dimensions" title="Permalink"></a></h3><p>For this discussion we use the following two-dimensional unstructured curved mesh with three elements:</p><p><img src="https://user-images.githubusercontent.com/25242486/139241997-88e70a01-286f-4cee-80b1-2fd83c60bcca.png" alt="abaqus-2dmesh-docs"/></p><p>We note that the corner and element connectivity information parsed from the Abaqus file creates a straight sided (linear) mesh. From this linear mesh there are two strategies available to make the mesh curvilinear:</p><ol><li>Apply a <code>mapping</code> function to describe a transformation of the linear mesh to another physical domain. The mapping is approximated using interpolation polynomial of a user specified polynomial degree. The default value of this polynomial degree is <code>1</code> that corresponds to an uncurved geometry.</li><li>High-order boundary information is available in the <code>.inp</code> mesh file because it was created with the <a href="https://github.com/trixi-framework/HOHQMesh">HOHQMesh</a> mesh generator, which is available via the Julia package <a href="https://github.com/trixi-framework/HOHQMesh.jl">HOHQMesh.jl</a>. This information is used to create appropriate transfinite mappings during the mesh construction.</li></ol><p>We divide our discussion into two parts. The first part discusses the standard corner and element information contained in the <code>.inp</code> mesh file. The second part specifically deals with the mesh file parsing of an Abaqus file created by HOHQMesh.jl.</p><h4 id="Mesh-file-header"><a class="docs-heading-anchor" href="#Mesh-file-header">Mesh file header</a><a id="Mesh-file-header-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-file-header" title="Permalink"></a></h4><p>An Abaqus <code>.inp</code> mesh file typically begins with a <code>*Heading</code>. Though <em>optional</em>, the <code>*Heading</code> is helpful to give users some information about the mesh described by the mesh file. In particular, a <code>.inp</code> mesh file created with <code>HOHQMesh</code> will contain the header</p><pre><code class="nohighlight hljs">*Heading
 File created by HOHQMesh</code></pre><p>This heading is used to indicate to the mesh constructor which of the above mapping strategies to apply in order to create a curvilinear mesh. If the Abaqus file header is <strong>not</strong> present then the <code>P4estMesh</code> is created with the first strategy above.</p><h4 id="List-of-corner-nodes"><a class="docs-heading-anchor" href="#List-of-corner-nodes">List of corner nodes</a><a id="List-of-corner-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-corner-nodes" title="Permalink"></a></h4><p>Next, prefaced with <code>*NODE</code>, comes a list of the physical <code>(x,y,z)</code> coordinates of all the corners. The first integer in the list of the corners provides its id number. Thus, for the two-dimensional example mesh this block of corner information is</p><pre><code class="nohighlight hljs">*NODE
1, 1.0, -1.0, 0.0
2, 3.0,  0.0, 0.0
3, 1.0,  1.0, 0.0
4, 2.0,  0.0, 0.0
5, 0.0,  0.0, 0.0
6, 3.0,  1.0, 0.0
7, 3.0, -1.0, 0.0</code></pre><h4 id="List-of-elements"><a class="docs-heading-anchor" href="#List-of-elements">List of elements</a><a id="List-of-elements-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-elements" title="Permalink"></a></h4><p>The element connectivity is given after the list of corners. The header for this information block is</p><pre><code class="nohighlight hljs">*ELEMENT, type=CPS4, ELSET=Surface1</code></pre><p>The Abaqus element type <code>CPS4</code> corresponds to a quadrilateral element. Each quadrilateral element in the unstructured mesh is dictated by four corner points with indexing taken from the numbering given by the corner list above. The elements connect a set of four corner points (starting from the bottom left) in an anti-clockwise fashion; making the element <em>right-handed</em>. This element handedness is indicated using the circular arrow in the figure above. Just as with the corner list, the first integer in the element connectivity list indicates the element id number. Thus, the element connectivity list for the three element example mesh is</p><pre><code class="nohighlight hljs">*ELEMENT, type=CPS4, ELSET=Surface1
1, 5, 1, 4, 3
2, 4, 2, 6, 3
3, 7, 2, 4, 1</code></pre><h4 id="Element-neighbor-connectivity"><a class="docs-heading-anchor" href="#Element-neighbor-connectivity">Element neighbor connectivity</a><a id="Element-neighbor-connectivity-1"></a><a class="docs-heading-anchor-permalink" href="#Element-neighbor-connectivity" title="Permalink"></a></h4><p>The construction of the element neighbor ids and identifying physical boundary surfaces is done using functionality directly from the <a href="https://github.com/cburstedde/p4est"><code>p4est</code></a> library. For example, the neighbor connectivity is created in the mesh constructor using the wrapper <code>read_inp_p4est</code> function.</p><h4 id="HOHQMesh-boundary-information"><a class="docs-heading-anchor" href="#HOHQMesh-boundary-information">HOHQMesh boundary information</a><a id="HOHQMesh-boundary-information-1"></a><a class="docs-heading-anchor-permalink" href="#HOHQMesh-boundary-information" title="Permalink"></a></h4><p>If present, any additional information in the mesh file that was created by <code>HOHQMesh</code> is prefaced with <code>**</code> to make it an Abaqus comment. This ensures that the read in of the file by a standard Abaqus file parser, as done in the <code>read_inp_p4est</code> function, is done correctly.</p><p>The high-order, curved boundary information and labels of the physical boundary created by <code>HOHQMesh</code> is found below the comment line</p><pre><code class="nohighlight hljs">** ***** HOHQMesh boundary information ***** **</code></pre><p>Next comes the <em>polynomial degree</em> that the mesh will use to represent any curved sides</p><pre><code class="nohighlight hljs">** mesh polynomial degree = 8</code></pre><p>The mesh file then, again, provides the element connectivity as well as information for curved surfaces either interior to the domain or along the physical boundaries. A set of check digits are included directly below the four corner indexes to indicate whether the local surface index (<code>-y</code>, <code>+x</code>, <code>+y</code>, or <code>-x</code>) within the element is straight sided, <code>0</code>, or is curved, <code>1</code>. If the local surface is straight sided no additional information is necessary during the mesh file read in. But for any curved surfaces the mesh file provides <code>(x,y,z)</code> coordinate values in order to construct an interpolant of this surface with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes. This list of <code>(x,y,z)</code> data will be given in the direction of the local coordinate system. Given below is the element curvature information for the example mesh:</p><pre><code class="nohighlight hljs">**  5 1 4 3
**  0 0 1 1
**   1.000000000000000   1.000000000000000   0.0
**   1.024948365654583   0.934461926834452   0.0
**   1.116583018200151   0.777350964621867   0.0
**   1.295753434047077   0.606254343587194   0.0
**   1.537500000000000   0.462500000000000   0.0
**   1.768263070247418   0.329729152118310   0.0
**   1.920916981799849   0.185149035378133   0.0
**   1.986035130050921   0.054554577460044   0.0
**   2.000000000000000                 0.0   0.0
**                 0.0                 0.0   0.0
**   0.035513826946206   0.105291711848750   0.0
**   0.148591270347399   0.317731556850611   0.0
**   0.340010713990041   0.452219430075470   0.0
**   0.575000000000000   0.462500000000000   0.0
**   0.788022294598950   0.483764065630034   0.0
**   0.926408729652601   0.644768443149389   0.0
**   0.986453164464803   0.883724792445746   0.0
**   1.000000000000000   1.000000000000000   0.0
**  4 2 6 3
**  0 0 0 1
**   2.000000000000000                 0.0   0.0
**   1.986035130050921   0.054554577460044   0.0
**   1.920916981799849   0.185149035378133   0.0
**   1.768263070247418   0.329729152118310   0.0
**   1.537500000000000   0.462500000000000   0.0
**   1.295753434047077   0.606254343587194   0.0
**   1.116583018200151   0.777350964621867   0.0
**   1.024948365654583   0.934461926834452   0.0
**   1.000000000000000   1.000000000000000   0.0
**  7 2 4 1
**  0 0 0 0</code></pre><p>The last piece of information provided by <code>HOHQMesh</code> are labels for the different surfaces of an element. These labels are useful to set boundary conditions along physical surfaces. The labels can be short descriptive words up to 32 characters in length. The label <code>---</code> indicates an internal surface where no boundary condition is required.</p><p>It is important to note that these labels are given in the following order according to the local surface index <code>-x</code> <code>+x</code> <code>-y</code> <code>+y</code> as required by the <a href="https://github.com/cburstedde/p4est"><code>p4est</code></a> library.</p><pre><code class="nohighlight hljs">**  Bezier --- Slant ---
**  --- Right --- Top
**  Bottom --- Right ---</code></pre><p>For completeness, we provide the entire Abaqus mesh file for the example mesh in the figure above:</p><pre><code class="nohighlight hljs">*Heading
 File created by HOHQMesh
*NODE
1, 1.0, -1.0, 0.0
2, 3.0,  0.0, 0.0
3, 1.0,  1.0, 0.0
4, 2.0,  0.0, 0.0
5, 0.0,  0.0, 0.0
6, 3.0,  1.0, 0.0
7, 3.0, -1.0, 0.0
*ELEMENT, type=CPS4, ELSET=Surface1
1, 5, 1, 4, 3
2, 4, 2, 6, 3
3, 7, 2, 4, 1
** ***** HOHQMesh boundary information ***** **
** mesh polynomial degree = 8
**  5 1 4 3
**  0 0 1 1
**   1.000000000000000   1.000000000000000   0.0
**   1.024948365654583   0.934461926834452   0.0
**   1.116583018200151   0.777350964621867   0.0
**   1.295753434047077   0.606254343587194   0.0
**   1.537500000000000   0.462500000000000   0.0
**   1.768263070247418   0.329729152118310   0.0
**   1.920916981799849   0.185149035378133   0.0
**   1.986035130050921   0.054554577460044   0.0
**   2.000000000000000                 0.0   0.0
**                 0.0                 0.0   0.0
**   0.035513826946206   0.105291711848750   0.0
**   0.148591270347399   0.317731556850611   0.0
**   0.340010713990041   0.452219430075470   0.0
**   0.575000000000000   0.462500000000000   0.0
**   0.788022294598950   0.483764065630034   0.0
**   0.926408729652601   0.644768443149389   0.0
**   0.986453164464803   0.883724792445746   0.0
**   1.000000000000000   1.000000000000000   0.0
**  4 2 6 3
**  0 0 0 1
**   2.000000000000000                 0.0   0.0
**   1.986035130050921   0.054554577460044   0.0
**   1.920916981799849   0.185149035378133   0.0
**   1.768263070247418   0.329729152118310   0.0
**   1.537500000000000   0.462500000000000   0.0
**   1.295753434047077   0.606254343587194   0.0
**   1.116583018200151   0.777350964621867   0.0
**   1.024948365654583   0.934461926834452   0.0
**   1.000000000000000   1.000000000000000   0.0
**  7 2 4 1
**  0 0 0 0
**  Bezier --- Slant ---
**  --- Right --- Top
**  Bottom --- Right ---</code></pre><h3 id="Mesh-in-three-spatial-dimensions"><a class="docs-heading-anchor" href="#Mesh-in-three-spatial-dimensions">Mesh in three spatial dimensions</a><a id="Mesh-in-three-spatial-dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-in-three-spatial-dimensions" title="Permalink"></a></h3><p>The 3D Abaqus file format with high-order boundary information from <code>HOHQMesh</code> is very similar to the 2D version discussed above. There are only three changes:</p><ol><li>The element connectivity would be given in terms of the eight corners that define a hexahedron. The corners are numbered as shown in the figure below. The header of the element list changes to be<pre><code class="nohighlight hljs">*ELEMENT, type=C3D8, ELSET=Volume1</code></pre>where <code>C3D8</code> corresponds to a Abaqus hexahedral element.</li><li>There are six check digits included directly below the eight corner indexes to indicate whether the local face within the element is straight sided, <code>0</code>, or is curved, <code>1</code>. For curved faces <code>(x,y,z)</code> coordinate values are available in order to construct an face interpolant with the mesh polynomial order at the Chebyshev-Gauss-Lobatto nodes.</li><li>The boundary labels are given in the following order according to the local surface index <code>-x</code> <code>+x</code> <code>-y</code> <code>+y</code> <code>-z</code> <code>+z</code> as required by the <a href="https://github.com/cburstedde/p4est"><code>p4est</code></a> library.</li></ol><p>For completeness, we also give a short description and derivation of the three-dimensional transfinite mapping formulas used to compute the physical coordinates <span>$\mathbf{x}=(x,y,z)$</span> of a (possibly curved) hexahedral element give the reference coordinates <span>$\boldsymbol{\xi} = (\xi, \eta, \zeta)$</span> which lie in <span>$[-1,1]^3$</span>. That is, we will create an expression <span>$\mathbf{x}= \mathbf{X}(\boldsymbol{\xi})$</span>.</p><p>Below we provide a sketch of a single hexahedral element with curved faces. This is done to introduce the numbering conventions for corners, edges, and faces of the element.</p><p><img src="https://user-images.githubusercontent.com/25242486/139839161-8c5f5979-2724-4cfb-9eac-6af58105ef12.png" alt="abaqus-3dmesh-docs"/></p><p>When the hexahedron is a straight sided (linear) element we compute the transfinite mapping directly from the element corner points according to</p><p class="math-container">\[\begin{aligned}
\mathbf{X}_{linear}(\boldsymbol{\xi}) &amp;=  \frac{1}{8}[\quad\, \mathbf{x}_1(1-\xi)(1-\eta)(1-\zeta)
                                                         + \mathbf{x}_2(1+\xi)(1-\eta)(1-\zeta)\\[-0.15cm]
                                    &amp; \qquad\;             + \mathbf{x}_3(1+\xi)(1+\eta)(1-\zeta)
                                                         + \mathbf{x}_4(1-\xi)(1+\eta)(1-\zeta) \\
                                    &amp; \qquad\;             + \mathbf{x}_5(1-\xi)(1-\eta)(1+\zeta)
                                                         + \mathbf{x}_6(1+\xi)(1-\eta)(1+\zeta) \\
                                    &amp; \qquad\;             + \mathbf{x}_7(1+\xi)(1+\eta)(1+\zeta)
                                                         + \mathbf{x}_8(1-\xi)(1+\eta)(1+\zeta)\quad].
\end{aligned}\]</p><p>Next, we create a transfinite mapping function, <span>$\mathbf{X}(\boldsymbol{\xi})$</span>, for a hexahedron that has one or more curved faces. For this we assume that have a set of six interpolating polynomials <span>$\{\Gamma_i\}_{i=1}^6$</span> that approximate the faces. The interpolating polynomial for any curved faces is provided by the information in a <code>HOHQMesh</code> Abaqus mesh file or is constructed on the fly via a bi-linear interpolation routine for any linear faces. Explicitly, these six face interpolation polynomials depend on the computational coordinates <span>$\boldsymbol{\xi}$</span> as follows</p><p class="math-container">\[  \begin{aligned}
    \Gamma_1(\xi, \zeta), \quad &amp;&amp; \quad \Gamma_3(\xi, \eta), \quad &amp;&amp; \quad \Gamma_4(\eta, \zeta),\\[0.1cm]
    \Gamma_2(\xi, \zeta), \quad &amp;&amp; \quad \Gamma_5(\xi, \eta), \quad &amp;&amp; \quad \Gamma_6(\eta, \zeta).
  \end{aligned}\]</p><p>To determine the form of the mapping we first create linear interpolations between two opposing faces, e.g., <span>$\Gamma_3$</span> and <span>$\Gamma_5$</span> and sum them together to have</p><p class="math-container">\[\begin{aligned}
  \boldsymbol\Sigma(\boldsymbol{\xi}) &amp;= \frac{1}{2}[\quad\,(1-\xi)\Gamma_6(\eta,\zeta) + (1+\xi)\Gamma_4(\eta,\zeta) \\[-0.15cm]
  &amp;\qquad\;+ (1-\eta)\Gamma_1(\xi,\zeta) + (1+\eta)\Gamma_2(\xi,\zeta) \\%[-0.15cm]
                                  &amp;\qquad\; +(1-\zeta)\Gamma_3(\xi,\eta) + (1+\zeta)\Gamma_5(\xi,\eta)\quad].
\end{aligned}\]</p><p>Unfortunately, the linear interpolations <span>$\boldsymbol\Sigma(\boldsymbol{\xi})$</span> no longer match at the faces, e.g., evaluating at <span>$\eta = -1$</span> we have</p><p class="math-container">\[\boldsymbol\Sigma(\xi,-1,\zeta) = \Gamma_1(\xi,\zeta) + \frac{1}{2}[\;(1-\xi)\Gamma_6(-1,\zeta) + (1+\xi)\Gamma_4(-1,\zeta)
                                 +(1-\zeta)\Gamma_3(\xi,-1) + (1+\zeta)\Gamma_5(\xi,-1)\;],\]</p><p>which is the desired face <span>$\Gamma_1(\xi,\zeta)$</span> plus four edge error terms. Analogous edge error terms occur at the other faces evaluating <span>$\boldsymbol\Sigma(\boldsymbol{\xi})$</span> at <span>$\eta=1$</span>, <span>$\xi=\pm 1$</span>, and <span>$\zeta=\pm 1$</span>. In order to match the faces, we subtract a linear interpolant in the <span>$\xi$</span>, <span>$\eta$</span>, and <span>$\zeta$</span> directions of the edge error terms, e.g., the terms in braces in the above equation. So, continuing the example above, the correction term to be subtracted for face <span>$\Gamma_1$</span> to match would be</p><p class="math-container">\[\left(\frac{1-\eta}{2}\right) \bigg[ \frac{1}{2} [ \; (1-\xi)\Gamma_6(-1,\zeta) + (1+\xi)\Gamma_4(-1,\zeta)+(1-\zeta)\Gamma_3(\xi,-1)
 + (1+\zeta)\Gamma_5(\xi,-1)\;] \bigg].\]</p><p>For clarity, and to allow an easier comparison to the implementation, we introduce auxiliary notation for the 12 edge values present in the complete correction term. That is, for given values of <span>$\xi$</span>, <span>$\eta$</span>, and <span>$\zeta$</span> we have</p><p class="math-container">\[  \begin{aligned}
    \texttt{edge}_{1} &amp;= \Gamma_1(\xi, -1), \quad &amp;&amp; \quad \texttt{edge}_{5} = \Gamma_2(\xi, -1), \quad &amp; \quad  \texttt{edge}_{9} &amp;= \Gamma_6(\eta, -1),\\[0.1cm]
    \texttt{edge}_{2} &amp;= \Gamma_1(1, \zeta), \quad &amp;&amp; \quad\texttt{edge}_{6} = \Gamma_2(1, \zeta), \quad &amp; \quad  \texttt{edge}_{10} &amp;= \Gamma_4(\eta, -1),\\[0.1cm]
    \texttt{edge}_{3} &amp;= \Gamma_1(\xi, 1), \quad &amp;&amp; \quad \texttt{edge}_{7} = \Gamma_2(\xi,  1), \quad &amp; \quad  \texttt{edge}_{11} &amp;= \Gamma_4(\eta, 1),\\[0.1cm]
    \texttt{edge}_{4} &amp;= \Gamma_1(-1, \zeta), \quad &amp;&amp; \quad \texttt{edge}_{8} = \Gamma_2(-1, \zeta), \quad &amp; \quad  \texttt{edge}_{12} &amp;= \Gamma_6(\eta, 1).
  \end{aligned}\]</p><p>With this notation for the edge terms (and after some algebraic manipulation) we write the complete edge correction term, <span>$\mathcal{C}_{\texttt{edge}}(\boldsymbol{\xi})$</span>, as</p><p class="math-container">\[\begin{aligned}
\mathcal{C}_{\texttt{edge}}(\boldsymbol{\xi}) &amp;=  \frac{1}{4}[\quad\, (1-\eta)(1-\zeta)\texttt{edge}_{1}\\[-0.15cm]
                                    &amp; \qquad\;              + (1+\xi)(1-\eta)\texttt{edge}_{2} \\
                                    &amp; \qquad\;              + (1-\eta)(1+\zeta)\texttt{edge}_{3} \\
                                    &amp; \qquad\;              + (1-\xi)(1-\eta)\texttt{edge}_{4} \\
                                    &amp; \qquad\;              + (1+\eta)(1-\zeta)\texttt{edge}_{5} \\
                                    &amp; \qquad\;              + (1+\xi)(1+\eta)\texttt{edge}_{6} \\
                                    &amp; \qquad\;              + (1+\eta)(1+\zeta)\texttt{edge}_{7} \\
                                    &amp; \qquad\;              + (1-\xi)(1+\eta)\texttt{edge}_{8} \\
                                    &amp; \qquad\;              + (1-\xi)(1-\zeta)\texttt{edge}_{9} \\
                                    &amp; \qquad\;              + (1+\xi)(1-\zeta)\texttt{edge}_{10} \\
                                    &amp; \qquad\;              + (1+\xi)(1+\zeta)\texttt{edge}_{11} \\
                                    &amp; \qquad\;              + (1-\xi)(1+\zeta)\texttt{edge}_{12}\quad].
\end{aligned}\]</p><p>However, subtracting the edge correction terms <span>$\mathcal{C}_{\texttt{edge}}(\boldsymbol{\xi})$</span> from <span>$\boldsymbol\Sigma(\boldsymbol{\xi})$</span> removes the interior element contributions twice. Thus, to complete the construction of the transfinite mapping <span>$\mathbf{X}(\boldsymbol{\xi})$</span> we add the transfinite map of the straight sided hexahedral element to find</p><p class="math-container">\[\mathbf{X}(\boldsymbol{\xi}) = \boldsymbol\Sigma(\boldsymbol{\xi})
                             - \mathcal{C}_{\texttt{edge}}(\boldsymbol{\xi})
                             + \mathbf{X}_{linear}(\boldsymbol{\xi}).\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="unstructured_quad_mesh.html">« Unstructured mesh</a><a class="docs-footer-nextpage" href="dgmulti_mesh.html">DGMulti mesh »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 April 2023 00:22">Sunday 2 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
