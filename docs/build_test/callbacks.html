<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callbacks · Trixi.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/callbacks.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Trixi.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="overview.html">Overview</a></li><li><a class="tocitem" href="visualization.html">Visualization</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/introduction.html">Introduction</a></li><li><a class="tocitem" href="tutorials/getting_started_with_Trixi.html">1 Getting started with Trixi</a></li><li><a class="tocitem" href="tutorials/scalar_linear_advection_1d.html">2 Introduction to DG methods</a></li><li><a class="tocitem" href="tutorials/DGSEM_FluxDiff.html">3 DGSEM with flux differencing</a></li><li><a class="tocitem" href="tutorials/shock_capturing.html">4 Shock capturing with flux differencing and stage limiter</a></li><li><a class="tocitem" href="tutorials/non_periodic_boundaries.html">5 Non-periodic boundaries</a></li><li><a class="tocitem" href="tutorials/DGMulti_1.html">6 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="tutorials/DGMulti_2.html">7 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="tutorials/upwind_fdsbp.html">8 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="tutorials/adding_new_scalar_equations.html">9 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="tutorials/adding_nonconservative_equation.html">10 Adding a non-conservative equation</a></li><li><a class="tocitem" href="tutorials/parabolic_terms.html">11 Parabolic terms</a></li><li><a class="tocitem" href="tutorials/adding_new_parabolic_terms.html">12 Adding new parabolic terms</a></li><li><a class="tocitem" href="tutorials/adaptive_mesh_refinement.html">13 Adaptive mesh refinement</a></li><li><a class="tocitem" href="tutorials/structured_mesh_mapping.html">14 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="tutorials/hohqmesh_tutorial.html">15 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="tutorials/time_stepping.html">16 Explicit time stepping</a></li><li><a class="tocitem" href="tutorials/differentiable_programming.html">17 Differentiable programming</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="meshes/tree_mesh.html">Tree mesh</a></li><li><a class="tocitem" href="meshes/structured_mesh.html">Structured mesh</a></li><li><a class="tocitem" href="meshes/unstructured_quad_mesh.html">Unstructured mesh</a></li><li><a class="tocitem" href="meshes/p4est_mesh.html">P4est-based mesh</a></li><li><a class="tocitem" href="meshes/dgmulti_mesh.html">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="time_integration.html">Time integration</a></li><li class="is-active"><a class="tocitem" href="callbacks.html">Callbacks</a><ul class="internal"><li><a class="tocitem" href="#Step-callbacks"><span>Step callbacks</span></a></li><li><a class="tocitem" href="#Usage-of-step-callbacks"><span>Usage of step callbacks</span></a></li><li><a class="tocitem" href="#Stage-callbacks"><span>Stage callbacks</span></a></li><li><a class="tocitem" href="#Implementing-new-callbacks"><span>Implementing new callbacks</span></a></li></ul></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="conventions.html">Conventions</a></li><li><a class="tocitem" href="development.html">Development</a></li><li><a class="tocitem" href="github-git.html">GitHub &amp; Git</a></li><li><a class="tocitem" href="styleguide.html">Style guide</a></li><li><a class="tocitem" href="testing.html">Testing</a></li><li><a class="tocitem" href="performance.html">Performance</a></li><li><a class="tocitem" href="parallelization.html">Parallelization</a></li></ul></li><li><a class="tocitem" href="troubleshooting.html">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="reference-trixi.html">Trixi.jl</a></li><li><a class="tocitem" href="reference-trixi2vtk.html">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="authors.html">Authors</a></li><li><a class="tocitem" href="contributing.html">Contributing</a></li><li><a class="tocitem" href="code_of_conduct.html">Code of Conduct</a></li><li><a class="tocitem" href="license.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic building blocks</a></li><li class="is-active"><a href="callbacks.html">Callbacks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="callbacks.html">Callbacks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/callbacks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="callbacks-id"><a class="docs-heading-anchor" href="#callbacks-id">Callbacks</a><a id="callbacks-id-1"></a><a class="docs-heading-anchor-permalink" href="#callbacks-id" title="Permalink"></a></h1><p>Many of the advanced features of Trixi, such as adaptive mesh refinement, are implemented as callbacks. A callback is an algorithmic entity that gets passed to the ODE solver and is called at specific points during execution to perform certain tasks. Callbacks in Trixi are either called after each time step (<em>step callbacks</em>) or after each stage of the ODE solver (<em>stage callbacks</em>).</p><p><img src="https://user-images.githubusercontent.com/65298011/108088616-f690c000-7078-11eb-9dd1-b673eac6cecf.png" alt="callbacks_illustration"/></p><p>The advantage of callbacks over hard-coding all features is that it allows to extend Trixi without modifying the internal source code. Trixi provides callbacks for time step control, adaptive mesh refinement, I/O, and more.</p><h2 id="Step-callbacks"><a class="docs-heading-anchor" href="#Step-callbacks">Step callbacks</a><a id="Step-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Step-callbacks" title="Permalink"></a></h2><h3 id="CFL-based-time-step-control"><a class="docs-heading-anchor" href="#CFL-based-time-step-control">CFL-based time step control</a><a id="CFL-based-time-step-control-1"></a><a class="docs-heading-anchor-permalink" href="#CFL-based-time-step-control" title="Permalink"></a></h3><p>Time step control can be performed with a <a href="reference-trixi.html#Trixi.StepsizeCallback"><code>StepsizeCallback</code></a>. An example making use of this can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_advection_basic.jl">examples/tree<em>2d</em>dgsem/elixir_advection_basic.jl</a></p><h3 id="Adaptive-mesh-refinement"><a class="docs-heading-anchor" href="#Adaptive-mesh-refinement">Adaptive mesh refinement</a><a id="Adaptive-mesh-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-mesh-refinement" title="Permalink"></a></h3><p>Trixi uses a hierarchical Cartesian mesh which can be locally refined in a solution-adaptive way. This can be used to speed up simulations with minimal loss in overall accuracy. Adaptive mesh refinement (AMR) can be used by passing an <a href="reference-trixi.html#Trixi.AMRCallback"><code>AMRCallback</code></a> to the ODE solver. The <code>AMRCallback</code> requires a controller such as <a href="reference-trixi.html#Trixi.ControllerThreeLevel"><code>ControllerThreeLevel</code></a> or <a href="reference-trixi.html#Trixi.ControllerThreeLevelCombined"><code>ControllerThreeLevelCombined</code></a> to tell the AMR algorithm which cells to refine/coarsen.</p><p>An example elixir using AMR can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_advection_amr.jl">examples/tree<em>2d</em>dgsem/elixir_advection_amr.jl</a>.</p><h3 id="Analyzing-the-numerical-solution"><a class="docs-heading-anchor" href="#Analyzing-the-numerical-solution">Analyzing the numerical solution</a><a id="Analyzing-the-numerical-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-the-numerical-solution" title="Permalink"></a></h3><p>The <a href="reference-trixi.html#Trixi.AnalysisCallback"><code>AnalysisCallback</code></a> can be used to analyze the numerical solution, e.g. calculate errors or user-specified integrals, and print the results to the screen. The results can also be saved in a file. An example can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_euler_vortex.jl">examples/tree<em>2d</em>dgsem/elixir_euler_vortex.jl</a>. In  you can find a detailed description of the different performance metrics the <code>AnalysisCallback</code> computes.</p><h3 id="I/O"><a class="docs-heading-anchor" href="#I/O">I/O</a><a id="I/O-1"></a><a class="docs-heading-anchor-permalink" href="#I/O" title="Permalink"></a></h3><h4 id="Solution-and-restart-files"><a class="docs-heading-anchor" href="#Solution-and-restart-files">Solution and restart files</a><a id="Solution-and-restart-files-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-and-restart-files" title="Permalink"></a></h4><p>To save the solution in regular intervals you can use a <a href="reference-trixi.html#Trixi.SaveSolutionCallback"><code>SaveSolutionCallback</code></a>. It is also possible to create restart files using the <a href="reference-trixi.html#Trixi.SaveRestartCallback"><code>SaveRestartCallback</code></a>. An example making use of these can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_advection_extended.jl">examples/tree<em>2d</em>dgsem/elixir_advection_extended.jl</a>. An example showing how to restart a simulation from a restart file can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_advection_restart.jl">examples/tree<em>2d</em>dgsem/elixir_advection_restart.jl</a>.</p><h4 id="Time-series"><a class="docs-heading-anchor" href="#Time-series">Time series</a><a id="Time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Time-series" title="Permalink"></a></h4><p>Sometimes it is useful to record the evoluation of state variables over time at a given set of points. This can be achieved by the <a href="reference-trixi.html#Trixi.TimeSeriesCallback"><code>TimeSeriesCallback</code></a>, which is used, e.g., in <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_acoustics_gaussian_source.jl">examples/tree<em>2d</em>dgsem/elixir_acoustics_gaussian_source.jl</a>. The <code>TimeSeriesCallback</code> constructor expects a semidiscretization and a list of points at which the solution should be recorded in regular time step intervals. After the last time step, the entire record is stored in an HDF5 file.</p><p>For the points, two different input formats are supported: You can either provide them as a list of tuples, which is handy if you specify them by hand on the REPL. Alternatively, you can provide them as a two-dimensional array, where the first dimension is the point number and the second dimension is the coordinate dimension. This is especially useful when reading them from a file.</p><p>For example, to record the primitive variables at the points <code>(0.0, 0.0)</code> and <code>(-1.0, 0.5)</code> every five timesteps and storing the collected data in the file <code>tseries.h5</code>, you can create the <code>TimeSeriesCallback</code> as</p><pre><code class="language-julia hljs">time_series = TimeSeriesCallback(semi, [(0.0, 0.0), (-1.0, 0.5)];
                                 interval=5,
                                 solution_variables=cons2prim,
                                 filename=&quot;tseries.h5&quot;)</code></pre><p>For a full list of possible arguments, please check the documentation for the <a href="reference-trixi.html#Trixi.TimeSeriesCallback"><code>TimeSeriesCallback</code></a>. As an alternative to specifying the point coordinates directly in the elixir or on the REPL, you can read them from a file. For instance, with a text file <code>points.dat</code> with content</p><pre><code class="nohighlight hljs"> 0.0 0.0
-1.0 0.5</code></pre><p>you can create a time series callback with</p><pre><code class="language-julia hljs">using DelimitedFiles: readdlm
time_series = TimeSeriesCallback(semi, readdlm(&quot;points.dat&quot;))</code></pre><p>To plot the individual point data series over time, you can create a <a href="reference-trixi.html#Trixi.PlotData1D"><code>PlotData1D</code></a> from the <code>TimeSeriesCallback</code> and a given point ID. For example, executing</p><pre><code class="language-julia hljs">julia&gt; using Trixi, Plots

julia&gt; trixi_include(joinpath(examples_dir(), &quot;tree_2d_dgsem&quot;, &quot;elixir_acoustics_gaussian_source.jl&quot;))

julia&gt; pd1 = PlotData1D(time_series, 1)

julia&gt; pd2 = PlotData1D(time_series, 2)

julia&gt; plot(pd1[&quot;p_prime&quot;]); plot!(pd2[&quot;p_prime&quot;], xguide=&quot;t&quot;)</code></pre><p>will yield the following plot:</p><p><img src="https://user-images.githubusercontent.com/3637659/115822874-9108d900-a405-11eb-9960-4ca3d535e3c6.png" alt="image"/></p><h3 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h3><ul><li>The <a href="reference-trixi.html#Trixi.AliveCallback"><code>AliveCallback</code></a> prints some information to the screen to show that a simulation is still running.</li><li>The <a href="reference-trixi.html#Trixi.SummaryCallback-Tuple{}"><code>SummaryCallback</code></a> prints a human-readable summary of the simulation setup and controls the automated performance measurements, including an output of the recorded timers after a simulation.</li><li>The <a href="reference-trixi.html#Trixi.VisualizationCallback-Tuple{}"><code>VisualizationCallback</code></a> can be used for in-situ visualization. See <a href="visualization.html#Visualizing-results-during-a-simulation">Visualizing results during a simulation</a>.</li><li>The <a href="reference-trixi.html#Trixi.TrivialCallback-Tuple{}"><code>TrivialCallback</code></a> does nothing and can be used to to easily disable some callbacks via <a href="reference-trixi.html#Trixi.trixi_include-Tuple{Module, AbstractString}"><code>trixi_include</code></a>.</li></ul><h3 id="Equation-specific-callbacks"><a class="docs-heading-anchor" href="#Equation-specific-callbacks">Equation-specific callbacks</a><a id="Equation-specific-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-specific-callbacks" title="Permalink"></a></h3><p>Some callbacks provided by Trixi implement specific features for certain equations:</p><ul><li>The <a href="reference-trixi.html#Trixi.LBMCollisionCallback-Tuple{}"><code>LBMCollisionCallback</code></a> implements the Lattice-Boltzmann method (LBM) collision operator and should only be used when solving the Lattice-Boltzmann equations. See e.g. <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_lbm_constant.jl">examples/tree<em>2d</em>dgsem/elixir_lbm_constant.jl</a></li><li>The <a href="reference-trixi.html#Trixi.SteadyStateCallback"><code>SteadyStateCallback</code></a> terminates the time integration when the residual steady state falls below a certain threshold. This checks the convergence of the potential <span>$\phi$</span> for hyperbolic diffusion. See e.g. <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_hypdiff_nonperiodic.jl">examples/tree<em>2d</em>dgsem/elixir_hypdiff_nonperiodic.jl</a>.</li><li>The <a href="reference-trixi.html#Trixi.GlmSpeedCallback"><code>GlmSpeedCallback</code></a> updates the divergence cleaning wave speed <code>c_h</code> for the ideal GLM-MHD equations. See e.g. <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_mhd_alfven_wave.jl">examples/tree<em>2d</em>dgsem/elixir_mhd_alfven_wave.jl</a>.</li></ul><h2 id="Usage-of-step-callbacks"><a class="docs-heading-anchor" href="#Usage-of-step-callbacks">Usage of step callbacks</a><a id="Usage-of-step-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-of-step-callbacks" title="Permalink"></a></h2><p>Step callbacks are passed to the <code>solve</code> method from the ODE solver via the keyword argument <code>callback</code>. If you want to use a single callback <code>cb</code>, pass it as <code>callback=cb</code>. When using two or more callbacks, you need to turn them into a <code>CallbackSet</code> first by calling <code>callbacks = CallbackSet(cb1, cb2)</code> and passing it as <code>callback=callbacks</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are some restrictions regarding the order of callbacks in a <code>CallbackSet</code>.</p><p>The callbacks are called <em>after</em> each time step but some callbacks actually belong to the next time step. Therefore, the callbacks should be ordered in the following way:</p><ul><li>Callbacks that belong to the current time step:<ul><li><code>SummaryCallback</code> controls, among other things, timers and should thus be first</li><li><code>SteadyStateCallback</code> may mark a time step as the last one</li><li><code>AnalysisCallback</code> may do some checks that mark a time step as the last one</li><li><code>AliveCallback</code> should be nearby <code>AnalysisCallback</code></li><li><code>SaveSolutionCallback</code>/<code>SaveRestartCallback</code> should save the current solution before it is degraded by AMR</li><li><code>VisualizationCallback</code> should be called before the mesh is adapted</li></ul></li><li>Callbacks that belong to the next time step:<ul><li><code>AMRCallback</code></li><li><code>StepsizeCallback</code> must be called after <code>AMRCallback</code> to accomodate potential changes to the mesh</li><li><code>GlmSpeedCallback</code> must be called after <code>StepsizeCallback</code> because the step size affects the value of <code>c_h</code></li><li><code>LBMCollisionCallback</code> is already part of the calculations of the next time step and should therefore be called after <code>StepsizeCallback</code></li></ul></li></ul></div></div><h2 id="Stage-callbacks"><a class="docs-heading-anchor" href="#Stage-callbacks">Stage callbacks</a><a id="Stage-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-callbacks" title="Permalink"></a></h2><p><a href="reference-trixi.html#Trixi.PositivityPreservingLimiterZhangShu"><code>PositivityPreservingLimiterZhangShu</code></a> is a positivity-preserving limiter, used to enforce physical constraints. An example elixir using this feature can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_euler_positivity.jl">examples/tree<em>2d</em>dgsem/elixir_euler_positivity.jl</a>.</p><h2 id="Implementing-new-callbacks"><a class="docs-heading-anchor" href="#Implementing-new-callbacks">Implementing new callbacks</a><a id="Implementing-new-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-new-callbacks" title="Permalink"></a></h2><p>Since Trixi is compatible with <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>, both packages share the same callback interface. A detailed description of it can be found in the OrdinaryDiffEq.jl <a href="https://diffeq.sciml.ai/latest/">documentation</a>. Step callbacks are just called <a href="https://diffeq.sciml.ai/latest/features/callback_functions/">callbacks</a>. Stage callbacks are called <a href="https://diffeq.sciml.ai/latest/solvers/ode_solve/#Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)"><code>stage_limiter!</code></a>.</p><p>An example elixir showing how to implement a new simple stage callback and a new simple step callback can be found at <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_2d_dgsem/elixir_advection_callbacks.jl">examples/tree<em>2d</em>dgsem/elixir_advection_callbacks.jl</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="time_integration.html">« Time integration</a><a class="docs-footer-nextpage" href="conventions.html">Conventions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 3 April 2023 17:45">Monday 3 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
