# Unstructured simplicial meshes

Support for simplicial meshes uses the [StartUpDG.jl](https://github.com/jlchan/StartUpDG.jl)
package. These meshes are constructed by specifying a list of vertex coordinates `vertex_coordinates_x`,
`vertex_coordinates_y`, `vertex_coordinates_z` and a connectivity matrix `EToV` where `EToV[e,:]`
gives the vertices which correspond to element `e`.

We make a few simplifying assumptions about simplicial meshes:
* meshes consist of a single type of element
* meshes are _conforming_ (e.g., each face of an element is shared with at most one other element).
* the geometric mapping from reference to physical elements is polynomial (currently, only affine
mappings are supported).

## `AbstractMeshData` wrapper type

Simplicial meshes in Trixi are represented using an `AbstractMeshData{NDIMS, ElemType}` wrapper.
For example, `VertexMappedMesh{NDIMS, Tri} <: AbstractMeshData{NDIMS, Tri}` describes a mesh whose
reference-to-physical mapping can be constructed using only the vertex positions (e.g., an affine
simplicial mesh or a bilinear quadrilateral mesh). These quantities are generated by most simplicial
mesh generators, and `StartUpDG.jl` includes both simple uniform meshes via `uniform_mesh`, as
well as support for triangular meshes constructed using
[Triangulate.jl](https://github.com/JuliaGeometry/Triangulate.jl), a wrapper around Jonathan Shewchuk's
[Triangle](https://www.cs.cmu.edu/~quake/triangle.html) package.

The only fields are `md::MeshData`, which contains geometric terms derived from the mapping between
the reference and physical elements, and `boundary_faces`, which contains a `Dict` of boundary
segment names (symbols) and list of faces which lie on that boundary segment.

## Variable naming conventions

We use the convention that coordinates on the reference element are ``r`` in 1D, ``r, s`` in 2D,
or ``r, s, t`` in 3D. Physical coordinates use the standard conventions ``x``, ``x, y``, and
``x, y, z`` in 1D, 2D, and 3D.

!["Ref-to-physical mapping"](https://user-images.githubusercontent.com/1156048/124361389-a2841380-dbf4-11eb-8ee4-33e71109c8bb.png)

Derivatives of reference coordinates with respect to physical coordinates are abbreviated, e.g.,
``\frac{\partial r}{\partial x} = r_x``. Additionally, ``J`` is used to denote the determinant of
the Jacobian of the reference-to-physical mapping.

## Variable meanings and conventions in `StartUpDG.jl`

`StartUpDG.jl` exports structs `RefElemData{NDIMS, ElemShape, ...}` (which contains data associated
with the reference element, such as interpolation points, quadrature rules, face nodes, normals,
and differentiation/interpolation/projection matrices) and `MeshData{NDIMS}` (which contains geometric
data associated with a mesh). These are currently used for evaluating DG formulations in a matrix-free
fashion. These structs contain fields similar (but not identical) to those in
`Globals1D, Globals2D, Globals3D` in the Matlab codes from "Nodal Discontinuous Galerkin Methods"
by Hesthaven and Warburton (2007).

In general, we use the following code conventions:
* variables such as `r, s,...` and `x, y,...` correspond to values at nodal interpolation points.
* variables ending in `q` (e.g., `rq, sq,...` and `xq, yq,...`) correspond to values at volume
quadrature points.
* variables ending in `f` (e.g., `rf, sf,...` and `xf, yf,...`) correspond to values at face
quadrature points.
* variables ending in `p` (e.g., `rp, sp,...`) correspond to "plotting" points, which are usually
a fine grid of equispaced points.
* `V` matrices correspond to interpolation matrices from nodal interpolation points, e.g., `Vq`
interpolates to volume quadrature points, `Vf` interpolates to face quadrature points.
* geometric quantities in `MeshData` are stored as matrices of dimension
``\text{number of points per element } \times \text{number of elements}``.

Quantities in `rd::RefElemData`:
* `rd.Np, rd.Nq, rd.Nf`: the number of nodal interpolation points, volume quadrature points, and
face quadrature points on the reference element, respectively.
* `rd.Vq`: interpolation matrices from values at nodal interpolation points to volume quadrature points
* `rd.wq`: volume quadrature weights on the reference element
* `rd.Vf`: interpolation matrices from values at nodal interpolation points to face quadrature points
* `rd.wf`: a vector containing face quadrature weights on the reference element
* `rd.M`: the quadrature-based mass matrix, computed via `rd.Vq' * diagm(rd.wq) * rd.Vq`.
* `rd.Pq`: a quadrature-based ``L^2`` projection matrix `rd.Pq = rd.M \ rd.Vq' * diagm(rd.wq)`
which maps between values at quadrature points and values at nodal points.
* `Dr, Ds, Dt` matrices are nodal differentiation matrices with respect to the ``r,s,t`` coordinates,
e.g., `Dr*f.(r,s)` approximates the derivative of ``f(r,s)`` at nodal points.

Quantities in `md::MeshData`:
* `md.xyz` is a tuple of matrices `md.x`, `md.y`, `md.z`, where column `e` contains coordinates of
physical interpolation points.
* `md.xyzq` is a tuple of matrices `md.xq`, `md.yq`, `md.zq`, where column `e` contains coordinates
of physical quadrature points.
* `md.rxJ, md.sxJ, ...` are matrices where column `e` contains values of
``J\frac{\partial r}{\partial x}``, ``J\frac{\partial s}{\partial x}``, etc. at nodal interpolation
points on the element `e`.
* `md.J` is a matrix where column `e` contains values of the Jacobian ``J`` at nodal interpolation points.
* `md.Jf` is a matrix where column `e` contains values of the face Jacobian (e.g., determinant of
the geometric mapping between a physical face and a reference face) at face quadrature points.
* `md.nxJ, md.nyJ, ...` are matrices where column `e` contains values of components of the unit
normal scaled by the face Jacobian `md.Jf` at face quadrature points.

For more details, please see the [StartUpDG.jl docs](https://jlchan.github.io/StartUpDG.jl/dev/).

## Special options

Trixi solvers on simplicial meshes use `DG` solver types with the basis field set as a `RefElemData`
type. By default, `RefElemData(Tri(), polydeg)` will generate data for a degree `polydeg` polynomial
approximation on a triangle. There are also several parameters which can be tweaked:

* `RefElemData(Tri(), polydeg, quad_rule_vol = quad_nodes(Tri(), Nq))` will substitute in a volume
quadrature rule of degree `Nq` instead of the default (which is a quadrature rule of degree `polydeg`).
Here, a degree `Nq` rule will be exact for at least degree `2*Nq` integrands (such that the mass
matrix is integrated exactly). Quadrature rules of which exactly integrate degree `Nq` integrands
may also be specified by setting `quad_rule_vol = StartUpDG.quad_nodes_tri(Nq)`.
* `RefElemData(Tri(), polydeg, quad_rule_face = quad_nodes(Line(), Nq))` will use a face quadrature rule
of degree `Nq` rather than the default. This rule is also exact for at least degree `2*Nq` integrands.
* `RefElemData(Tri(), SBP(), polydeg)` will generate a reference element corresponding to a
multi-dimensional SBP discretization. Types of SBP discretizations available include
`SBP{Kubatko{LobattoFaceNodes}}()` (the default choice), `SBP{Kubatko{LegendreFaceNodes}}()`, and
[`SBP{Hicken}()`](https://doi.org/10.1007/s10915-020-01154-8). For `polydeg = 1, ..., 4`, the
`SBP{Kubatko{LegendreFaceNodes}}()` SBP nodes are identical to the SBP nodes of
[Chen and Shu](https://doi.org/10.1016/j.jcp.2017.05.025).
More detailed descriptions of each SBP node set can be found in the
[StartUpDG.jl docs](https://jlchan.github.io/StartUpDG.jl/dev/RefElemData/#RefElemData-based-on-SBP-finite-differences).
Trixi will also specialize certain parts of the solver based on the `SBP` approximation type.

## Trixi elixirs on simplicial meshes

Example elixirs on simplicial meshes can be found in the `examples/simplicial_mesh` folder.
Some key elixirs to look at:

* `elixir_euler_triangular_mesh.jl`: basic weak form DG discretization on a uniform triangular mesh.
* `elixir_euler_periodic_triangular_mesh.jl`: same as above, but enforces periodicity in the ``x,y`` directions.
* `elixir_euler_triangulate_pkg_mesh.jl`: uses a `TriangulateIO` unstructured mesh generated by `Triangulate.jl`.
* `elixir_ape_sbp_triangular_mesh.jl`: uses a multi-dimensional SBP discretization in weak form.
* `elixir_euler_tet_mesh.jl`: basic weak form DG discretization on a uniform tet mesh.

We also have support for flux differencing on simplicial meshes:
* `elixir_euler_triangular_mesh_ec.jl`: Modal DG discretization with flux differencing on a uniform triangular mesh.
* `elixir_euler_sbp_triangular_mesh_ec.jl`: SBP-DG discretization with flux differencing on a uniform triangular mesh.
* `elixir_euler_tet_mesh_ec.jl`: Modal DG discretization with flux differencing on a uniform tetrahedral mesh.
