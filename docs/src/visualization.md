# [Visualization](@id visualization)

There are two possible approaches to visualize results from Trixi: either
directly from the REPL using [Plots.jl](@ref) or with ParaView/VisIt by
postprocessing Trixi's output files with [Trixi2Vtk](@ref).

!!! note
    There is also a package [Trixi2Img](@ref) that allows to create images
    from Trixi's HDF5 output files. However, it is deprecated in favor of plotting
    directly from the REPL with [Plots.jl](@ref).


## [Plots.jl [experimental]](@id Plots.jl)

### Getting started
By far the easiest and most convenient plotting approach is to use the powerful
[Plots.jl](https://github.com/JuliaPlots/Plots.jl) package to directly visualize
Trixi's 2D/3D results from the REPL.
!!! note
    Plotting via Plots.jl is still considered an experimental feature and might
    change in any future releases.

After running a simulation with Trixi in the REPL, load the Plots package with
```julia
julia> using Plots
```
To visualize the solution, execute
```julia
julia> plot(sol)
```
Here we assume that `sol` holds the return value of the `solve(...)` method
(with type `DiffEqBase.ODESolution`), which is the default variable name when
you use one of the example elixirs. This will generate a grid layout with one
subplot for each solution variable, convenient for getting an overview of
the current solution:

![plot-sol](https://user-images.githubusercontent.com/3637659/102711618-8c97ac80-42bb-11eb-96c8-af69d789feb0.png)

You can save the resulting file as a PNG image file by calling `savefig(...)`
with an output file name that ends in `.png`, e.g.,
```julia
julia> savefig("solution-overview.png")
```


### Customizing plot results via plot data objects
For more fine-grained control over what to plot, first create a
[`PlotData2D`](@ref) object by executing
```julia
julia> pd = PlotData2D(sol)
```
This takes the results generated by Trixi and stores them in a data format that
can be understood by the Plots package, and `pd` holds all data relevant for
plotting `sol`. You can pass variable names as strings to `pd` using a
dictionary-like syntax, e.g.,
```julia
julia> plot(pd["rho"])
```
This will create a single 2D heatmap plot of the variable `rho`:

![plot-rho](https://user-images.githubusercontent.com/3637659/102711621-93beba80-42bb-11eb-8f65-d03e083dc3bc.png)

The default plot type and style can be overridden by passing any additional
arguments that are understood by the Plots package. For example, to change the
color scheme and add names to the axes, modify the previous command to
```julia
julia> plot(pd["rho"], seriescolor = :heat, xguide="x", yguide="y")
```
to yield

![plot-rho-modified](https://user-images.githubusercontent.com/3637659/102724842-d8c20b80-4312-11eb-87db-b3ab22e74568.png)

For more details on the various format options for `plot`, please consult the
[Plots documentation](https://docs.juliaplots.org/latest/).

In addition, you can plot the mesh lines on top of the solution variables by calling
the `getmesh(...)` function on the `PlotData2D` object
```julia
julia> plot!(getmesh(pd)) # here we use `plot!` with an `!` to add to the previous plot
```
which modifies the previous plot to

![plot-rho-modified-mesh](https://user-images.githubusercontent.com/3637659/102724856-e1b2dd00-4312-11eb-83ae-e470c32f9008.png)

By default, `PlotData2D` will convert the conserved variables to primitive
variables, but this can changed by passing an appropriate conversion function in
the `solution_variables` keyword argument, similar to the behavior of the
[`SaveSolutionCallback`](@ref):
```julia
julia> pd = PlotData2D(sol; solution_variables=cons2cons) # Plot conservative variables
```
There are several other keyword arguments that influence how the solution data
is processed for visualization with the Plots package. A detailed explanation
can be found in the docstring of the [`PlotData2D`](@ref) constructor.

Another way to change the appearance of a plot is to convert the solution to a
uniformly refined mesh before plotting. This can be helpful, e.g., when
trying different settings for a simulation with adaptive mesh refinement,
where one would like to ignore the mesh changes when comparing solutions. This
is achieved with [`adapt_to_mesh_level`](@ref), which uses the mesh adaptation
routines to adapt the solution to a uniform grid. For example, the AMR solution
from above could be preprocessed with
```julia
julia> pd = PlotData2D(adapt_to_mesh_level(sol, 4)...)
```
When plotted together with the mesh, this will yield the following visualization:

![plot-rho-uniform-mesh](https://user-images.githubusercontent.com/3637659/112101404-e0f64500-8ba6-11eb-9516-ad910c6813b2.png)


### Plotting 3D solutions
It is possible to plot 2D slices from 3D simulation data with the same commands
as above. By default, plotting `sol` or creating a `PlotData2D` object from
a 3D simulation will create a 2D slice of the solution in the xy-plane. You can
customize this behavior by creating a `PlotData2D` object and passing
appropriate keyword arguments to `PlotData2D`:
* `slice_axis` specifies the axis orthogonal to the slice and can be `:x`, `:y`,
  or `:z` (default: `:z`)
* `slice_axis_intercept` specifies the axis coordinate of the `slice_axis` at
  which the slice is created (default: `0.0`)

For example, to plot the velocity field orthogonal to the yz-plane at different
x-axis locations, you can execute
```julia
julia> trixi_include(joinpath(examples_dir(), "3d", "elixir_euler_taylor_green_vortex.jl"), tspan=(0, 1))
[...]

julia> plots = []
Any[]

julia> for x in range(0, stop=pi/2, length=6)
         pd = PlotData2D(sol, slice_axis=:x, slice_axis_intercept=x)
         push!(plots, plot(pd["v1"], clims=(-1,1), title="x = "*string(round(x, digits=2))))
       end

julia> plot(plots..., layout=(2, 3), size=(750,350))
```
which results in a 2x3 grid of slices orthogonal to the x-axis:

![plot-v1-0.0-to-0.5pi](https://user-images.githubusercontent.com/3637659/102917883-417dc500-4486-11eb-9bd3-d18efd9c8337.png)


### Visualizing results during a simulation
To visualize solutions while a simulation is still running (also known as *in-situ visualization*),
you can use the [`VisualizationCallback`](@ref). It is created as a regular
callback and accepts upon creation a number of keyword arguments that allow,
e.g., to control the visualization interval, to specify the variables
to plot, or to customize the plotting style.

During the simulation, the visualization callback creates and displays
visualizations of the current solution in regular intervals. This can be useful
to, e.g., monitor the validity of a long-running simulation or for illustrative
purposes. An example for how to create a `VisualizationCallback` can be found in
[examples/2d/elixir\_advection\_amr\_visualization.jl](https://trixi-framework.github.com/Trixi.jl/examples/2d/elixir_advection_amr_visualization.jl):
```julia
[...]

# Enable in-situ visualization with a new plot generated every 20 time steps
# and additional plotting options passed as keyword arguments
visualization = VisualizationCallback(interval=20; clims=(0,1))

[...]
```

The resulting output of the referenced elixir can be seen in the embedded video
below:
```@raw html
  <!--
  Video creation details
  * Set up terminal size and position appropriately
  * Record video as MP4 with SimpleScreenRecorder (https://en.wikipedia.org/wiki/SimpleScreenRecorder)
  * Upload to YouTube
  * Obtain responsive code by inserting link on https://embedresponsively.com
  -->
  <style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube-nocookie.com/embed/UZtrqeDY1Fs' frameborder='0' allowfullscreen></iframe></div>
```


## Trixi2Vtk
Trixi2Vtk converts Trixi's `.h5` output files to VTK files, which can be read
by [ParaView](https://www.paraview.org), [VisIt](https://visit.llnl.gov),
and other visualization tools. It
automatically interpolates solution data from the original quadrature node
locations to equidistant *visualization nodes* at a higher resolution, to make
up for the loss of accuracy from going from a high-order polynomial
representation to a piecewise constant representation in VTK.

In the Julia REPL, first load the package Trixi2Vtk
```julia
julia> using Trixi2Vtk
```
To process an HDF5 file generated by Trixi.jl, execute
```julia
julia> trixi2vtk(joinpath("out", "solution_000000.h5"), output_directory="out")
```
This will create two unstructured VTK files in the `out` subdirectory that can
be opened with ParaView or VisIt: `solution_000000.vtu` contains the
discontinuous Galerkin solution data while `solution_000000_celldata.vtu` holds
any cell-based values such as the current AMR indicator or the cell refinement
level.

!["solution_000000_scalar_mesh"](https://github.com/trixi-framework/Trixi2Vtk.jl/raw/main/docs/src/assets/solution_000000_scalar_mesh.png)

This allows you to generate VTK files for solution, restart and mesh files. By
default, Trixi2Vtk generates `.vtu` (unstructured VTK) files for both
cell/element data (e.g., cell ids, element ids) and node data (e.g., solution
variables). This format visualizes each cell with the same number of nodes,
independent of its size.  Alternatively, you can provide `format=:vti` as a
keyword argument to `trixi2vtk`, which causes Trixi2Vtk to generate
`.vti` (image data VTK) files for the solution files, while still using `.vtu`
files for cell-/element-based data. In `.vti` files, a uniform resolution is
used throughout the entire domain, resulting in different number of
visualization nodes for each element.  This can be advantageous to create
publication-quality images, but increases the file size.

If you want to convert multiple solution/restart files at once, you can just supply
multiple input files as the positional arguments to `trixi2vtk`, e.g.,
```julia
julia> trixi2vtk("out/solution_000000.h5", "out/solution_000040.h5")
```
You may also use file globbing to select a range of files based on filename patterns, e.g.,
```julia
julia> trixi2vtk("out/solution_*.h5")
```
to convert all solution files in the `out/` directory or
```julia
julia> trixi2vtk("out/restart_00[0-9]000.h5")
```
to convert every one-thousandth restart file (`out/restart_000000.h5`,
`out/restart_001000.h5` etc.).

When multiple solution/restart files are provided, Trixi2Vtk will also generate a
`.pvd` file, which allows ParaView to read all `.vtu`/`.vti` files at once and which
uses the `time` attribute in solution/restart files to inform ParaView about the
solution time. A comprehensive list of all possible arguments for
`trixi2vtk` can be found in the [Trixi2Vtk.jl API](@ref).


## Trixi2Img
!!! note "Trixi2Img is deprecated"
    Since it is possible to visualize results from Trixi directly from the REPL
    using the Plots package, Trixi2Img has been deprecated. There are still some
    features missing when using Plots, such as postprocessing HDF5 files. Once
    these have been added to the Plots-based solution, Trixi2Img will be
    retired.

Trixi2Img can be used to directly convert Trixi's output files to image files,
without having to use a third-pary visualization tool such as ParaView or VisIt. The
downside of this approach is that it generally takes longer to visualize the
data (especially for large files) and that it does not allow as much
customization of the generated output files.  Currently, PNG and PDF are
supported as output formats.

In the Julia REPL, first load the package Trixi2Img
```julia
julia> using Trixi2Img
```
To process an HDF5 file generated by Trixi.jl, execute
```julia
julia> trixi2img(joinpath("out", "solution_000040.h5"), output_directory="out", grid_lines=true)
```
This will create a file `solution_000040_scalar.png` in the `out/` subdirectory
that can be opened with any image viewer:

!["solution_000040_scalar_resized"](https://github.com/trixi-framework/Trixi2Img.jl/raw/main/docs/src/assets/solution_000040_scalar_resized.png)

To visualize 3D data generated by Trixi.jl, a 2D slice must be extracted.
A slice can only lie in a plane orthogonal to one of the coordinate axes.
The slice plane is defined by the axis to which it is orthogonal and an axis intercept.

For example, to create a 2D slice in the xy-plane at the axis intercept `z = 0.5` from 3D data, execute
```julia
julia> trixi2img(joinpath("out", "solution_000000.h5"), output_directory="out", grid_lines=true, slice_axis=:z, slice_axis_intercept=0.5)
```

Similar to [Trixi2Vtk](@ref), you can also provide multiple files to
`trixi2img` or use file globbing, e.g.,
```julia
julia> trixi2img("out/solution_*.h5")
```
to convert all solution files. The default is to generate a PNG file for each
variable found in the respective file. Use `format=:pdf` as a keyword argument
to create PDF files. A comprehensive list of all possible arguments for
`trixi2img` can be found in the [Trixi2Img.jl API](@ref).
